---
phase: 04-sanctions-identity-screening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/sanctions/fuzzy-match.ts
  - src/lib/sanctions/name-normalizer.ts
  - src/lib/sanctions/__tests__/fuzzy-match.test.ts
autonomous: true

must_haves:
  truths:
    - "Name variations like Mohammed/Muhammad/Mohamed match with appropriate confidence"
    - "Transliterated names (Arabic, Cyrillic) are normalized before comparison"
    - "Fuzzy matching returns scored results sorted by similarity"
    - "Phonetic matching catches names that sound similar but spell differently"
  artifacts:
    - path: "src/lib/sanctions/fuzzy-match.ts"
      provides: "Fuzzy name matching engine with multiple algorithms"
      exports: ["fuzzyMatchName", "FuzzyMatchResult"]
    - path: "src/lib/sanctions/name-normalizer.ts"
      provides: "Name normalization and transliteration utilities"
      exports: ["normalizeName", "normalizeArabicName", "generatePhoneticCodes"]
    - path: "src/lib/sanctions/__tests__/fuzzy-match.test.ts"
      provides: "Test suite for fuzzy matching edge cases"
  key_links:
    - from: "src/lib/sanctions/fuzzy-match.ts"
      to: "src/lib/sanctions/name-normalizer.ts"
      via: "imports normalization functions"
      pattern: "import.*normalizeName.*from.*name-normalizer"
---

<objective>
Build the fuzzy name matching engine that powers sanctions screening. This is the algorithmic core — it determines whether a submitted name matches a sanctions entry, handling real-world name variations, transliterations, and phonetic similarities.

Purpose: Exact string matching misses 40-60% of real sanctions matches due to name variations, transliteration differences, and spelling inconsistencies. The fuzzy matching engine is what makes this a real screening system rather than a toy.

Output: A matching engine combining Levenshtein distance, Soundex/Double Metaphone phonetic matching, and name normalization — with comprehensive tests for edge cases.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build name normalization and phonetic encoding utilities</name>
  <files>src/lib/sanctions/name-normalizer.ts</files>
  <action>
  Create `src/lib/sanctions/name-normalizer.ts` with these exports:

  **normalizeName(name: string): string**
  - Convert to lowercase
  - Remove diacritics/accents (use String.normalize('NFD').replace(/[\u0300-\u036f]/g, ''))
  - Remove honorifics and titles: Dr., Mr., Mrs., Ms., Sheikh, Haji, Hajj, General, Colonel, etc.
  - Remove common prefixes that cause mismatches: "al-", "el-", "bin ", "ibn ", "abu "
    BUT store these separately — they're meaningful for disambiguation, just not for primary matching
  - Collapse multiple spaces to single space
  - Trim whitespace
  - Remove punctuation (periods, commas, hyphens used inconsistently)

  **normalizeArabicName(name: string): string**
  - Map common Arabic name transliteration variants:
    - Mohammed/Muhammad/Mohamed/Muhammed/Mohammad -> muhammad
    - Ahmed/Ahmad/Ahmet -> ahmad
    - Hussein/Husain/Hussain/Husein -> husayn
    - Osama/Usama -> usama
    - Abdul/Abdel/Abdoul -> abd
    - Abdulrahman/Abdelrahman/Abd al-Rahman -> abd rahman
    - Khaled/Khalid -> khalid
    - Hassan/Hasan -> hasan
    - Ibrahim/Ibraheem -> ibrahim
  - This is a lookup table of ~30-50 common variants, not a full transliteration engine
  - Apply AFTER normalizeName

  **generatePhoneticCodes(name: string): { soundex: string, metaphone: string }**
  - Implement Soundex algorithm (standard: keep first letter, map consonants to digits, collapse duplicates, pad to 4 chars)
  - Implement Double Metaphone (use the `double-metaphone` npm package — add to package.json)
  - Return both codes for each name token (split on spaces, generate codes per token)

  **splitNameTokens(fullName: string): string[]**
  - Split full name into individual tokens
  - Useful for matching individual parts (first name against first name, etc.)

  Do NOT over-engineer: This is a focused utility file. No classes, no complex inheritance. Pure functions.
  </action>
  <verify>
  - `npx tsc --noEmit src/lib/sanctions/name-normalizer.ts` compiles
  - normalizeName("Dr. Mohammed Al-Rahman") returns "mohammed rahman" (or similar normalized form)
  - normalizeArabicName("Mohammed") returns "muhammad"
  - generatePhoneticCodes("Smith") returns valid Soundex and Metaphone codes
  </verify>
  <done>Name normalization handles diacritics, honorifics, Arabic transliteration variants, and phonetic encoding. Pure functions, no external state.</done>
</task>

<task type="auto">
  <name>Task 2: Build fuzzy matching engine with tests</name>
  <files>src/lib/sanctions/fuzzy-match.ts, src/lib/sanctions/__tests__/fuzzy-match.test.ts</files>
  <action>
  Create `src/lib/sanctions/fuzzy-match.ts`:

  **Types:**
  ```typescript
  export interface FuzzyMatchResult {
    score: number;        // 0-1 overall similarity
    matchType: 'exact' | 'normalized_exact' | 'fuzzy' | 'phonetic';
    details: {
      levenshteinScore: number;   // 0-1
      phoneticMatch: boolean;
      nameVariantMatch: boolean;  // Arabic normalization matched
      tokenOverlap: number;       // what fraction of name tokens overlap
    };
  }
  ```

  **fuzzyMatchName(query: string, candidate: string, options?: { threshold?: number }): FuzzyMatchResult | null**
  - Returns null if score below threshold (default 0.6)
  - Matching pipeline (in order, short-circuit on exact):
    1. **Exact match**: normalized query === normalized candidate -> score 1.0, type 'exact'
    2. **Normalized exact**: After Arabic normalization, exact match -> score 0.95, type 'normalized_exact'
    3. **Levenshtein**: Calculate Levenshtein distance, convert to similarity ratio (1 - distance/maxLength)
       - Use `fastest-levenshtein` npm package (fast C++ bindings) — add to package.json
    4. **Phonetic**: Compare Soundex and Double Metaphone codes of each name token
       - If all phonetic codes match -> boost score by 0.15
    5. **Token overlap**: Split both names into tokens, calculate Jaccard similarity (intersection/union)
       - Handles name reordering (e.g., "Smith John" vs "John Smith")

  - Combine scores: `finalScore = max(levenshteinScore, tokenOverlapScore) + phoneticBoost + variantBoost`
  - Cap at 1.0
  - Assign matchType based on what contributed most to the score

  **fuzzyMatchNames(query: string, candidates: string[]): FuzzyMatchResult[]**
  - Batch version — match query against multiple candidates
  - Return only matches above threshold, sorted by score descending
  - Used for scanning the full sanctions list

  Create test file `src/lib/sanctions/__tests__/fuzzy-match.test.ts`:

  Test cases that MUST pass:
  ```
  // Exact matches
  "John Smith" vs "John Smith" -> score 1.0, type 'exact'

  // Case/whitespace normalization
  "JOHN SMITH" vs "john smith" -> score ~1.0, type 'exact'

  // Arabic name variants
  "Mohammed Al-Rahman" vs "Muhammad Al Rahman" -> score >= 0.9
  "Osama bin Laden" vs "Usama bin Ladin" -> score >= 0.85
  "Ahmed Hassan" vs "Ahmad Hasan" -> score >= 0.9

  // Phonetic matches
  "Mikhail" vs "Michael" -> score >= 0.7
  "Sergei" vs "Sergey" -> score >= 0.8

  // Name reordering
  "Smith John" vs "John Smith" -> score >= 0.9 (token overlap catches this)

  // Partial matches (should be lower confidence)
  "John" vs "John Smith" -> score >= 0.5 but < 0.8

  // Non-matches (should return null or very low score)
  "John Smith" vs "Jane Doe" -> null (below threshold)
  "Ahmed Hassan" vs "Bob Wilson" -> null
  ```

  Run tests with: `npx vitest run src/lib/sanctions/__tests__/fuzzy-match.test.ts`
  If project uses Jest instead of Vitest, adapt accordingly. Check package.json for test runner.
  </action>
  <verify>
  - `npx tsc --noEmit src/lib/sanctions/fuzzy-match.ts` compiles
  - All test cases pass: `npx vitest run src/lib/sanctions/__tests__/fuzzy-match.test.ts` (or Jest equivalent)
  - "Osama bin Laden" vs "Usama bin Ladin" returns score >= 0.85
  - "John Smith" vs "Jane Doe" returns null (below threshold)
  </verify>
  <done>Fuzzy matching engine handles exact, normalized, Levenshtein, phonetic, and token-overlap matching. Arabic name variants resolved. All edge case tests passing.</done>
</task>

</tasks>

<verification>
- All tests in `src/lib/sanctions/__tests__/fuzzy-match.test.ts` pass
- TypeScript compiles without errors for all new files
- fuzzyMatchName correctly handles the critical "Mohammed"/"Muhammad" variant case
- Phonetic matching correctly identifies similar-sounding names
- Performance: matching one name against 100 candidates completes in < 100ms
</verification>

<success_criteria>
- Fuzzy matching engine produces scored results for name comparisons
- Arabic/transliteration name variants match with high confidence
- Phonetic matching catches sound-alike names
- Test suite validates all critical edge cases
- No external API dependencies — all matching runs locally
</success_criteria>

<output>
After completion, create `.planning/phases/04-sanctions-identity-screening/04-02-SUMMARY.md`
</output>

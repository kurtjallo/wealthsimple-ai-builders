---
phase: 04-sanctions-identity-screening
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/lib/sanctions/screening-service.ts
  - src/lib/sanctions/__tests__/screening-service.test.ts
autonomous: true

must_haves:
  truths:
    - "Screening a name returns matches from all three lists (OFAC, UN, PEP) in a single query"
    - "Results include confidence scores, match type, and evidence links"
    - "Fuzzy matching catches name variants that exact SQL queries would miss"
    - "Date of birth provides secondary verification to reduce false positives"
  artifacts:
    - path: "src/lib/sanctions/screening-service.ts"
      provides: "Unified sanctions screening query layer"
      exports: ["screenName", "screenIdentity", "ScreeningResult"]
      min_lines: 80
    - path: "src/lib/sanctions/__tests__/screening-service.test.ts"
      provides: "Integration tests for screening service"
  key_links:
    - from: "src/lib/sanctions/screening-service.ts"
      to: "supabase"
      via: "queries sanctions_entries and sanctions_aliases tables"
      pattern: "supabase.*from.*sanctions_entries"
    - from: "src/lib/sanctions/screening-service.ts"
      to: "src/lib/sanctions/fuzzy-match.ts"
      via: "applies fuzzy matching to database results"
      pattern: "import.*fuzzyMatchName.*from.*fuzzy-match"
    - from: "src/lib/sanctions/screening-service.ts"
      to: "src/lib/sanctions/types.ts"
      via: "returns SanctionsSearchResult[]"
      pattern: "SanctionsSearchResult"
---

<objective>
Build the unified sanctions screening service — the query layer that combines Supabase database searches with fuzzy matching to produce scored, evidence-linked screening results across all three sanctions lists.

Purpose: This is the service that agents will call. It abstracts the complexity of searching across OFAC, UN, and PEP lists with fuzzy matching into a clean API: give it a name (and optionally DOB, nationality), get back structured match results with confidence and evidence.

Output: Screening service with `screenName` and `screenIdentity` functions, plus integration tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sanctions-identity-screening/04-01-SUMMARY.md
@.planning/phases/04-sanctions-identity-screening/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build unified sanctions screening service</name>
  <files>src/lib/sanctions/screening-service.ts</files>
  <action>
  Create `src/lib/sanctions/screening-service.ts`:

  **Types:**
  ```typescript
  export interface ScreeningRequest {
    fullName: string;
    dateOfBirth?: string;     // ISO date string
    nationality?: string;
    documentNumber?: string;  // passport/ID number for future use
  }

  export interface ScreeningResult {
    screened_name: string;
    screening_date: string;  // ISO timestamp
    total_matches: number;
    matches: SanctionsSearchResult[];
    risk_level: 'clear' | 'potential_match' | 'strong_match';
    summary: string;  // human-readable one-liner: "No matches found" or "2 potential matches on OFAC SDN list"
  }
  ```

  **screenName(name: string, options?: { sources?: SanctionsListSource[], threshold?: number }): Promise<ScreeningResult>**

  Implementation:
  1. Normalize the input name using normalizeName + normalizeArabicName from name-normalizer.ts
  2. **Database pre-filter** — Use Supabase pg_trgm similarity to get candidate matches:
     ```sql
     SELECT * FROM sanctions_entries
     WHERE primary_name % $1  -- trigram similarity
     OR primary_name ILIKE '%' || $1 || '%'
     ORDER BY similarity(primary_name, $1) DESC
     LIMIT 100
     ```
     Also search sanctions_aliases:
     ```sql
     SELECT se.*, sa.alias_name FROM sanctions_aliases sa
     JOIN sanctions_entries se ON sa.entry_id = se.id
     WHERE sa.alias_name % $1
     OR sa.alias_name ILIKE '%' || $1 || '%'
     ORDER BY similarity(sa.alias_name, $1) DESC
     LIMIT 100
     ```
  3. **Fuzzy match refinement** — Run fuzzyMatchName on each database candidate against the input name
  4. **Deduplicate** — Same sanctions_entry may match on primary_name and alias; keep highest score
  5. **Sort** by score descending
  6. **Classify risk_level**:
     - 'clear': no matches above threshold (default 0.6)
     - 'potential_match': highest match score 0.6-0.85
     - 'strong_match': highest match score > 0.85
  7. **Generate summary**: "No matches found across OFAC, UN, PEP lists" or "1 strong match on OFAC SDN (score: 0.92), 2 potential matches on UN Security Council"

  Filter by sources if provided (e.g., only OFAC, or only PEP).

  **screenIdentity(request: ScreeningRequest): Promise<ScreeningResult>**

  Extended version that:
  1. Calls screenName with the fullName
  2. If dateOfBirth is provided and matches have DOB:
     - Exact DOB match -> boost score by 0.1 (strong secondary confirmation)
     - Same year but different date -> boost by 0.05
     - DOB mismatch -> reduce score by 0.1 (possible false positive)
  3. If nationality provided and matches have nationality:
     - Same nationality -> boost by 0.05
     - Different nationality -> no change (people have multiple nationalities)
  4. Re-sort and re-classify after adjustments
  5. Update summary to mention DOB/nationality verification

  **Important implementation notes:**
  - Use the Supabase client from the project's existing setup (check src/lib/supabase.ts or similar)
  - If pg_trgm similarity operator (%) is not available, fall back to ILIKE with first/last name tokens
  - Handle empty results gracefully — return ScreeningResult with matches: [], risk_level: 'clear'
  - All database queries should have reasonable limits (LIMIT 100) to prevent performance issues
  </action>
  <verify>
  - `npx tsc --noEmit src/lib/sanctions/screening-service.ts` compiles
  - screenName and screenIdentity are exported
  - ScreeningResult type includes all required fields
  - Function handles empty results without throwing
  </verify>
  <done>Unified screening service queries all three sanctions lists with fuzzy matching, DOB secondary verification, and confidence-scored results.</done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for screening service</name>
  <files>src/lib/sanctions/__tests__/screening-service.test.ts</files>
  <action>
  Create integration tests in `src/lib/sanctions/__tests__/screening-service.test.ts`.

  These tests need Supabase data loaded (from Plans 01 and 03). Structure tests to handle this:
  - Check if sanctions_entries table has data before running
  - If no data, skip with descriptive message (tests can run after data load)

  **Test cases:**

  1. **Clear result — no matches:**
     ```typescript
     const result = await screenName("John Everyman Smith XII");
     expect(result.risk_level).toBe('clear');
     expect(result.matches.length).toBe(0);
     ```

  2. **Strong match on known OFAC entry:**
     Pick a well-known name from the OFAC SDN list that is guaranteed to be present.
     Use a sanctions list name that's public knowledge (e.g., search for a common sanctioned entity name).
     ```typescript
     // Use a name known to be on OFAC SDN - find one after data load
     const result = await screenName("KNOWN_OFAC_NAME");
     expect(result.risk_level).toBe('strong_match');
     expect(result.matches[0].entry.source).toBe('OFAC_SDN');
     expect(result.matches[0].score).toBeGreaterThan(0.85);
     ```

  3. **Fuzzy match with name variant:**
     ```typescript
     // Search with common variant spelling
     const result = await screenName("Muhammad");  // Many OFAC entries use "Mohammed"
     // Should find matches with fuzzy matching
     if (result.matches.length > 0) {
       expect(result.matches.some(m => m.match_type === 'fuzzy' || m.match_type === 'phonetic')).toBe(true);
     }
     ```

  4. **PEP screening:**
     ```typescript
     const result = await screenName("Ahmad Al-Rashid");  // Known PEP entry from our mock data
     expect(result.matches.some(m => m.entry.source === 'PEP')).toBe(true);
     ```

  5. **DOB secondary verification:**
     ```typescript
     const result = await screenIdentity({
       fullName: "KNOWN_NAME",
       dateOfBirth: "1980-01-01",  // matching DOB
     });
     // Score should be boosted compared to name-only search
     ```

  6. **Source filtering:**
     ```typescript
     const result = await screenName("Test Name", { sources: ['PEP'] });
     result.matches.forEach(m => expect(m.entry.source).toBe('PEP'));
     ```

  7. **Result structure validation:**
     ```typescript
     const result = await screenName("Any Name");
     expect(result).toHaveProperty('screened_name');
     expect(result).toHaveProperty('screening_date');
     expect(result).toHaveProperty('total_matches');
     expect(result).toHaveProperty('matches');
     expect(result).toHaveProperty('risk_level');
     expect(result).toHaveProperty('summary');
     ```

  Use the project's test runner (vitest or jest). Mock Supabase client if needed for unit test isolation, or run as integration tests against real Supabase.
  </action>
  <verify>
  - `npx tsc --noEmit src/lib/sanctions/__tests__/screening-service.test.ts` compiles
  - Tests pass: `npx vitest run src/lib/sanctions/__tests__/screening-service.test.ts` (or jest equivalent)
  - At minimum, structure validation and clear-result tests pass without database dependency
  </verify>
  <done>Integration tests validate screening service returns correct structure, handles clear/match/strong-match cases, and DOB secondary verification works.</done>
</task>

</tasks>

<verification>
- screenName("UNIQUE_FAKE_NAME") returns risk_level 'clear' with 0 matches
- screenName with a known OFAC entry returns risk_level 'strong_match'
- screenIdentity with DOB match adjusts scores upward
- All tests pass
- TypeScript compiles without errors
</verification>

<success_criteria>
- Single function call screens against OFAC, UN, and PEP simultaneously
- Results include confidence scores, match types, and evidence
- DOB and nationality provide secondary verification
- Risk level classification (clear/potential/strong) works correctly
- Tests validate core screening scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/04-sanctions-identity-screening/04-04-SUMMARY.md`
</output>

---
phase: 07-agent-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/hooks/use-agent-status.ts
  - src/lib/hooks/use-pipeline-stream.ts
  - src/app/api/cases/[caseId]/stream/route.ts
  - src/app/api/cases/[caseId]/agents/route.ts
autonomous: true

must_haves:
  truths:
    - "Client can subscribe to real-time pipeline state updates for a case via SSE"
    - "Agent status changes (pending/running/completed/failed) stream to the browser as they happen"
    - "useAgentStatus hook provides typed agent status data with auto-reconnect"
    - "usePipelineStream hook provides the full pipeline state with live updates"
    - "Agent status API returns current agent_runs for a case from Supabase"
  artifacts:
    - path: "src/app/api/cases/[caseId]/stream/route.ts"
      provides: "SSE endpoint streaming PipelineState changes in real-time"
      exports: ["GET"]
    - path: "src/app/api/cases/[caseId]/agents/route.ts"
      provides: "REST endpoint returning current agent_runs for a case"
      exports: ["GET"]
    - path: "src/lib/hooks/use-pipeline-stream.ts"
      provides: "React hook that subscribes to SSE pipeline stream"
      exports: ["usePipelineStream"]
    - path: "src/lib/hooks/use-agent-status.ts"
      provides: "React hook that provides per-agent status derived from pipeline state"
      exports: ["useAgentStatus"]
  key_links:
    - from: "src/app/api/cases/[caseId]/stream/route.ts"
      to: "src/lib/agents/orchestrator.ts"
      via: "imports processCase with onStateChange callback wired to SSE"
      pattern: "import.*processCase.*from.*orchestrator"
    - from: "src/lib/hooks/use-pipeline-stream.ts"
      to: "src/app/api/cases/[caseId]/stream/route.ts"
      via: "EventSource connection to SSE endpoint"
      pattern: "EventSource.*stream"
    - from: "src/lib/hooks/use-agent-status.ts"
      to: "src/lib/hooks/use-pipeline-stream.ts"
      via: "derives per-agent status from pipeline state"
      pattern: "import.*usePipelineStream"
---

<objective>
Build the real-time agent status infrastructure: SSE (Server-Sent Events) endpoint that streams pipeline state changes, REST endpoint for current agent status, and React hooks that consume both for live UI updates.

Purpose: This is the data backbone for all visualization components. Without real-time streaming, the dashboard cannot show agents working in parallel — which is THE demo selling point ("3 minutes vs 5 days"). SSE was chosen over WebSockets because it works natively with Next.js API routes (no custom server needed), supports auto-reconnect, and is simpler for a unidirectional data flow.

Output: Two API routes (SSE stream + REST status) and two React hooks (usePipelineStream + useAgentStatus) that provide typed, real-time agent data to any component.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/index.ts (AgentType, AgentRunStatus)
@src/types/pipeline.ts (PipelineState, PipelineStage)
@src/lib/agents/orchestrator.ts (processCase, PipelineCallback)
@src/lib/supabase/server.ts (createServerSupabaseClient)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSE streaming endpoint and agent status REST endpoint</name>
  <files>src/app/api/cases/[caseId]/stream/route.ts, src/app/api/cases/[caseId]/agents/route.ts</files>
  <action>
    1. Create `src/app/api/cases/[caseId]/stream/route.ts` — SSE endpoint that streams pipeline state changes in real-time:

       ```typescript
       import { NextRequest } from 'next/server';
       import { processCase } from '@/lib/agents/orchestrator';
       import { registerAllStubs } from '@/lib/agents/stubs';
       import { createServerSupabaseClient } from '@/lib/supabase/server';
       import { PipelineState } from '@/types';

       // Register agents (stubs until real agents replace them)
       registerAllStubs();

       export async function GET(
         request: NextRequest,
         { params }: { params: Promise<{ caseId: string }> }
       ) {
         const { caseId } = await params;

         // Set up SSE response
         const encoder = new TextEncoder();
         const stream = new ReadableStream({
           async start(controller) {
             // Helper to send SSE events
             function sendEvent(event: string, data: unknown) {
               const payload = `event: ${event}\ndata: ${JSON.stringify(data)}\n\n`;
               controller.enqueue(encoder.encode(payload));
             }

             try {
               // Load case from Supabase to get processing input
               const supabase = createServerSupabaseClient();
               const { data: caseData, error: caseError } = await supabase
                 .from('cases')
                 .select('*')
                 .eq('id', caseId)
                 .single();

               if (caseError || !caseData) {
                 sendEvent('error', { message: `Case not found: ${caseId}` });
                 controller.close();
                 return;
               }

               // Load documents for this case
               const { data: documents } = await supabase
                 .from('documents')
                 .select('*')
                 .eq('case_id', caseId);

               // Update case status to processing
               await supabase
                 .from('cases')
                 .update({ status: 'processing' })
                 .eq('id', caseId);

               sendEvent('connected', { case_id: caseId, timestamp: new Date().toISOString() });

               // Process the case with real-time callbacks
               const pipelineState = await processCase(
                 {
                   case_id: caseId,
                   documents: (documents || []).map(doc => ({
                     id: doc.id,
                     file_url: doc.file_url,
                     file_name: doc.file_name,
                     type: doc.type as any,
                   })),
                   applicant_name: caseData.applicant_name,
                   applicant_email: caseData.applicant_email || '',
                 },
                 (state: PipelineState) => {
                   // Stream each state change to the client
                   sendEvent('pipeline_update', {
                     stage: state.stage,
                     updated_at: state.updated_at,
                     document_result: state.document_result ? {
                       success: state.document_result.success,
                       confidence: state.document_result.confidence,
                       duration_ms: state.document_result.duration_ms,
                       agent_type: state.document_result.agent_type,
                     } : null,
                     identity_result: state.identity_result ? {
                       success: state.identity_result.success,
                       confidence: state.identity_result.confidence,
                       duration_ms: state.identity_result.duration_ms,
                       agent_type: state.identity_result.agent_type,
                     } : null,
                     sanctions_result: state.sanctions_result ? {
                       success: state.sanctions_result.success,
                       confidence: state.sanctions_result.confidence,
                       duration_ms: state.sanctions_result.duration_ms,
                       agent_type: state.sanctions_result.agent_type,
                     } : null,
                     risk_result: state.risk_result ? {
                       success: state.risk_result.success,
                       confidence: state.risk_result.confidence,
                       duration_ms: state.risk_result.duration_ms,
                       agent_type: state.risk_result.agent_type,
                     } : null,
                     narrative_result: state.narrative_result ? {
                       success: state.narrative_result.success,
                       confidence: state.narrative_result.confidence,
                       duration_ms: state.narrative_result.duration_ms,
                       agent_type: state.narrative_result.agent_type,
                     } : null,
                     errors: state.errors,
                   });

                   // Also update agent_runs table in Supabase for persistence
                   updateAgentRuns(supabase, caseId, state).catch(console.error);
                 },
               );

               // Send final complete event with full pipeline state
               sendEvent('pipeline_complete', pipelineState);

               // Update case with final results
               if (pipelineState.stage === 'completed' && pipelineState.risk_result?.data) {
                 await supabase
                   .from('cases')
                   .update({
                     status: 'review',
                     risk_score: pipelineState.risk_result.data.risk_score,
                     risk_level: pipelineState.risk_result.data.risk_level,
                     narrative: pipelineState.narrative_result?.data?.narrative || null,
                   })
                   .eq('id', caseId);
               } else if (pipelineState.stage === 'failed') {
                 await supabase
                   .from('cases')
                   .update({ status: 'pending' })
                   .eq('id', caseId);
               }

             } catch (err) {
               const message = err instanceof Error ? err.message : 'Unknown error';
               sendEvent('error', { message });
             } finally {
               controller.close();
             }
           },
         });

         return new Response(stream, {
           headers: {
             'Content-Type': 'text/event-stream',
             'Cache-Control': 'no-cache, no-transform',
             'Connection': 'keep-alive',
             'X-Accel-Buffering': 'no', // Disable Nginx buffering
           },
         });
       }

       // Helper: update agent_runs table based on pipeline state
       async function updateAgentRuns(
         supabase: ReturnType<typeof createServerSupabaseClient>,
         caseId: string,
         state: PipelineState,
       ) {
         const agentResults = [
           { type: 'document_processor', result: state.document_result },
           { type: 'identity_verifier', result: state.identity_result },
           { type: 'sanctions_screener', result: state.sanctions_result },
           { type: 'risk_scorer', result: state.risk_result },
           { type: 'case_narrator', result: state.narrative_result },
         ];

         for (const { type, result } of agentResults) {
           if (result) {
             // Upsert agent run (create if not exists, update if exists)
             await supabase
               .from('agent_runs')
               .upsert(
                 {
                   case_id: caseId,
                   agent_type: type,
                   status: result.success ? 'completed' : 'failed',
                   started_at: state.started_at,
                   completed_at: new Date().toISOString(),
                   output: result.data as any,
                   confidence: result.confidence,
                   error: result.error,
                 },
                 { onConflict: 'case_id,agent_type', ignoreDuplicates: false }
               );
           }
         }

         // Create 'running' entries for agents in current stage that haven't completed
         const runningAgents = getRunningAgents(state.stage);
         for (const agentType of runningAgents) {
           const existing = agentResults.find(a => a.type === agentType && a.result);
           if (!existing) {
             await supabase
               .from('agent_runs')
               .upsert(
                 {
                   case_id: caseId,
                   agent_type: agentType,
                   status: 'running',
                   started_at: new Date().toISOString(),
                 },
                 { onConflict: 'case_id,agent_type', ignoreDuplicates: false }
               );
           }
         }
       }

       function getRunningAgents(stage: string): string[] {
         switch (stage) {
           case 'document_processing': return ['document_processor'];
           case 'parallel_verification': return ['identity_verifier', 'sanctions_screener'];
           case 'risk_scoring': return ['risk_scorer'];
           case 'narrative_generation': return ['case_narrator'];
           default: return [];
         }
       }
       ```

       IMPORTANT NOTES:
       - The SSE endpoint uses `ReadableStream` which works in Next.js Edge and Node runtimes.
       - The `onStateChange` callback fires on every pipeline stage transition, streaming updates to the client immediately.
       - Agent run results are also persisted to the `agent_runs` table for subsequent page loads (REST fallback).
       - The `upsert` on `case_id,agent_type` requires a unique constraint on those columns. If the migration from Phase 1 doesn't have it, the executor should add `CREATE UNIQUE INDEX IF NOT EXISTS idx_agent_runs_case_agent ON agent_runs(case_id, agent_type);` to the schema or handle the upsert gracefully. Alternatively, use a select-then-insert-or-update pattern.

    2. Create `src/app/api/cases/[caseId]/agents/route.ts` — REST endpoint returning current agent status:

       ```typescript
       import { NextRequest, NextResponse } from 'next/server';
       import { createServerSupabaseClient } from '@/lib/supabase/server';

       export async function GET(
         request: NextRequest,
         { params }: { params: Promise<{ caseId: string }> }
       ) {
         const { caseId } = await params;
         const supabase = createServerSupabaseClient();

         const { data: agentRuns, error } = await supabase
           .from('agent_runs')
           .select('*')
           .eq('case_id', caseId)
           .order('created_at', { ascending: true });

         if (error) {
           return NextResponse.json(
             { error: `Failed to fetch agent runs: ${error.message}` },
             { status: 500 },
           );
         }

         // Build per-agent status map
         const agentStatus: Record<string, {
           status: string;
           confidence: number | null;
           duration_ms: number | null;
           error: string | null;
           started_at: string | null;
           completed_at: string | null;
         }> = {};

         const allAgentTypes = [
           'document_processor',
           'identity_verifier',
           'sanctions_screener',
           'risk_scorer',
           'case_narrator',
         ];

         for (const agentType of allAgentTypes) {
           const run = agentRuns?.find(r => r.agent_type === agentType);
           agentStatus[agentType] = run
             ? {
                 status: run.status,
                 confidence: run.confidence,
                 duration_ms: run.completed_at && run.started_at
                   ? new Date(run.completed_at).getTime() - new Date(run.started_at).getTime()
                   : null,
                 error: run.error,
                 started_at: run.started_at,
                 completed_at: run.completed_at,
               }
             : {
                 status: 'pending',
                 confidence: null,
                 duration_ms: null,
                 error: null,
                 started_at: null,
                 completed_at: null,
               };
         }

         return NextResponse.json({
           case_id: caseId,
           agents: agentStatus,
           total: agentRuns?.length || 0,
           timestamp: new Date().toISOString(),
         });
       }
       ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes for both route files
    - SSE endpoint returns `Content-Type: text/event-stream`
    - SSE endpoint streams `connected`, `pipeline_update`, and `pipeline_complete` events
    - Agent status REST endpoint returns per-agent status for all 5 agents
    - REST endpoint returns `pending` for agents that haven't started yet
  </verify>
  <done>
    SSE streaming endpoint wires the orchestrator's onStateChange callback to Server-Sent Events. REST endpoint provides fallback agent status from Supabase. Both endpoints are typed and handle errors gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React hooks for real-time agent status consumption</name>
  <files>src/lib/hooks/use-pipeline-stream.ts, src/lib/hooks/use-agent-status.ts</files>
  <action>
    1. Create `src/lib/hooks/use-pipeline-stream.ts` — React hook that subscribes to the SSE pipeline stream:

       ```typescript
       'use client';

       import { useState, useEffect, useCallback, useRef } from 'react';
       import { PipelineStage } from '@/types';

       // Lightweight pipeline update (what SSE sends — not the full PipelineState)
       export interface PipelineUpdate {
         stage: PipelineStage;
         updated_at: string;
         document_result: AgentResultSummary | null;
         identity_result: AgentResultSummary | null;
         sanctions_result: AgentResultSummary | null;
         risk_result: AgentResultSummary | null;
         narrative_result: AgentResultSummary | null;
         errors: Array<{ stage: string; agent_type: string; error_message: string }>;
       }

       export interface AgentResultSummary {
         success: boolean;
         confidence: number;
         duration_ms: number;
         agent_type: string;
       }

       export type StreamStatus = 'idle' | 'connecting' | 'connected' | 'completed' | 'error';

       export interface UsePipelineStreamReturn {
         status: StreamStatus;
         pipelineUpdate: PipelineUpdate | null;
         completePipelineState: unknown | null; // Full state on completion
         error: string | null;
         startStream: (caseId: string) => void;
         stopStream: () => void;
       }

       export function usePipelineStream(): UsePipelineStreamReturn {
         const [status, setStatus] = useState<StreamStatus>('idle');
         const [pipelineUpdate, setPipelineUpdate] = useState<PipelineUpdate | null>(null);
         const [completePipelineState, setCompletePipelineState] = useState<unknown | null>(null);
         const [error, setError] = useState<string | null>(null);
         const eventSourceRef = useRef<EventSource | null>(null);

         const stopStream = useCallback(() => {
           if (eventSourceRef.current) {
             eventSourceRef.current.close();
             eventSourceRef.current = null;
           }
         }, []);

         const startStream = useCallback((caseId: string) => {
           // Clean up any existing connection
           stopStream();

           setStatus('connecting');
           setError(null);
           setPipelineUpdate(null);
           setCompletePipelineState(null);

           const eventSource = new EventSource(`/api/cases/${caseId}/stream`);
           eventSourceRef.current = eventSource;

           eventSource.addEventListener('connected', (event) => {
             setStatus('connected');
           });

           eventSource.addEventListener('pipeline_update', (event) => {
             try {
               const data: PipelineUpdate = JSON.parse(event.data);
               setPipelineUpdate(data);
             } catch (e) {
               console.error('Failed to parse pipeline update:', e);
             }
           });

           eventSource.addEventListener('pipeline_complete', (event) => {
             try {
               const data = JSON.parse(event.data);
               setCompletePipelineState(data);
               setStatus('completed');
             } catch (e) {
               console.error('Failed to parse pipeline complete:', e);
             }
             eventSource.close();
             eventSourceRef.current = null;
           });

           eventSource.addEventListener('error', (event) => {
             // Check if it's an SSE error event with data
             if (event instanceof MessageEvent && event.data) {
               try {
                 const data = JSON.parse(event.data);
                 setError(data.message || 'Unknown error');
               } catch {
                 setError('Stream error');
               }
             }
             setStatus('error');
             eventSource.close();
             eventSourceRef.current = null;
           });

           // Handle native EventSource errors (connection failures)
           eventSource.onerror = () => {
             if (eventSource.readyState === EventSource.CLOSED) {
               // Stream was closed normally — don't report as error if we already completed
               if (status !== 'completed') {
                 setStatus('error');
                 setError('Connection lost');
               }
             }
           };
         }, [stopStream, status]);

         // Cleanup on unmount
         useEffect(() => {
           return () => {
             stopStream();
           };
         }, [stopStream]);

         return {
           status,
           pipelineUpdate,
           completePipelineState,
           error,
           startStream,
           stopStream,
         };
       }
       ```

    2. Create `src/lib/hooks/use-agent-status.ts` — React hook that derives per-agent status from pipeline state:

       ```typescript
       'use client';

       import { useMemo } from 'react';
       import { AgentType, AgentRunStatus } from '@/types';
       import { PipelineUpdate, AgentResultSummary } from './use-pipeline-stream';

       export interface AgentStatusInfo {
         agentType: AgentType;
         label: string;
         description: string;
         status: AgentRunStatus;
         confidence: number | null;
         durationMs: number | null;
         error: string | null;
         order: number; // Pipeline order for layout
       }

       // Human-readable labels for each agent
       const AGENT_LABELS: Record<string, { label: string; description: string; order: number }> = {
         document_processor: {
           label: 'Document Processor',
           description: 'OCR extraction and structured data parsing',
           order: 1,
         },
         identity_verifier: {
           label: 'Identity Verifier',
           description: 'Cross-reference identity fields against application',
           order: 2,
         },
         sanctions_screener: {
           label: 'Sanctions Screener',
           description: 'Screen against UN, OFAC, and PEP databases',
           order: 2, // Same order as identity (parallel)
         },
         risk_scorer: {
           label: 'Risk Scorer',
           description: 'Aggregate signals into composite risk score',
           order: 3,
         },
         case_narrator: {
           label: 'Case Narrator',
           description: 'Generate human-readable risk assessment',
           order: 4,
         },
       };

       // Derive agent status from the current pipeline stage
       function deriveAgentStatus(
         agentType: string,
         pipelineUpdate: PipelineUpdate | null,
       ): { status: AgentRunStatus; result: AgentResultSummary | null } {
         if (!pipelineUpdate) {
           return { status: 'pending', result: null };
         }

         // Map agent type to its result field
         const resultMap: Record<string, AgentResultSummary | null> = {
           document_processor: pipelineUpdate.document_result,
           identity_verifier: pipelineUpdate.identity_result,
           sanctions_screener: pipelineUpdate.sanctions_result,
           risk_scorer: pipelineUpdate.risk_result,
           case_narrator: pipelineUpdate.narrative_result,
         };

         const result = resultMap[agentType];

         // If result exists, agent has completed (or failed)
         if (result) {
           return {
             status: result.success ? 'completed' : 'failed',
             result,
           };
         }

         // Determine if agent is currently running based on pipeline stage
         const stage = pipelineUpdate.stage;

         const isRunning =
           (agentType === 'document_processor' && stage === 'document_processing') ||
           (agentType === 'identity_verifier' && stage === 'parallel_verification') ||
           (agentType === 'sanctions_screener' && stage === 'parallel_verification') ||
           (agentType === 'risk_scorer' && stage === 'risk_scoring') ||
           (agentType === 'case_narrator' && stage === 'narrative_generation');

         return {
           status: isRunning ? 'running' : 'pending',
           result: null,
         };
       }

       export function useAgentStatus(
         pipelineUpdate: PipelineUpdate | null,
       ): AgentStatusInfo[] {
         return useMemo(() => {
           const agentTypes: AgentType[] = [
             'document_processor',
             'identity_verifier',
             'sanctions_screener',
             'risk_scorer',
             'case_narrator',
           ];

           return agentTypes.map((agentType) => {
             const meta = AGENT_LABELS[agentType];
             const { status, result } = deriveAgentStatus(agentType, pipelineUpdate);

             // Find error for this agent
             const agentError = pipelineUpdate?.errors.find(
               e => e.agent_type === agentType || e.agent_type.includes(agentType)
             );

             return {
               agentType,
               label: meta.label,
               description: meta.description,
               status,
               confidence: result?.confidence ?? null,
               durationMs: result?.duration_ms ?? null,
               error: agentError?.error_message ?? null,
               order: meta.order,
             };
           });
         }, [pipelineUpdate]);
       }
       ```

    IMPORTANT: Both hooks must have `'use client'` directive at the top since they use React state and effects.

    IMPORTANT: The `useAgentStatus` hook is intentionally pure — it takes `pipelineUpdate` as a parameter rather than internally subscribing to the stream. This makes it composable and testable. The parent component calls `usePipelineStream()` once and passes the update to `useAgentStatus()`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes for both hook files
    - `usePipelineStream` exports a hook that returns status, pipelineUpdate, error, startStream, stopStream
    - `useAgentStatus` exports a hook that returns AgentStatusInfo[] with all 5 agents
    - Both hooks have 'use client' directive
    - AgentStatusInfo includes label, description, status, confidence, durationMs, error, order
    - Agent status correctly derives 'running' from pipeline stage (e.g., parallel_verification = identity_verifier + sanctions_screener running)
  </verify>
  <done>
    Two React hooks provide the real-time data layer. usePipelineStream manages the SSE connection lifecycle. useAgentStatus derives per-agent status info with labels, descriptions, and pipeline order. Hooks are composable — parent subscribes once, children consume.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all 4 new files
2. SSE endpoint at `/api/cases/[caseId]/stream` returns `text/event-stream` content type
3. SSE streams `connected`, `pipeline_update`, and `pipeline_complete` events in sequence
4. REST endpoint at `/api/cases/[caseId]/agents` returns per-agent status with all 5 agents
5. `usePipelineStream` hook manages EventSource lifecycle with auto-cleanup on unmount
6. `useAgentStatus` hook correctly maps pipeline stages to per-agent running/pending/completed/failed
7. Identity verifier and sanctions screener both show as "running" during parallel_verification stage
8. Agent results persist to agent_runs table in Supabase
</verification>

<success_criteria>
- Real-time pipeline state streams to the browser via SSE (DASH-02 foundation)
- Per-agent status derived from pipeline stage with correct parallel semantics
- React hooks provide typed, composable data layer for visualization components
- Agent status persists to Supabase for page refresh resilience
</success_criteria>

<output>
After completion, create `.planning/phases/07-agent-visualization/07-01-SUMMARY.md`
</output>

---
phase: 03-document-processing
plan: 05
type: execute
wave: 3
depends_on: ["03-02", "03-04"]
files_modified:
  - src/app/api/documents/upload/route.ts
  - src/app/api/documents/process/route.ts
  - src/app/api/documents/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Documents can be uploaded via POST /api/documents/upload with multipart form data"
    - "Document processing can be triggered via POST /api/documents/process"
    - "Document results (extracted data, confidence) can be retrieved via GET /api/documents/[id]"
    - "API routes validate input and return proper error responses"
  artifacts:
    - path: "src/app/api/documents/upload/route.ts"
      provides: "Document upload endpoint"
      contains: "POST"
    - path: "src/app/api/documents/process/route.ts"
      provides: "Document processing trigger endpoint"
      contains: "POST"
    - path: "src/app/api/documents/[id]/route.ts"
      provides: "Document retrieval endpoint"
      contains: "GET"
  key_links:
    - from: "src/app/api/documents/upload/route.ts"
      to: "src/lib/supabase/storage.ts"
      via: "file upload"
      pattern: "import.*uploadDocument"
    - from: "src/app/api/documents/process/route.ts"
      to: "src/lib/agents/document-processor.ts"
      via: "agent invocation"
      pattern: "import.*documentProcessorAgent"
    - from: "src/app/api/documents/[id]/route.ts"
      to: "src/lib/supabase/documents.ts"
      via: "document retrieval"
      pattern: "import.*getDocument"
---

<objective>
Create the API routes for document upload, processing, and retrieval. These routes expose the document processing pipeline to the frontend and orchestrator.

Purpose: The dashboard and orchestrator need HTTP endpoints to upload documents, trigger processing, and retrieve results. These routes are the bridge between the UI/orchestrator and the document processing pipeline built in Plans 01-04.
Output: Three API routes: upload (multipart file -> Supabase Storage), process (trigger OCR + extraction), and retrieve (get document + extracted data).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-document-processing/03-02-SUMMARY.md
@.planning/phases/03-document-processing/03-04-SUMMARY.md
@src/lib/agents/document-processor.ts
@src/lib/supabase/documents.ts
@src/lib/supabase/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create document upload API route</name>
  <files>src/app/api/documents/upload/route.ts</files>
  <action>
    Create `src/app/api/documents/upload/route.ts` — handles multipart file uploads:

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { uploadDocument } from '@/lib/supabase/storage';
    import { createDocument } from '@/lib/supabase/documents';
    import { DocumentType } from '@/types/index';

    const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'application/pdf'];
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    const VALID_DOC_TYPES: DocumentType[] = ['passport', 'drivers_license', 'utility_bill', 'bank_statement', 'corporate_doc'];

    export async function POST(request: NextRequest) {
      try {
        const formData = await request.formData();
        const file = formData.get('file') as File | null;
        const caseId = formData.get('case_id') as string | null;
        const documentType = formData.get('document_type') as DocumentType | null;

        // Validate required fields
        if (!file) {
          return NextResponse.json({ error: 'No file provided' }, { status: 400 });
        }
        if (!caseId) {
          return NextResponse.json({ error: 'case_id is required' }, { status: 400 });
        }
        if (!documentType || !VALID_DOC_TYPES.includes(documentType)) {
          return NextResponse.json(
            { error: `document_type must be one of: ${VALID_DOC_TYPES.join(', ')}` },
            { status: 400 }
          );
        }

        // Validate file type
        if (!ALLOWED_TYPES.includes(file.type)) {
          return NextResponse.json(
            { error: `File type '${file.type}' not allowed. Allowed: ${ALLOWED_TYPES.join(', ')}` },
            { status: 400 }
          );
        }

        // Validate file size
        if (file.size > MAX_FILE_SIZE) {
          return NextResponse.json(
            { error: `File size ${(file.size / 1024 / 1024).toFixed(1)}MB exceeds maximum of 10MB` },
            { status: 400 }
          );
        }

        // Upload file to Supabase Storage
        const fileBuffer = Buffer.from(await file.arrayBuffer());
        const { path: storagePath } = await uploadDocument(
          caseId,
          file.name,
          fileBuffer,
          file.type
        );

        // Create document record in database
        const document = await createDocument({
          case_id: caseId,
          type: documentType,
          file_name: file.name,
          file_path: storagePath,
        });

        return NextResponse.json({
          document_id: document.id,
          file_name: document.file_name,
          document_type: document.type,
          processing_status: document.processing_status,
          message: 'Document uploaded successfully. Call POST /api/documents/process to start processing.',
        }, { status: 201 });

      } catch (error) {
        const message = error instanceof Error ? error.message : 'Upload failed';
        return NextResponse.json({ error: message }, { status: 500 });
      }
    }
    ```

    IMPORTANT: File validation happens BEFORE upload to Supabase. The route accepts multipart/form-data with fields: file (File), case_id (string), document_type (string). Max file size 10MB. Allowed types: JPEG, PNG, WebP, PDF.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exists at `src/app/api/documents/upload/route.ts`
    - Exports POST handler
    - Validates: file presence, case_id, document_type, file type, file size
    - Uploads to Supabase Storage, creates document record
    - Returns 201 with document_id on success, 400/500 on error
  </verify>
  <done>
    Document upload API route created. Accepts multipart file uploads with case_id and document_type, validates input, uploads to Supabase Storage, and creates a pending document record.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create document processing and retrieval API routes</name>
  <files>src/app/api/documents/process/route.ts, src/app/api/documents/[id]/route.ts</files>
  <action>
    1. Create `src/app/api/documents/process/route.ts` — triggers document processing via the Document Processor agent:

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { documentProcessorAgent, DocumentProcessorInput } from '@/lib/agents/document-processor';
    import { getDocument } from '@/lib/supabase/documents';
    import { DocumentType } from '@/types/index';

    export async function POST(request: NextRequest) {
      try {
        const body = await request.json();
        const { document_id } = body;

        if (!document_id) {
          return NextResponse.json({ error: 'document_id is required' }, { status: 400 });
        }

        // Fetch document record
        const document = await getDocument(document_id);
        if (!document) {
          return NextResponse.json({ error: 'Document not found' }, { status: 404 });
        }

        if (document.processing_status === 'completed') {
          return NextResponse.json({
            message: 'Document already processed',
            document_id: document.id,
            processing_status: document.processing_status,
            overall_confidence: document.overall_confidence,
          });
        }

        if (document.processing_status === 'processing') {
          return NextResponse.json({
            message: 'Document is currently being processed',
            document_id: document.id,
            processing_status: document.processing_status,
          });
        }

        // Run the Document Processor agent
        const input: DocumentProcessorInput = {
          case_id: document.case_id,
          document_id: document.id,
          document_type: document.type as DocumentType,
          file_path: document.file_path || undefined,
          file_url: document.file_url || undefined,
        };

        const result = await documentProcessorAgent.run(input);

        return NextResponse.json({
          document_id: document.id,
          status: result.status,
          confidence: result.confidence,
          processing_time_ms: result.processing_time_ms,
          warnings: result.warnings,
          error: result.error || null,
          extracted: result.data.extracted,
        });

      } catch (error) {
        const message = error instanceof Error ? error.message : 'Processing failed';
        return NextResponse.json({ error: message }, { status: 500 });
      }
    }
    ```

    2. Create `src/app/api/documents/[id]/route.ts` — retrieves a document and its extracted data:

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { getDocument } from '@/lib/supabase/documents';

    export async function GET(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      try {
        const { id } = await params;

        if (!id) {
          return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
        }

        const document = await getDocument(id);
        if (!document) {
          return NextResponse.json({ error: 'Document not found' }, { status: 404 });
        }

        return NextResponse.json({
          id: document.id,
          case_id: document.case_id,
          type: document.type,
          file_name: document.file_name,
          processing_status: document.processing_status,
          ocr_raw_text: document.ocr_raw_text,
          extracted_data: document.extracted_data,
          overall_confidence: document.overall_confidence,
          processing_time_ms: document.processing_time_ms,
          processing_error: document.processing_error,
          warnings: document.warnings,
          created_at: document.created_at,
          updated_at: document.updated_at,
        });

      } catch (error) {
        const message = error instanceof Error ? error.message : 'Failed to retrieve document';
        return NextResponse.json({ error: message }, { status: 500 });
      }
    }
    ```

    IMPORTANT NOTES:
    - The process endpoint is synchronous — it waits for the agent to complete before responding. For the demo, this is fine (processing takes 5-15 seconds). For production, this would be an async job.
    - The process endpoint checks if the document is already processed or currently processing and returns early.
    - The [id] route uses Next.js 15 dynamic route params pattern (params is a Promise).
    - Both routes return consistent JSON error shapes: `{ error: string }`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/app/api/documents/process/route.ts` exports POST handler
    - `src/app/api/documents/[id]/route.ts` exports GET handler
    - Process route: validates document_id, checks processing_status, invokes agent
    - Retrieval route: fetches document by ID, returns full data including extracted_data
    - Both routes return proper error responses (400, 404, 500)
  </verify>
  <done>
    Document processing trigger and retrieval API routes created. POST /api/documents/process invokes the Document Processor agent. GET /api/documents/[id] returns the document with all extracted data and confidence scores.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. Three API routes exist: /api/documents/upload, /api/documents/process, /api/documents/[id]
3. Upload validates file type, size, and required fields
4. Process invokes the Document Processor agent and returns results
5. Retrieval returns the full document record including extracted data
6. All routes handle errors with consistent JSON responses
</verification>

<success_criteria>
- Documents can be uploaded via the API (feeds into CASE-01 flow)
- Document processing can be triggered and returns structured results (DOC-01, DOC-02)
- Extracted data with confidence scores is retrievable (DOC-04)
- API routes serve as the interface between frontend/orchestrator and the processing pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/03-document-processing/03-05-SUMMARY.md`
</output>

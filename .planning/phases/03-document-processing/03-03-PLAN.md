---
phase: 03-document-processing
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/ocr/structured-extractor.ts
  - src/lib/ocr/extraction-prompts.ts
autonomous: true

must_haves:
  truths:
    - "Gemini can parse raw OCR text and return structured data matching the document type schema"
    - "Each extracted field includes a confidence score between 0.0 and 1.0"
    - "Extraction handles all four document types (passport, drivers_license, utility_bill, corporate_doc)"
    - "Missing or unclear fields get low confidence rather than being omitted"
  artifacts:
    - path: "src/lib/ocr/structured-extractor.ts"
      provides: "Gemini-powered structured data extraction from OCR text"
      contains: "extractStructuredData"
    - path: "src/lib/ocr/extraction-prompts.ts"
      provides: "Document-type-specific extraction prompts for Gemini"
      contains: "getExtractionPrompt"
  key_links:
    - from: "src/lib/ocr/structured-extractor.ts"
      to: "@google/generative-ai"
      via: "Gemini API call"
      pattern: "import.*GoogleGenerativeAI"
    - from: "src/lib/ocr/structured-extractor.ts"
      to: "src/types/documents.ts"
      via: "type imports for extraction output"
      pattern: "import.*ExtractedDocumentData"
    - from: "src/lib/ocr/structured-extractor.ts"
      to: "src/lib/ocr/extraction-prompts.ts"
      via: "prompt templates"
      pattern: "import.*getExtractionPrompt"
---

<objective>
Build the Gemini-powered structured data extractor that takes raw OCR text and produces typed, confidence-scored field extractions for each document type.

Purpose: Raw OCR text alone is useless for KYC — we need structured fields (name, DOB, address, document numbers) with confidence scores. Gemini is ideal for this because it can reason about ambiguous text, handle OCR errors, and assign meaningful confidence levels.
Output: A structured extractor that takes OCR text + document type and returns typed ExtractedDocumentData with per-field confidence scores.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-document-processing/03-01-SUMMARY.md
@src/types/documents.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create document-type-specific extraction prompts</name>
  <files>src/lib/ocr/extraction-prompts.ts</files>
  <action>
    Create `src/lib/ocr/extraction-prompts.ts` with extraction prompts for each document type. These prompts instruct Gemini to extract specific fields with confidence scores.

    ```typescript
    import { DocumentType } from '@/types/index';

    /**
     * Get the extraction prompt for a specific document type.
     * Each prompt instructs Gemini to extract fields and assign confidence scores.
     */
    export function getExtractionPrompt(documentType: DocumentType): string {
      const prompts: Record<DocumentType, string> = {
        passport: PASSPORT_PROMPT,
        drivers_license: DRIVERS_LICENSE_PROMPT,
        utility_bill: UTILITY_BILL_PROMPT,
        bank_statement: UTILITY_BILL_PROMPT, // Same structure as utility bill
        corporate_doc: CORPORATE_DOC_PROMPT,
      };

      return prompts[documentType];
    }

    const CONFIDENCE_INSTRUCTIONS = `
    For each field, assign a confidence score between 0.0 and 1.0:
    - 1.0: Text is clearly legible and unambiguous
    - 0.8-0.9: Text is legible but minor formatting issues
    - 0.6-0.7: Text is partially legible or requires interpretation
    - 0.3-0.5: Text is difficult to read, educated guess
    - 0.1-0.2: Very uncertain, minimal evidence
    - 0.0: Field not found in document

    For the "source" field, quote the relevant text from the OCR output that you extracted the value from. If the field is not found, set source to "not found in document".

    IMPORTANT: Always include ALL fields even if not found. Set value to empty string and confidence to 0.0 for missing fields. Never omit a field.
    `.trim();

    const PASSPORT_PROMPT = `
    Extract the following fields from this passport OCR text. Return ONLY valid JSON matching the schema below.

    ${CONFIDENCE_INSTRUCTIONS}

    Required JSON schema:
    {
      "full_name": { "value": "string", "confidence": number, "source": "string" },
      "date_of_birth": { "value": "string (YYYY-MM-DD format)", "confidence": number, "source": "string" },
      "nationality": { "value": "string", "confidence": number, "source": "string" },
      "passport_number": { "value": "string", "confidence": number, "source": "string" },
      "expiry_date": { "value": "string (YYYY-MM-DD format)", "confidence": number, "source": "string" },
      "gender": { "value": "string (M/F/X)", "confidence": number, "source": "string" },
      "issuing_country": { "value": "string", "confidence": number, "source": "string" },
      "mrz_line1": { "value": "string", "confidence": number, "source": "string" },
      "mrz_line2": { "value": "string", "confidence": number, "source": "string" }
    }

    Respond with ONLY the JSON object. No markdown, no explanation.
    `.trim();

    const DRIVERS_LICENSE_PROMPT = `
    Extract the following fields from this driver's license OCR text. Return ONLY valid JSON matching the schema below.

    ${CONFIDENCE_INSTRUCTIONS}

    Required JSON schema:
    {
      "full_name": { "value": "string", "confidence": number, "source": "string" },
      "date_of_birth": { "value": "string (YYYY-MM-DD format)", "confidence": number, "source": "string" },
      "address": { "value": "string (full address)", "confidence": number, "source": "string" },
      "license_number": { "value": "string", "confidence": number, "source": "string" },
      "expiry_date": { "value": "string (YYYY-MM-DD format)", "confidence": number, "source": "string" },
      "class": { "value": "string (license class/type)", "confidence": number, "source": "string" },
      "issuing_province_state": { "value": "string", "confidence": number, "source": "string" }
    }

    Respond with ONLY the JSON object. No markdown, no explanation.
    `.trim();

    const UTILITY_BILL_PROMPT = `
    Extract the following fields from this utility bill OCR text. Return ONLY valid JSON matching the schema below.

    ${CONFIDENCE_INSTRUCTIONS}

    Required JSON schema:
    {
      "account_holder_name": { "value": "string", "confidence": number, "source": "string" },
      "service_address": { "value": "string (full address)", "confidence": number, "source": "string" },
      "account_number": { "value": "string", "confidence": number, "source": "string" },
      "bill_date": { "value": "string (YYYY-MM-DD format)", "confidence": number, "source": "string" },
      "utility_provider": { "value": "string", "confidence": number, "source": "string" }
    }

    Respond with ONLY the JSON object. No markdown, no explanation.
    `.trim();

    const CORPORATE_DOC_PROMPT = `
    Extract the following fields from this corporate registration document OCR text. Return ONLY valid JSON matching the schema below.

    ${CONFIDENCE_INSTRUCTIONS}

    Required JSON schema:
    {
      "company_name": { "value": "string", "confidence": number, "source": "string" },
      "registration_number": { "value": "string", "confidence": number, "source": "string" },
      "incorporation_date": { "value": "string (YYYY-MM-DD format)", "confidence": number, "source": "string" },
      "registered_address": { "value": "string (full address)", "confidence": number, "source": "string" },
      "directors": { "value": ["string array of director names"], "confidence": number, "source": "string" },
      "jurisdiction": { "value": "string (province/state/country)", "confidence": number, "source": "string" },
      "company_type": { "value": "string (e.g., Corporation, LLC, Partnership)", "confidence": number, "source": "string" }
    }

    Respond with ONLY the JSON object. No markdown, no explanation.
    `.trim();
    ```

    IMPORTANT: The prompts ask Gemini to return ONLY JSON, no markdown wrapping. This makes parsing reliable. The confidence instructions are shared across all prompts to ensure consistent scoring.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/lib/ocr/extraction-prompts.ts` exports getExtractionPrompt function
    - getExtractionPrompt returns different prompts for each DocumentType
    - All prompts include confidence scoring instructions
    - All prompts specify the exact JSON schema expected
  </verify>
  <done>
    Extraction prompts created for all four document types (passport, driver's license, utility bill, corporate registration) with shared confidence scoring instructions and strict JSON output format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Gemini structured data extractor with confidence scoring</name>
  <files>src/lib/ocr/structured-extractor.ts</files>
  <action>
    Create `src/lib/ocr/structured-extractor.ts` — uses Gemini to extract structured data from raw OCR text:

    ```typescript
    import { GoogleGenerativeAI } from '@google/generative-ai';
    import { DocumentType } from '@/types/index';
    import {
      ExtractedField,
      ExtractedDocumentData,
      PassportData,
      DriversLicenseData,
      UtilityBillData,
      CorporateDocData,
    } from '@/types/documents';
    import { getExtractionPrompt } from './extraction-prompts';

    const MODEL = 'gemini-2.5-pro';

    function getGoogleGenAIClient(): GoogleGenerativeAI {
      const apiKey = process.env.GEMINI_API_KEY;
      if (!apiKey) {
        throw new Error('GEMINI_API_KEY environment variable is not set');
      }
      return new GoogleGenerativeAI(apiKey);
    }

    /**
     * Extract structured data from raw OCR text using Gemini.
     * Returns typed extracted data with per-field confidence scores.
     */
    export async function extractStructuredData(
      ocrText: string,
      documentType: DocumentType
    ): Promise<{
      extracted: ExtractedDocumentData;
      overall_confidence: number;
      warnings: string[];
    }> {
      const client = getGoogleGenAIClient();
      const prompt = getExtractionPrompt(documentType);
      const model = client.getGenerativeModel({ model: MODEL });

      const result = await model.generateContent(
        `Here is the OCR text extracted from a ${documentType.replace('_', ' ')} document:\n\n---\n${ocrText}\n---\n\n${prompt}`
      );

      // Extract text content from Gemini's response
      const responseText = result.response.text();

      // Parse JSON response - strip any markdown code fences if Gemini adds them
      const cleanJson = responseText
        .replace(/^```json?\n?/m, '')
        .replace(/\n?```$/m, '')
        .trim();

      const parsed = JSON.parse(cleanJson);

      // Build typed extraction based on document type
      const { extracted, warnings } = buildTypedExtraction(documentType, parsed);

      // Calculate overall confidence as average of all field confidences
      const overall_confidence = calculateOverallConfidence(extracted);

      return { extracted, overall_confidence, warnings };
    }

    /**
     * Build typed extraction from parsed JSON, validating field structure.
     */
    function buildTypedExtraction(
      documentType: DocumentType,
      parsed: Record<string, unknown>
    ): { extracted: ExtractedDocumentData; warnings: string[] } {
      const warnings: string[] = [];

      function extractField<T = string>(
        obj: Record<string, unknown>,
        key: string,
        fieldName: string
      ): ExtractedField<T> {
        const field = obj[key] as Record<string, unknown> | undefined;
        if (!field) {
          warnings.push(`Missing field: ${fieldName}`);
          return { value: '' as unknown as T, confidence: 0, source: 'not found in extraction' };
        }
        return {
          value: (field.value ?? '') as T,
          confidence: typeof field.confidence === 'number' ? Math.max(0, Math.min(1, field.confidence)) : 0,
          source: (field.source as string) || 'not specified',
        };
      }

      switch (documentType) {
        case 'passport': {
          const data: PassportData = {
            full_name: extractField(parsed, 'full_name', 'Full Name'),
            date_of_birth: extractField(parsed, 'date_of_birth', 'Date of Birth'),
            nationality: extractField(parsed, 'nationality', 'Nationality'),
            passport_number: extractField(parsed, 'passport_number', 'Passport Number'),
            expiry_date: extractField(parsed, 'expiry_date', 'Expiry Date'),
            gender: extractField(parsed, 'gender', 'Gender'),
            issuing_country: extractField(parsed, 'issuing_country', 'Issuing Country'),
            mrz_line1: parsed.mrz_line1 ? extractField(parsed, 'mrz_line1', 'MRZ Line 1') : undefined,
            mrz_line2: parsed.mrz_line2 ? extractField(parsed, 'mrz_line2', 'MRZ Line 2') : undefined,
          };
          return { extracted: { type: 'passport', data }, warnings };
        }

        case 'drivers_license': {
          const data: DriversLicenseData = {
            full_name: extractField(parsed, 'full_name', 'Full Name'),
            date_of_birth: extractField(parsed, 'date_of_birth', 'Date of Birth'),
            address: extractField(parsed, 'address', 'Address'),
            license_number: extractField(parsed, 'license_number', 'License Number'),
            expiry_date: extractField(parsed, 'expiry_date', 'Expiry Date'),
            class: extractField(parsed, 'class', 'License Class'),
            issuing_province_state: extractField(parsed, 'issuing_province_state', 'Issuing Province/State'),
          };
          return { extracted: { type: 'drivers_license', data }, warnings };
        }

        case 'utility_bill':
        case 'bank_statement': {
          const data: UtilityBillData = {
            account_holder_name: extractField(parsed, 'account_holder_name', 'Account Holder Name'),
            service_address: extractField(parsed, 'service_address', 'Service Address'),
            account_number: extractField(parsed, 'account_number', 'Account Number'),
            bill_date: extractField(parsed, 'bill_date', 'Bill Date'),
            utility_provider: extractField(parsed, 'utility_provider', 'Utility Provider'),
          };
          return { extracted: { type: 'utility_bill', data }, warnings };
        }

        case 'corporate_doc': {
          const data: CorporateDocData = {
            company_name: extractField(parsed, 'company_name', 'Company Name'),
            registration_number: extractField(parsed, 'registration_number', 'Registration Number'),
            incorporation_date: extractField(parsed, 'incorporation_date', 'Incorporation Date'),
            registered_address: extractField(parsed, 'registered_address', 'Registered Address'),
            directors: extractField<string[]>(parsed, 'directors', 'Directors'),
            jurisdiction: extractField(parsed, 'jurisdiction', 'Jurisdiction'),
            company_type: extractField(parsed, 'company_type', 'Company Type'),
          };
          return { extracted: { type: 'corporate_doc', data }, warnings };
        }

        default:
          throw new Error(`Unsupported document type: ${documentType}`);
      }
    }

    /**
     * Calculate the overall confidence as the mean of all field confidences.
     */
    function calculateOverallConfidence(extracted: ExtractedDocumentData): number {
      const fields = Object.values(extracted.data) as ExtractedField[];
      if (fields.length === 0) return 0;

      const totalConfidence = fields.reduce((sum, field) => {
        if (typeof field === 'object' && field !== null && 'confidence' in field) {
          return sum + (field as ExtractedField).confidence;
        }
        return sum;
      }, 0);

      return Math.round((totalConfidence / fields.length) * 100) / 100;
    }
    ```

    IMPORTANT NOTES:
    - Uses Gemini 2.5 Pro (model ID: `gemini-2.5-pro`) — matches the project stack decision for reasoning tasks.
    - The JSON parsing includes cleanup for markdown code fences that Gemini sometimes adds despite instructions.
    - Confidence scores are clamped to [0, 1] range as a safety measure.
    - Missing fields generate warnings rather than throwing errors — partial extraction is better than failure.
    - The `extractField` helper provides a safe default for missing fields.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/lib/ocr/structured-extractor.ts` exports extractStructuredData
    - Function signature: takes (ocrText: string, documentType: DocumentType) and returns Promise with extracted, overall_confidence, warnings
    - Imports from @google/generative-ai (not a custom wrapper)
    - Uses gemini-2.5-pro model (not hardcoded to an old model)
    - No hardcoded API keys
  </verify>
  <done>
    Gemini-powered structured data extractor built. Takes raw OCR text + document type, calls Gemini with type-specific prompts, parses the JSON response into typed ExtractedDocumentData with per-field confidence scores. Handles all four document types with graceful degradation for missing fields.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. Extraction prompts cover all four document types
3. Structured extractor calls Gemini and returns typed data
4. Per-field confidence scores clamped to [0, 1]
5. Missing fields handled gracefully with warnings (not errors)
6. Overall confidence calculated as mean of all field confidences
</verification>

<success_criteria>
- Gemini extracts structured data from OCR text for all four document types (DOC-02)
- Every extracted field has a confidence score (DOC-04)
- Missing or unclear fields degrade gracefully with low confidence and warnings
- Extraction output matches the TypeScript types from Plan 01
</success_criteria>

<output>
After completion, create `.planning/phases/03-document-processing/03-03-SUMMARY.md`
</output>

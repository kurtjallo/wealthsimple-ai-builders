---
phase: 02-agent-orchestration-core
plan: 05
type: execute
wave: 4
depends_on: ["02-03", "02-04"]
files_modified:
  - src/app/api/cases/process/route.ts
  - src/lib/agents/__tests__/pipeline.test.ts
autonomous: true

must_haves:
  truths:
    - "A test case flows through the complete orchestration pipeline end-to-end with stub agents"
    - "The API endpoint accepts a case and returns the full pipeline state with all agent results"
    - "Pipeline transitions through all stages: initialized -> document_processing -> parallel_verification -> risk_scoring -> narrative_generation -> completed"
    - "Each agent result contains typed data, confidence scores, and timing"
  artifacts:
    - path: "src/app/api/cases/process/route.ts"
      provides: "POST endpoint that triggers full pipeline processing for a case"
      contains: "processCase"
    - path: "src/lib/agents/__tests__/pipeline.test.ts"
      provides: "Integration test proving end-to-end pipeline works with stubs"
      contains: "processCase"
  key_links:
    - from: "src/app/api/cases/process/route.ts"
      to: "src/lib/agents/orchestrator.ts"
      via: "calls processCase"
      pattern: "import.*processCase.*from.*orchestrator"
    - from: "src/app/api/cases/process/route.ts"
      to: "src/lib/agents/stubs/index.ts"
      via: "registers stubs before processing"
      pattern: "registerAllStubs"
    - from: "src/lib/agents/__tests__/pipeline.test.ts"
      to: "src/lib/agents/orchestrator.ts"
      via: "tests processCase end-to-end"
      pattern: "processCase"
---

<objective>
Create an API endpoint and integration test that prove the entire orchestration pipeline works end-to-end. A POST request triggers case processing through all 5 stages with stub agents and returns the full pipeline state.

Purpose: This is the proof that Phase 2 is complete — a real HTTP request flows through the orchestrator, spawns agents (stubs), and returns structured results. This validates every piece built in plans 01-04.
Output: Working API endpoint + passing integration test.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-agent-orchestration-core/02-02-SUMMARY.md
@.planning/phases/02-agent-orchestration-core/02-03-SUMMARY.md
@.planning/phases/02-agent-orchestration-core/02-04-SUMMARY.md
@src/lib/agents/orchestrator.ts
@src/lib/agents/stubs/index.ts
@src/types/pipeline.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create case processing API endpoint</name>
  <files>src/app/api/cases/process/route.ts</files>
  <action>
    Create `src/app/api/cases/process/route.ts` — a POST endpoint that:
    1. Accepts a case payload (case_id, applicant info, documents)
    2. Registers stub agents (until real agents replace them in later phases)
    3. Runs the full pipeline via `processCase`
    4. Returns the complete pipeline state as JSON

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { processCase, getPipelineSummary } from '@/lib/agents/orchestrator';
    import { registerAllStubs } from '@/lib/agents/stubs';
    import { DocumentType } from '@/types';

    // Register stubs on module load (will be replaced by real agents in later phases)
    registerAllStubs();

    interface ProcessCaseRequest {
      case_id: string;
      applicant_name: string;
      applicant_email: string;
      documents: Array<{
        id: string;
        file_url: string;
        file_name: string;
        type: DocumentType;
      }>;
    }

    export async function POST(request: NextRequest) {
      try {
        const body: ProcessCaseRequest = await request.json();

        // Validate required fields
        if (!body.case_id || !body.applicant_name || !body.applicant_email) {
          return NextResponse.json(
            { error: 'Missing required fields: case_id, applicant_name, applicant_email' },
            { status: 400 },
          );
        }

        if (!body.documents || body.documents.length === 0) {
          return NextResponse.json(
            { error: 'At least one document is required' },
            { status: 400 },
          );
        }

        // Process the case through the full pipeline
        const pipelineState = await processCase({
          case_id: body.case_id,
          documents: body.documents,
          applicant_name: body.applicant_name,
          applicant_email: body.applicant_email,
        });

        // Return full pipeline state
        return NextResponse.json({
          success: pipelineState.stage === 'completed',
          pipeline_state: pipelineState,
          summary: getPipelineSummary(pipelineState),
        });

      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        return NextResponse.json(
          { error: `Pipeline processing failed: ${message}` },
          { status: 500 },
        );
      }
    }
    ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/app/api/cases/process/route.ts` exports POST handler
    - POST handler validates required fields and returns 400 on missing data
    - POST handler calls `processCase` and returns pipeline state

    Manual verification with curl (after `npm run dev`):
    ```bash
    curl -X POST http://localhost:3000/api/cases/process \
      -H "Content-Type: application/json" \
      -d '{
        "case_id": "test-001",
        "applicant_name": "John Smith",
        "applicant_email": "john@example.com",
        "documents": [{
          "id": "doc-001",
          "file_url": "/uploads/passport.jpg",
          "file_name": "passport.jpg",
          "type": "passport"
        }]
      }'
    ```
    Expected: 200 response with `success: true`, `pipeline_state.stage: "completed"`, and all 5 agent results populated.
  </verify>
  <done>
    API endpoint processes cases through the full pipeline. Returns structured pipeline state with all agent results, timing data, and confidence scores.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test for end-to-end pipeline</name>
  <files>src/lib/agents/__tests__/pipeline.test.ts</files>
  <action>
    Create `src/lib/agents/__tests__/pipeline.test.ts` — a standalone test script that validates the full pipeline works.

    NOTE: This is NOT a Jest/Vitest test (no test framework in Phase 1). This is a runnable Node script that exercises the pipeline and asserts results. It exits with code 0 on success, 1 on failure.

    ```typescript
    /**
     * Integration test for the agent orchestration pipeline.
     * Run with: npx tsx src/lib/agents/__tests__/pipeline.test.ts
     *
     * Validates:
     * 1. Pipeline processes through all stages
     * 2. All agent results are populated
     * 3. State machine transitions are valid
     * 4. Error handling works for failed agents
     */

    import { processCase, createPipelineState, registerAgent, getPipelineSummary } from '../orchestrator';
    import { registerAllStubs } from '../stubs';
    import { PipelineState } from '@/types';

    let passed = 0;
    let failed = 0;

    function assert(condition: boolean, message: string): void {
      if (condition) {
        console.log(`  PASS: ${message}`);
        passed++;
      } else {
        console.error(`  FAIL: ${message}`);
        failed++;
      }
    }

    async function testHappyPath(): Promise<void> {
      console.log('\n--- Test: Happy Path (all stubs succeed) ---');

      registerAllStubs();

      const result = await processCase({
        case_id: 'test-happy-001',
        documents: [{ id: 'doc-001', file_url: '/test/passport.jpg', file_name: 'passport.jpg', type: 'passport' }],
        applicant_name: 'John Smith',
        applicant_email: 'john@test.com',
      });

      assert(result.stage === 'completed', `Pipeline completed (got: ${result.stage})`);
      assert(result.errors.length === 0, `No errors (got: ${result.errors.length})`);

      // All results populated
      assert(result.document_result !== null, 'Document result populated');
      assert(result.identity_result !== null, 'Identity result populated');
      assert(result.sanctions_result !== null, 'Sanctions result populated');
      assert(result.risk_result !== null, 'Risk result populated');
      assert(result.narrative_result !== null, 'Narrative result populated');

      // Results are successful
      assert(result.document_result!.success === true, 'Document processing succeeded');
      assert(result.identity_result!.success === true, 'Identity verification succeeded');
      assert(result.sanctions_result!.success === true, 'Sanctions screening succeeded');
      assert(result.risk_result!.success === true, 'Risk scoring succeeded');
      assert(result.narrative_result!.success === true, 'Narrative generation succeeded');

      // Confidence scores present
      assert(result.document_result!.confidence > 0, 'Document confidence > 0');
      assert(result.risk_result!.data!.risk_score >= 0, 'Risk score >= 0');

      // Timing data
      assert(result.document_result!.duration_ms > 0, 'Document has timing data');

      // Narrative content
      assert(result.narrative_result!.data!.narrative.length > 100, 'Narrative has content');
      assert(result.narrative_result!.data!.key_findings.length > 0, 'Narrative has key findings');

      console.log('\nPipeline Summary:');
      console.log(getPipelineSummary(result));
    }

    async function testStateCallbacks(): Promise<void> {
      console.log('\n--- Test: State Change Callbacks ---');

      registerAllStubs();

      const stages: string[] = [];

      await processCase(
        {
          case_id: 'test-callback-001',
          documents: [{ id: 'doc-001', file_url: '/test/passport.jpg', file_name: 'passport.jpg', type: 'passport' }],
          applicant_name: 'Jane Doe',
          applicant_email: 'jane@test.com',
        },
        (state: PipelineState) => {
          stages.push(state.stage);
        },
      );

      assert(stages.includes('initialized'), 'Callback received initialized');
      assert(stages.includes('document_processing'), 'Callback received document_processing');
      assert(stages.includes('parallel_verification'), 'Callback received parallel_verification');
      assert(stages.includes('risk_scoring'), 'Callback received risk_scoring');
      assert(stages.includes('narrative_generation'), 'Callback received narrative_generation');
      assert(stages.includes('completed'), 'Callback received completed');
      assert(stages.length >= 6, `At least 6 state changes (got: ${stages.length})`);
    }

    async function testFailedAgent(): Promise<void> {
      console.log('\n--- Test: Failed Agent (document processor) ---');

      // Register a failing document processor
      registerAgent('document_processor', async () => {
        throw new Error('OCR service timed out');
      });
      // Keep other stubs working
      registerAllStubs(); // This will re-register all (including doc processor with the stub)

      // Actually, we need to register the failing one AFTER stubs
      registerAgent('document_processor', async () => {
        throw new Error('OCR service timed out');
      });

      const result = await processCase({
        case_id: 'test-fail-001',
        documents: [{ id: 'doc-001', file_url: '/test/passport.jpg', file_name: 'passport.jpg', type: 'passport' }],
        applicant_name: 'Test Failure',
        applicant_email: 'fail@test.com',
      });

      assert(result.stage === 'failed', `Pipeline failed (got: ${result.stage})`);
      assert(result.errors.length > 0, 'Errors recorded');
      assert(result.document_result !== null, 'Document result exists (with failure)');
      assert(result.document_result!.success === false, 'Document result marked as failed');

      // Re-register stubs for subsequent tests
      registerAllStubs();
    }

    async function testPipelineStateCreation(): Promise<void> {
      console.log('\n--- Test: Pipeline State Creation ---');

      const state = createPipelineState('test-create-001');

      assert(state.case_id === 'test-create-001', 'Case ID set correctly');
      assert(state.stage === 'initialized', 'Initial stage is initialized');
      assert(state.document_result === null, 'Document result starts null');
      assert(state.identity_result === null, 'Identity result starts null');
      assert(state.sanctions_result === null, 'Sanctions result starts null');
      assert(state.risk_result === null, 'Risk result starts null');
      assert(state.narrative_result === null, 'Narrative result starts null');
      assert(state.errors.length === 0, 'No initial errors');
      assert(state.retry_count === 0, 'Retry count starts at 0');
    }

    // Run all tests
    async function main(): Promise<void> {
      console.log('=== Agent Orchestration Pipeline Integration Tests ===');

      await testPipelineStateCreation();
      await testHappyPath();
      await testStateCallbacks();
      await testFailedAgent();

      console.log(`\n=== Results: ${passed} passed, ${failed} failed ===`);

      if (failed > 0) {
        process.exit(1);
      }
    }

    main().catch((err) => {
      console.error('Test runner failed:', err);
      process.exit(1);
    });
    ```

    IMPORTANT: Install tsx as a dev dependency if not already present: `npm install -D tsx`

    IMPORTANT: The test uses `@/types` path alias. Create or verify a `tsconfig.json` path mapping exists. If tsx can't resolve `@/`, the test needs to use relative imports. Check the existing tsconfig first — if `@/*` is mapped to `./src/*`, tsx with `--tsconfig tsconfig.json` should work. The run command is:
    ```
    npx tsx --tsconfig tsconfig.json src/lib/agents/__tests__/pipeline.test.ts
    ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx tsx --tsconfig tsconfig.json src/lib/agents/__tests__/pipeline.test.ts` runs and all tests pass (exit code 0)
    - Happy path: pipeline completes with all 5 results populated
    - Callbacks: all 6 stage transitions fire
    - Failure: pipeline fails gracefully with error details
    - State creation: initial state has correct defaults

    Also verify the API endpoint:
    ```bash
    # Start dev server, then in another terminal:
    curl -s -X POST http://localhost:3000/api/cases/process \
      -H "Content-Type: application/json" \
      -d '{"case_id":"curl-test","applicant_name":"Test User","applicant_email":"test@test.com","documents":[{"id":"d1","file_url":"/test.jpg","file_name":"test.jpg","type":"passport"}]}' | jq .
    ```
    Expected: JSON with `success: true` and full pipeline_state
  </verify>
  <done>
    End-to-end integration test passes: full pipeline processes through all stages with stub agents. API endpoint accepts cases and returns complete pipeline results. Phase 2 success criteria validated.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all files
2. Integration test: `npx tsx --tsconfig tsconfig.json src/lib/agents/__tests__/pipeline.test.ts` exits with code 0
3. API endpoint: POST to /api/cases/process returns 200 with completed pipeline state
4. Pipeline goes through all 6 stages (initialized through completed)
5. All 5 agent results populated with typed data
6. Failed agent test: pipeline fails gracefully with errors recorded
7. Callback test: all stage transitions fire in order
</verification>

<success_criteria>
- Phase 2 Success Criterion 1: "Agent orchestrator can spawn and coordinate multiple agents in parallel" - PROVEN by happy path test and API endpoint
- Phase 2 Success Criterion 2: "Agents can pass structured data between each other" - PROVEN by risk scorer receiving upstream results
- Phase 2 Success Criterion 3: "Orchestrator handles agent failures gracefully" - PROVEN by failed agent test
- Phase 2 Success Criterion 4: "A test case flows through the orchestration pipeline end-to-end" - PROVEN by integration test and curl test
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-orchestration-core/02-05-SUMMARY.md`
</output>

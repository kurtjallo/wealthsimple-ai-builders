---
phase: 02-agent-orchestration-core
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/lib/agents/error-handling.ts
  - src/lib/agents/orchestrator.ts
autonomous: true

must_haves:
  truths:
    - "Agent timeouts are caught and produce a failed AgentResult with timeout error"
    - "Failed agents are retried with exponential backoff up to the configured retry count"
    - "If one parallel verification agent fails, the pipeline continues with the other's results"
    - "All errors are accumulated in PipelineState.errors with timestamps and recoverability"
  artifacts:
    - path: "src/lib/agents/error-handling.ts"
      provides: "Error classification, graceful degradation logic, and error formatting utilities"
      contains: "classifyError"
    - path: "src/lib/agents/orchestrator.ts"
      provides: "Updated orchestrator with graceful degradation for parallel stage"
      contains: "processCase"
  key_links:
    - from: "src/lib/agents/error-handling.ts"
      to: "src/types/pipeline.ts"
      via: "uses PipelineError type"
      pattern: "PipelineError"
    - from: "src/lib/agents/orchestrator.ts"
      to: "src/lib/agents/error-handling.ts"
      via: "imports error classification"
      pattern: "import.*from.*error-handling"
---

<objective>
Implement robust error handling for the agent pipeline — error classification, graceful degradation when parallel agents partially fail, and structured error reporting.

Purpose: The orchestrator must handle real-world failure modes: API timeouts, rate limits, invalid responses. A single agent failure shouldn't crash the entire pipeline. This plan makes the system resilient.
Output: Error handling utilities and an updated orchestrator that degrades gracefully.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-agent-orchestration-core/02-02-SUMMARY.md
@src/lib/agents/orchestrator.ts
@src/lib/agents/base-agent.ts
@src/types/pipeline.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error classification and degradation utilities</name>
  <files>src/lib/agents/error-handling.ts</files>
  <action>
    Create `src/lib/agents/error-handling.ts` with:

    ```typescript
    import { PipelineError, PipelineStage, AgentResult } from '@/types';

    // Error categories for classification
    export type ErrorCategory = 'timeout' | 'rate_limit' | 'api_error' | 'invalid_response' | 'network' | 'unknown';

    export interface ClassifiedError {
      category: ErrorCategory;
      message: string;
      recoverable: boolean;
      should_retry: boolean;
    }

    // Classify an error into a category with recovery guidance
    export function classifyError(error: unknown): ClassifiedError {
      const message = error instanceof Error ? error.message : String(error);

      if (message.includes('timed out') || message.includes('timeout') || message.includes('abort')) {
        return { category: 'timeout', message, recoverable: true, should_retry: true };
      }

      if (message.includes('429') || message.includes('rate limit') || message.includes('too many requests')) {
        return { category: 'rate_limit', message, recoverable: true, should_retry: true };
      }

      if (message.includes('500') || message.includes('502') || message.includes('503') || message.includes('internal server error')) {
        return { category: 'api_error', message, recoverable: true, should_retry: true };
      }

      if (message.includes('ECONNREFUSED') || message.includes('ENOTFOUND') || message.includes('fetch failed') || message.includes('network')) {
        return { category: 'network', message, recoverable: true, should_retry: true };
      }

      if (message.includes('invalid') || message.includes('parse') || message.includes('JSON') || message.includes('unexpected token')) {
        return { category: 'invalid_response', message, recoverable: false, should_retry: false };
      }

      return { category: 'unknown', message, recoverable: false, should_retry: false };
    }

    // Create a PipelineError from a classified error
    export function createPipelineError(
      stage: PipelineStage,
      agentType: string,
      error: ClassifiedError,
    ): PipelineError {
      return {
        stage,
        agent_type: agentType,
        error_message: `[${error.category}] ${error.message}`,
        timestamp: new Date().toISOString(),
        recoverable: error.recoverable,
      };
    }

    // Create a "degraded" result when an agent fails but pipeline should continue
    // Used when one of the parallel verification agents fails
    export function createDegradedResult<T>(
      agentType: string,
      errorMessage: string,
    ): AgentResult<T> {
      return {
        success: false,
        data: null,
        error: errorMessage,
        confidence: 0,
        duration_ms: 0,
        agent_type: agentType as any,
        metadata: { degraded: true },
      };
    }

    // Determine if the pipeline should continue after a parallel stage
    // Rule: Continue if at least one verification agent succeeded
    export function shouldContinueAfterParallelFailure(
      results: Array<AgentResult<unknown>>,
    ): boolean {
      return results.some(r => r.success);
    }

    // Format errors for logging/display
    export function formatPipelineErrors(errors: PipelineError[]): string {
      if (errors.length === 0) return 'No errors';
      return errors
        .map((e, i) => `${i + 1}. [${e.stage}] ${e.agent_type}: ${e.error_message} (${e.recoverable ? 'recoverable' : 'fatal'})`)
        .join('\n');
    }
    ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `classifyError` correctly categorizes: timeout, rate_limit, api_error, network, invalid_response, unknown
    - `shouldContinueAfterParallelFailure` returns true when at least one result succeeded
    - `createDegradedResult` produces a valid AgentResult with success=false
  </verify>
  <done>
    Error classification system with 6 categories, graceful degradation utilities for parallel failures, and structured error formatting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance orchestrator with graceful degradation and error reporting</name>
  <files>src/lib/agents/orchestrator.ts</files>
  <action>
    Update `src/lib/agents/orchestrator.ts` to integrate error handling:

    1. Import error handling utilities at top:
       ```typescript
       import { classifyError, createPipelineError, shouldContinueAfterParallelFailure, formatPipelineErrors } from './error-handling';
       ```

    2. Update the parallel verification stage in `processCase` to use graceful degradation:
       - Wrap `Promise.all` in `Promise.allSettled` to catch individual agent failures without failing the whole stage
       - If one agent fails, continue with the other's results
       - Only fail the stage if BOTH agents fail

       Replace the existing parallel verification block with:
       ```typescript
       // Stage 2: Parallel Verification (Identity + Sanctions run concurrently)
       state = transition(state, 'parallel_verification');
       notify(state);

       const verificationResults = await Promise.allSettled([
         runAgent<IdentityVerifierInput, IdentityVerifierOutput>(
           'identity_verifier',
           {
             case_id: input.case_id,
             extracted_fields: docResult.data!.extracted_fields,
             applicant_name: input.applicant_name,
           },
           AGENT_CONFIGS.identity_verifier,
           getHandler('identity_verifier'),
         ),
         runAgent<SanctionsScreenerInput, SanctionsScreenerOutput>(
           'sanctions_screener',
           {
             case_id: input.case_id,
             applicant_name: input.applicant_name,
             extracted_fields: docResult.data!.extracted_fields,
           },
           AGENT_CONFIGS.sanctions_screener,
           getHandler('sanctions_screener'),
         ),
       ]);

       // Extract results, creating degraded results for rejected promises
       const identityResult = verificationResults[0].status === 'fulfilled'
         ? verificationResults[0].value
         : createDegradedResult<IdentityVerifierOutput>('identity_verifier', (verificationResults[0] as PromiseRejectedResult).reason?.message || 'Unknown error');

       const sanctionsResult = verificationResults[1].status === 'fulfilled'
         ? verificationResults[1].value
         : createDegradedResult<SanctionsScreenerOutput>('sanctions_screener', (verificationResults[1] as PromiseRejectedResult).reason?.message || 'Unknown error');

       state = {
         ...state,
         identity_result: identityResult,
         sanctions_result: sanctionsResult,
         updated_at: new Date().toISOString(),
       };

       // Track individual agent errors
       if (!identityResult.success) {
         const classified = classifyError(new Error(identityResult.error || 'Unknown'));
         state.errors.push(createPipelineError('parallel_verification', 'identity_verifier', classified));
       }
       if (!sanctionsResult.success) {
         const classified = classifyError(new Error(sanctionsResult.error || 'Unknown'));
         state.errors.push(createPipelineError('parallel_verification', 'sanctions_screener', classified));
       }

       // Only fail if BOTH agents failed
       if (!shouldContinueAfterParallelFailure([identityResult, sanctionsResult])) {
         return handleFailure(state, 'parallel_verification', 'identity_verifier+sanctions_screener', 'Both verification agents failed');
       }
       ```

    3. Add `createDegradedResult` import from error-handling.

    4. Update `handleFailure` to use error classification:
       ```typescript
       function handleFailure(
         state: PipelineState,
         stage: PipelineStage,
         agentType: string,
         errorMessage: string,
       ): PipelineState {
         const classified = classifyError(new Error(errorMessage));
         return {
           ...state,
           stage: 'failed',
           errors: [...state.errors, createPipelineError(stage, agentType, classified)],
           updated_at: new Date().toISOString(),
         };
       }
       ```

    5. Add a `getPipelineSummary` export function that returns a human-readable status:
       ```typescript
       export function getPipelineSummary(state: PipelineState): string {
         const lines: string[] = [
           `Pipeline: ${state.case_id}`,
           `Stage: ${state.stage}`,
           `Started: ${state.started_at}`,
           `Updated: ${state.updated_at}`,
           `Errors: ${state.errors.length}`,
         ];

         if (state.errors.length > 0) {
           lines.push('', 'Error Details:');
           lines.push(formatPipelineErrors(state.errors));
         }

         if (state.stage === 'completed') {
           lines.push('', 'Results:');
           lines.push(`  Document: ${state.document_result?.success ? 'OK' : 'FAILED'}`);
           lines.push(`  Identity: ${state.identity_result?.success ? 'OK' : 'FAILED/DEGRADED'}`);
           lines.push(`  Sanctions: ${state.sanctions_result?.success ? 'OK' : 'FAILED/DEGRADED'}`);
           lines.push(`  Risk: ${state.risk_result?.success ? 'OK' : 'FAILED'}`);
           lines.push(`  Narrative: ${state.narrative_result?.success ? 'OK' : 'FAILED'}`);
         }

         return lines.join('\n');
       }
       ```

    IMPORTANT: Keep all existing `processCase` logic intact — only replace the parallel verification block and update handleFailure. Do not change the sequential stages (document_processing, risk_scoring, narrative_generation).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `processCase` uses `Promise.allSettled` for parallel verification
    - If identity_verifier fails but sanctions_screener succeeds, pipeline continues to risk_scoring
    - If both verification agents fail, pipeline transitions to 'failed'
    - All errors are accumulated in PipelineState.errors with proper classification
    - `getPipelineSummary` returns human-readable status
  </verify>
  <done>
    Orchestrator now handles partial failures in parallel stage gracefully. Error classification categorizes failures. Pipeline continues with degraded results when at least one verification agent succeeds.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with all error handling integrated
2. Error classification correctly identifies: timeout, rate_limit, api_error, network, invalid_response
3. Parallel verification degrades gracefully — one agent failure doesn't kill pipeline
4. Both agents failing causes pipeline failure
5. All errors accumulated with timestamps, categories, and recoverability
6. `getPipelineSummary` produces readable output for any pipeline state
</verification>

<success_criteria>
- Agent failures classified by category with retry guidance
- Parallel verification stage continues if at least one agent succeeds
- All errors accumulated in structured format with timestamps
- Pipeline summary function provides human-readable status at any point
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-orchestration-core/02-04-SUMMARY.md`
</output>

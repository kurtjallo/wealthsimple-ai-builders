---
phase: 02-agent-orchestration-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/agents/base-agent.ts
  - src/lib/agents/orchestrator.ts
  - src/lib/agents/agent-config.ts
autonomous: true

must_haves:
  truths:
    - "Orchestrator can spawn an agent function and receive a typed AgentResult"
    - "Orchestrator drives the pipeline state machine through stage transitions"
    - "Each pipeline stage triggers the correct agent(s) and advances state"
  artifacts:
    - path: "src/lib/agents/base-agent.ts"
      provides: "Base agent runner function that wraps Claude API calls with timing, error handling, and typed results"
      contains: "runAgent"
    - path: "src/lib/agents/orchestrator.ts"
      provides: "Pipeline orchestrator that manages state transitions and agent coordination"
      contains: "processCase"
    - path: "src/lib/agents/agent-config.ts"
      provides: "Default configurations for each agent type"
      contains: "AGENT_CONFIGS"
  key_links:
    - from: "src/lib/agents/orchestrator.ts"
      to: "src/lib/agents/base-agent.ts"
      via: "imports runAgent"
      pattern: "import.*runAgent.*from.*base-agent"
    - from: "src/lib/agents/orchestrator.ts"
      to: "src/types/pipeline.ts"
      via: "uses PipelineState and transitions"
      pattern: "import.*PipelineState.*from.*types"
    - from: "src/lib/agents/base-agent.ts"
      to: "src/types/agents.ts"
      via: "returns AgentResult<T>"
      pattern: "AgentResult"
---

<objective>
Build the orchestrator engine — the base agent runner and the pipeline state machine that coordinates agent execution. The orchestrator drives a case through all pipeline stages, spawning agents and collecting results.

Purpose: This is the backbone of the multi-agent system. It manages state transitions, triggers agents at the right stages, and collects results into a unified pipeline state. Everything else plugs into this.
Output: A working orchestrator that can process a case through the full pipeline (even with stub agents).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-agent-orchestration-core/02-01-SUMMARY.md
@src/types/agents.ts
@src/types/pipeline.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base agent runner and agent configs</name>
  <files>src/lib/agents/base-agent.ts, src/lib/agents/agent-config.ts</files>
  <action>
    1. Create `src/lib/agents/agent-config.ts` with default configurations per agent:

       ```typescript
       import { AgentConfig, AgentType } from '@/types';

       export const AGENT_CONFIGS: Record<AgentType, AgentConfig> = {
         orchestrator: {
           model: 'claude-sonnet-4-6',
           max_tokens: 4096,
           timeout_ms: 120000,    // 2 min
           retry_count: 2,
           temperature: 0,
         },
         document_processor: {
           model: 'claude-sonnet-4-6',
           max_tokens: 4096,
           timeout_ms: 60000,     // 1 min
           retry_count: 2,
           temperature: 0,
         },
         identity_verifier: {
           model: 'claude-haiku-4-5',  // Lighter model for verification
           max_tokens: 2048,
           timeout_ms: 30000,     // 30 sec
           retry_count: 2,
           temperature: 0,
         },
         sanctions_screener: {
           model: 'claude-haiku-4-5',
           max_tokens: 2048,
           timeout_ms: 30000,
           retry_count: 2,
           temperature: 0,
         },
         risk_scorer: {
           model: 'claude-sonnet-4-6',  // Needs reasoning
           max_tokens: 4096,
           timeout_ms: 45000,
           retry_count: 1,
           temperature: 0,
         },
         case_narrator: {
           model: 'claude-sonnet-4-6',
           max_tokens: 4096,
           timeout_ms: 60000,
           retry_count: 1,
           temperature: 0.3,     // Slight creativity for narrative
         },
       };
       ```

    2. Create `src/lib/agents/base-agent.ts` with the core agent execution function:

       ```typescript
       import Anthropic from '@anthropic-ai/sdk';
       import { AgentResult, AgentConfig, AgentType } from '@/types';

       const anthropic = new Anthropic();

       // Type for an agent handler function
       export type AgentHandler<TInput, TOutput> = (
         input: TInput,
         config: AgentConfig,
       ) => Promise<AgentResult<TOutput>>;

       // Core execution wrapper — handles timing, errors, retries
       export async function runAgent<TInput, TOutput>(
         agentType: AgentType,
         input: TInput,
         config: AgentConfig,
         handler: (input: TInput, client: Anthropic, config: AgentConfig) => Promise<TOutput>,
       ): Promise<AgentResult<TOutput>> {
         const startTime = Date.now();
         let lastError: string | null = null;

         for (let attempt = 0; attempt <= config.retry_count; attempt++) {
           try {
             // Create abort controller for timeout
             const controller = new AbortController();
             const timeoutId = setTimeout(() => controller.abort(), config.timeout_ms);

             const data = await Promise.race([
               handler(input, anthropic, config),
               new Promise<never>((_, reject) => {
                 controller.signal.addEventListener('abort', () => {
                   reject(new Error(`Agent ${agentType} timed out after ${config.timeout_ms}ms`));
                 });
               }),
             ]);

             clearTimeout(timeoutId);

             return {
               success: true,
               data,
               error: null,
               confidence: 1.0, // Handler should override this
               duration_ms: Date.now() - startTime,
               agent_type: agentType,
               metadata: { attempt },
             };
           } catch (error) {
             lastError = error instanceof Error ? error.message : String(error);
             console.error(`Agent ${agentType} attempt ${attempt + 1} failed:`, lastError);

             // Don't retry on last attempt
             if (attempt < config.retry_count) {
               // Exponential backoff: 1s, 2s, 4s...
               await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
             }
           }
         }

         return {
           success: false,
           data: null,
           error: lastError,
           confidence: 0,
           duration_ms: Date.now() - startTime,
           agent_type: agentType,
           metadata: { attempts: config.retry_count + 1 },
         };
       }
       ```

    IMPORTANT: The `Anthropic` client is instantiated once at module level — it reads `ANTHROPIC_API_KEY` from env automatically. Do NOT pass the key explicitly.

    IMPORTANT: Do NOT use `AbortSignal.timeout()` — it's not available in all Node versions. Use the manual abort controller + setTimeout pattern shown above.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - `src/lib/agents/base-agent.ts` exports `runAgent` and `AgentHandler`
    - `src/lib/agents/agent-config.ts` exports `AGENT_CONFIGS` with all 6 agent types
    - `runAgent` returns `AgentResult<TOutput>` with timing, confidence, and error handling
  </verify>
  <done>
    Base agent runner wraps any agent handler with timeout, retry (exponential backoff), and typed result collection. All agent configs defined with model, token limits, and timeouts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pipeline orchestrator with state machine</name>
  <files>src/lib/agents/orchestrator.ts</files>
  <action>
    Create `src/lib/agents/orchestrator.ts` — the main orchestrator that processes a case through the full pipeline.

    ```typescript
    import {
      PipelineState,
      PipelineStage,
      PipelineError,
      PIPELINE_TRANSITIONS,
      AgentResult,
      DocumentProcessorOutput,
      IdentityVerifierOutput,
      SanctionsScreenerOutput,
      RiskScorerOutput,
      CaseNarratorOutput,
      DocumentProcessorInput,
      IdentityVerifierInput,
      SanctionsScreenerInput,
      RiskScorerInput,
      CaseNarratorInput,
    } from '@/types';
    import { runAgent } from './base-agent';
    import { AGENT_CONFIGS } from './agent-config';

    // Agent handler registry — populated by registerAgent()
    // Each agent registers its handler here. Stubs are used until real agents are built.
    type AnyAgentHandler = (input: any, client: any, config: any) => Promise<any>;

    const agentHandlers: Map<string, AnyAgentHandler> = new Map();

    export function registerAgent(agentType: string, handler: AnyAgentHandler): void {
      agentHandlers.set(agentType, handler);
    }

    function getHandler(agentType: string): AnyAgentHandler {
      const handler = agentHandlers.get(agentType);
      if (!handler) {
        throw new Error(`No handler registered for agent type: ${agentType}`);
      }
      return handler;
    }

    // State machine transition validation
    function canTransition(from: PipelineStage, to: PipelineStage): boolean {
      return PIPELINE_TRANSITIONS[from].includes(to);
    }

    function transition(state: PipelineState, to: PipelineStage): PipelineState {
      if (!canTransition(state.stage, to)) {
        throw new Error(`Invalid transition: ${state.stage} -> ${to}`);
      }
      return {
        ...state,
        stage: to,
        updated_at: new Date().toISOString(),
      };
    }

    // Create initial pipeline state
    export function createPipelineState(caseId: string): PipelineState {
      return {
        case_id: caseId,
        stage: 'initialized',
        started_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        document_result: null,
        identity_result: null,
        sanctions_result: null,
        risk_result: null,
        narrative_result: null,
        errors: [],
        retry_count: 0,
      };
    }

    // Pipeline stage callback for real-time updates
    export type PipelineCallback = (state: PipelineState) => void;

    // Main orchestration function — processes a case through the full pipeline
    export async function processCase(
      input: {
        case_id: string;
        documents: DocumentProcessorInput['documents'];
        applicant_name: string;
        applicant_email: string;
      },
      onStateChange?: PipelineCallback,
    ): Promise<PipelineState> {
      let state = createPipelineState(input.case_id);
      const notify = (s: PipelineState) => { if (onStateChange) onStateChange(s); };

      notify(state);

      try {
        // Stage 1: Document Processing
        state = transition(state, 'document_processing');
        notify(state);

        const docResult = await runAgent<DocumentProcessorInput, DocumentProcessorOutput>(
          'document_processor',
          { case_id: input.case_id, documents: input.documents },
          AGENT_CONFIGS.document_processor,
          getHandler('document_processor'),
        );
        state = { ...state, document_result: docResult, updated_at: new Date().toISOString() };

        if (!docResult.success) {
          return handleFailure(state, 'document_processing', 'document_processor', docResult.error || 'Unknown error');
        }

        // Stage 2: Parallel Verification (Identity + Sanctions run concurrently)
        state = transition(state, 'parallel_verification');
        notify(state);

        const [identityResult, sanctionsResult] = await Promise.all([
          runAgent<IdentityVerifierInput, IdentityVerifierOutput>(
            'identity_verifier',
            {
              case_id: input.case_id,
              extracted_fields: docResult.data!.extracted_fields,
              applicant_name: input.applicant_name,
            },
            AGENT_CONFIGS.identity_verifier,
            getHandler('identity_verifier'),
          ),
          runAgent<SanctionsScreenerInput, SanctionsScreenerOutput>(
            'sanctions_screener',
            {
              case_id: input.case_id,
              applicant_name: input.applicant_name,
              extracted_fields: docResult.data!.extracted_fields,
            },
            AGENT_CONFIGS.sanctions_screener,
            getHandler('sanctions_screener'),
          ),
        ]);

        state = {
          ...state,
          identity_result: identityResult,
          sanctions_result: sanctionsResult,
          updated_at: new Date().toISOString(),
        };

        // If both failed, fail the pipeline. If one failed, continue with degraded results.
        if (!identityResult.success && !sanctionsResult.success) {
          return handleFailure(state, 'parallel_verification', 'identity_verifier+sanctions_screener', 'Both verification agents failed');
        }

        // Stage 3: Risk Scoring
        state = transition(state, 'risk_scoring');
        notify(state);

        const riskResult = await runAgent<RiskScorerInput, RiskScorerOutput>(
          'risk_scorer',
          {
            case_id: input.case_id,
            document_result: docResult,
            identity_result: identityResult,
            sanctions_result: sanctionsResult,
          },
          AGENT_CONFIGS.risk_scorer,
          getHandler('risk_scorer'),
        );
        state = { ...state, risk_result: riskResult, updated_at: new Date().toISOString() };

        if (!riskResult.success) {
          return handleFailure(state, 'risk_scoring', 'risk_scorer', riskResult.error || 'Unknown error');
        }

        // Stage 4: Narrative Generation
        state = transition(state, 'narrative_generation');
        notify(state);

        const narrativeResult = await runAgent<CaseNarratorInput, CaseNarratorOutput>(
          'case_narrator',
          {
            case_id: input.case_id,
            applicant_name: input.applicant_name,
            document_result: docResult,
            identity_result: identityResult,
            sanctions_result: sanctionsResult,
            risk_result: riskResult,
          },
          AGENT_CONFIGS.case_narrator,
          getHandler('case_narrator'),
        );
        state = { ...state, narrative_result: narrativeResult, updated_at: new Date().toISOString() };

        if (!narrativeResult.success) {
          return handleFailure(state, 'narrative_generation', 'case_narrator', narrativeResult.error || 'Unknown error');
        }

        // Pipeline complete
        state = transition(state, 'completed');
        notify(state);
        return state;

      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        state = {
          ...state,
          stage: 'failed',
          errors: [...state.errors, {
            stage: state.stage,
            agent_type: 'orchestrator',
            error_message: errorMsg,
            timestamp: new Date().toISOString(),
            recoverable: false,
          }],
          updated_at: new Date().toISOString(),
        };
        notify(state);
        return state;
      }
    }

    function handleFailure(
      state: PipelineState,
      stage: PipelineStage,
      agentType: string,
      errorMessage: string,
    ): PipelineState {
      return {
        ...state,
        stage: 'failed',
        errors: [...state.errors, {
          stage,
          agent_type: agentType,
          error_message: errorMessage,
          timestamp: new Date().toISOString(),
          recoverable: true,
        }],
        updated_at: new Date().toISOString(),
      };
    }
    ```

    Key design decisions:
    - **Agent registry pattern** — agents register their handlers via `registerAgent()`. This decouples the orchestrator from specific agent implementations. Stub agents and real agents plug in the same way.
    - **State machine transitions** — every stage change validated against `PIPELINE_TRANSITIONS`. Invalid transitions throw.
    - **Parallel execution** — IdentityVerifier and SanctionsScreener run via `Promise.all()`. Graceful degradation: if one fails but the other succeeds, pipeline continues.
    - **Callback-driven updates** — `onStateChange` callback fires on every stage transition for real-time UI updates.
    - **Error accumulation** — errors stack in `state.errors` array with recoverability flag.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - `src/lib/agents/orchestrator.ts` exports `processCase`, `createPipelineState`, `registerAgent`
    - `processCase` accepts case input and returns `Promise<PipelineState>`
    - Parallel agents (identity + sanctions) use `Promise.all`
    - State transitions validated against `PIPELINE_TRANSITIONS`
  </verify>
  <done>
    Pipeline orchestrator drives cases through all 5 stages, spawning agents via the registry, running verification agents in parallel, and collecting results into a unified PipelineState. State machine enforces valid transitions. Callback system enables real-time UI updates.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — orchestrator compiles against type contracts
2. `registerAgent` accepts any agent handler and stores it by type
3. `processCase` drives through: initialized -> document_processing -> parallel_verification -> risk_scoring -> narrative_generation -> completed
4. Parallel stage uses `Promise.all` for identity + sanctions
5. Failed agents produce `PipelineState.stage === 'failed'` with error details
6. `onStateChange` callback fires at every stage transition
</verification>

<success_criteria>
- Orchestrator can spawn agents via registry and coordinate the full pipeline
- Identity and sanctions verification run in parallel (Promise.all)
- State machine enforces valid transitions and rejects invalid ones
- Callback system enables real-time state observation
- Error handling captures failures with context and recoverability info
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-orchestration-core/02-02-SUMMARY.md`
</output>

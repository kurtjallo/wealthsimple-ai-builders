---
phase: 02-agent-orchestration-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/agents.ts
  - src/types/pipeline.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "Every agent has a typed input and output contract defined in TypeScript"
    - "The pipeline stages are typed as a state machine with clear transitions"
    - "Agent results include confidence scores, timing metadata, and error states"
  artifacts:
    - path: "src/types/agents.ts"
      provides: "Agent input/output interfaces for all 5 agent types plus orchestrator"
      contains: "DocumentProcessorInput"
    - path: "src/types/pipeline.ts"
      provides: "Pipeline stage definitions, state machine types, case processing state"
      contains: "PipelineStage"
    - path: "src/types/index.ts"
      provides: "Re-exports all agent and pipeline types"
      contains: "export * from"
  key_links:
    - from: "src/types/agents.ts"
      to: "src/types/index.ts"
      via: "re-export"
      pattern: "export \\* from.*agents"
    - from: "src/types/pipeline.ts"
      to: "src/types/agents.ts"
      via: "imports agent result types"
      pattern: "import.*from.*agents"
---

<objective>
Define the complete TypeScript type system for the multi-agent orchestration pipeline — agent input/output contracts, pipeline stages, state machine transitions, and shared result types.

Purpose: Every downstream plan depends on these types. Getting the contracts right first means agents, orchestrator, and pipeline all share a single source of truth. No `any` types, no guessing.
Output: Three type files that define the entire agent system's data contracts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent input/output type contracts</name>
  <files>src/types/agents.ts</files>
  <action>
    Create `src/types/agents.ts` with typed input/output contracts for every agent in the system. Import existing types from `./index` (Case, Document, AgentType, etc.) where needed.

    Define these interfaces:

    1. **Base agent types:**
       ```typescript
       // Generic result wrapper every agent returns
       export interface AgentResult<T> {
         success: boolean;
         data: T | null;
         error: string | null;
         confidence: number; // 0-1
         duration_ms: number;
         agent_type: AgentType;
         metadata: Record<string, unknown>;
       }

       // Base config for all agents
       export interface AgentConfig {
         model: string;           // e.g. "gemini-2.5-pro"
         max_tokens: number;
         timeout_ms: number;      // Max time before timeout
         retry_count: number;     // Number of retries on failure
         temperature?: number;
       }
       ```

    2. **DocumentProcessor:**
       ```typescript
       export interface DocumentProcessorInput {
         case_id: string;
         documents: Array<{
           id: string;
           file_url: string;
           file_name: string;
           type: DocumentType;
         }>;
       }

       export interface ExtractedField {
         field_name: string;      // e.g. "full_name", "date_of_birth"
         value: string;
         confidence: number;      // 0-1
         source_document_id: string;
       }

       export interface DocumentProcessorOutput {
         extracted_fields: ExtractedField[];
         raw_ocr_text: Record<string, string>;  // doc_id -> ocr text
         document_quality: Record<string, number>; // doc_id -> quality 0-1
       }
       ```

    3. **IdentityVerifier:**
       ```typescript
       export interface IdentityVerifierInput {
         case_id: string;
         extracted_fields: ExtractedField[];
         applicant_name: string;
       }

       export interface IdentityMatch {
         field_name: string;
         expected: string;
         actual: string;
         match: boolean;
         confidence: number;
       }

       export interface IdentityVerifierOutput {
         verified: boolean;
         matches: IdentityMatch[];
         discrepancies: string[];
         verification_summary: string;
       }
       ```

    4. **SanctionsScreener:**
       ```typescript
       export interface SanctionsScreenerInput {
         case_id: string;
         applicant_name: string;
         extracted_fields: ExtractedField[];
       }

       export interface SanctionsMatch {
         list_name: string;       // "UN", "OFAC", "PEP"
         matched_name: string;
         match_score: number;     // 0-1 similarity
         entry_id: string;
         details: string;
       }

       export interface SanctionsScreenerOutput {
         flagged: boolean;
         matches: SanctionsMatch[];
         lists_checked: string[];
         screening_summary: string;
       }
       ```

    5. **RiskScorer:**
       ```typescript
       export interface RiskScorerInput {
         case_id: string;
         document_result: AgentResult<DocumentProcessorOutput>;
         identity_result: AgentResult<IdentityVerifierOutput>;
         sanctions_result: AgentResult<SanctionsScreenerOutput>;
       }

       export interface RiskFactor {
         factor_name: string;     // e.g. "sanctions_match", "document_quality"
         weight: number;          // 0-1
         score: number;           // 0-100
         explanation: string;
       }

       export interface RiskScorerOutput {
         risk_score: number;          // 0-100
         risk_level: RiskLevel;       // low/medium/high/critical
         risk_factors: RiskFactor[];
         requires_manual_review: boolean;
         scoring_summary: string;
       }
       ```

    6. **CaseNarrator:**
       ```typescript
       export interface CaseNarratorInput {
         case_id: string;
         applicant_name: string;
         document_result: AgentResult<DocumentProcessorOutput>;
         identity_result: AgentResult<IdentityVerifierOutput>;
         sanctions_result: AgentResult<SanctionsScreenerOutput>;
         risk_result: AgentResult<RiskScorerOutput>;
       }

       export interface CaseNarratorOutput {
         narrative: string;           // Human-readable case assessment
         key_findings: string[];      // Bullet points
         recommended_action: string;  // "approve" | "deny" | "escalate"
         evidence_links: Array<{
           claim: string;
           source: string;
           confidence: number;
         }>;
       }
       ```

    Import `AgentType`, `DocumentType`, `RiskLevel` from `./index`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - `src/types/agents.ts` exports all 12+ interfaces (AgentResult, AgentConfig, and 2 per agent type)
    - All agent output types are generic-compatible with AgentResult<T>
  </verify>
  <done>
    All 5 agent types have fully typed input/output contracts. Every field is explicit — no `any`, no `Record<string, unknown>` for core fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pipeline state machine types and update re-exports</name>
  <files>src/types/pipeline.ts, src/types/index.ts</files>
  <action>
    1. Create `src/types/pipeline.ts` defining the orchestration pipeline as a typed state machine:

       ```typescript
       import {
         AgentResult,
         DocumentProcessorOutput,
         IdentityVerifierOutput,
         SanctionsScreenerOutput,
         RiskScorerOutput,
         CaseNarratorOutput,
       } from './agents';

       // Pipeline stages as a finite state machine
       export type PipelineStage =
         | 'initialized'           // Case created, ready to process
         | 'document_processing'   // DocumentProcessor running
         | 'parallel_verification' // IdentityVerifier + SanctionsScreener running in parallel
         | 'risk_scoring'          // RiskScorer aggregating signals
         | 'narrative_generation'  // CaseNarrator producing assessment
         | 'completed'             // All agents done, ready for review
         | 'failed';              // Pipeline failed (unrecoverable)

       // Valid transitions
       export const PIPELINE_TRANSITIONS: Record<PipelineStage, PipelineStage[]> = {
         initialized: ['document_processing'],
         document_processing: ['parallel_verification', 'failed'],
         parallel_verification: ['risk_scoring', 'failed'],
         risk_scoring: ['narrative_generation', 'failed'],
         narrative_generation: ['completed', 'failed'],
         completed: [],
         failed: ['initialized'],  // Can retry from start
       };

       // Full pipeline state — tracks all agent results as they complete
       export interface PipelineState {
         case_id: string;
         stage: PipelineStage;
         started_at: string;
         updated_at: string;

         // Agent results (null until that stage completes)
         document_result: AgentResult<DocumentProcessorOutput> | null;
         identity_result: AgentResult<IdentityVerifierOutput> | null;
         sanctions_result: AgentResult<SanctionsScreenerOutput> | null;
         risk_result: AgentResult<RiskScorerOutput> | null;
         narrative_result: AgentResult<CaseNarratorOutput> | null;

         // Error tracking
         errors: PipelineError[];
         retry_count: number;
       }

       export interface PipelineError {
         stage: PipelineStage;
         agent_type: string;
         error_message: string;
         timestamp: string;
         recoverable: boolean;
       }

       // Events that drive pipeline transitions
       export type PipelineEvent =
         | { type: 'START'; case_id: string }
         | { type: 'DOCUMENT_PROCESSING_COMPLETE'; result: AgentResult<DocumentProcessorOutput> }
         | { type: 'IDENTITY_VERIFICATION_COMPLETE'; result: AgentResult<IdentityVerifierOutput> }
         | { type: 'SANCTIONS_SCREENING_COMPLETE'; result: AgentResult<SanctionsScreenerOutput> }
         | { type: 'PARALLEL_VERIFICATION_COMPLETE' }
         | { type: 'RISK_SCORING_COMPLETE'; result: AgentResult<RiskScorerOutput> }
         | { type: 'NARRATIVE_COMPLETE'; result: AgentResult<CaseNarratorOutput> }
         | { type: 'AGENT_FAILED'; error: PipelineError }
         | { type: 'RETRY' };
       ```

    2. Update `src/types/index.ts` to re-export all types:
       - Add `export * from './agents';` at the top
       - Add `export * from './pipeline';` after agents
       - Keep all existing type exports intact (Case, Document, AgentRun, AuditLog, etc.)
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - `src/types/pipeline.ts` exports PipelineStage, PipelineState, PipelineEvent, PipelineError, PIPELINE_TRANSITIONS
    - `src/types/index.ts` re-exports from both `./agents` and `./pipeline`
    - Importing from `@/types` gives access to all agent and pipeline types
  </verify>
  <done>
    Pipeline state machine fully typed with stages, transitions, events, and error tracking. All types accessible via single `@/types` import.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — all types compile correctly
2. No `any` types in agent contracts (except metadata fields)
3. Pipeline stages form valid state machine (every stage has defined transitions)
4. All 5 agent types have Input and Output interfaces
5. AgentResult<T> wraps all outputs with confidence, timing, and error state
6. PipelineState tracks all agent results with proper null handling
</verification>

<success_criteria>
- Every agent has typed input/output contracts — no ambiguity about data shapes
- Pipeline state machine defines clear stages and valid transitions
- Types compile with strict TypeScript — no `any` leaks
- Single import path (`@/types`) gives access to everything
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-orchestration-core/02-01-SUMMARY.md`
</output>

---
phase: 08-case-lifecycle-integration
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/lib/pipeline/error-recovery.ts
  - src/components/cases/processing-error-display.tsx
  - src/app/api/cases/[id]/retry/route.ts
autonomous: true

must_haves:
  truths:
    - "OCR failures show clear error message with retry option instead of crashing"
    - "API timeouts show clear error message with suggested actions"
    - "Agent failures are displayed with specific error details (which agent, what went wrong)"
    - "User can retry failed processing from the error state"
    - "Partial pipeline failures show which agents succeeded and which failed"
  artifacts:
    - path: "src/lib/pipeline/error-recovery.ts"
      provides: "Error classification, user-facing error messages, and recovery strategies"
      exports: ["classifyPipelineError", "getUserFacingError", "getRecoveryStrategy", "PipelineErrorDisplay"]
    - path: "src/components/cases/processing-error-display.tsx"
      provides: "UI component showing pipeline errors with retry actions"
      contains: "ProcessingErrorDisplay"
    - path: "src/app/api/cases/[id]/retry/route.ts"
      provides: "POST endpoint to retry failed case processing"
      exports: ["POST"]
  key_links:
    - from: "src/components/cases/processing-error-display.tsx"
      to: "src/lib/pipeline/error-recovery.ts"
      via: "imports error classification and display helpers"
      pattern: "import.*from.*error-recovery"
    - from: "src/app/api/cases/[id]/retry/route.ts"
      to: "src/lib/pipeline/case-processor.ts"
      via: "calls processCaseLifecycle to retry the pipeline"
      pattern: "import.*processCaseLifecycle"
---

<objective>
Build comprehensive error handling for the case lifecycle — clear error messages for OCR failures, API timeouts, and agent failures with retry capability. When things go wrong, the user sees exactly what happened and can take action.

Purpose: CASE-03 requires "error states handled gracefully (OCR failure, API timeout) with clear user feedback." In a compliance context, silent failures are unacceptable — the officer must know exactly what happened and be able to retry or escalate. This plan creates error classification, user-facing error messages, a retry mechanism, and an error display component.
Output: Error recovery utilities, processing error display component, and retry API endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-case-lifecycle-integration/08-01-SUMMARY.md
@src/lib/agents/error-handling.ts (classifyError, ErrorCategory — from Phase 2)
@src/types/pipeline.ts (PipelineState, PipelineError)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error recovery module and retry API endpoint</name>
  <files>src/lib/pipeline/error-recovery.ts, src/app/api/cases/[id]/retry/route.ts</files>
  <action>
    1. Create `src/lib/pipeline/error-recovery.ts` — user-facing error classification and recovery strategies:

    ```typescript
    import { PipelineState, PipelineError } from '@/types';

    export type ErrorSeverity = 'info' | 'warning' | 'error' | 'critical';

    export interface PipelineErrorDisplay {
      title: string;
      description: string;
      severity: ErrorSeverity;
      agent_name: string;
      can_retry: boolean;
      suggested_action: string;
      technical_details?: string;
    }

    export interface RecoveryStrategy {
      can_retry: boolean;
      retry_message: string;
      alternative_actions: string[];
      requires_human_intervention: boolean;
    }

    /**
     * Map pipeline errors to user-facing display objects.
     * Transforms technical error details into compliance-officer-friendly messages.
     */
    export function classifyPipelineError(error: PipelineError): PipelineErrorDisplay {
      const agentName = formatAgentName(error.agent_type);
      const errorMsg = error.error_message.toLowerCase();

      // OCR-specific errors
      if (error.agent_type === 'document_processor' || errorMsg.includes('ocr')) {
        if (errorMsg.includes('empty') || errorMsg.includes('blank') || errorMsg.includes('unreadable')) {
          return {
            title: 'Document Unreadable',
            description: 'The uploaded document could not be read. The image may be too dark, blurry, or the file may be corrupted.',
            severity: 'error',
            agent_name: agentName,
            can_retry: true,
            suggested_action: 'Re-upload a clearer image of the document, then retry processing.',
            technical_details: error.error_message,
          };
        }
        if (errorMsg.includes('timeout') || errorMsg.includes('timed out')) {
          return {
            title: 'Document Processing Timeout',
            description: 'The document processing service took too long to respond. This is usually temporary.',
            severity: 'warning',
            agent_name: agentName,
            can_retry: true,
            suggested_action: 'Wait a moment and retry. If the issue persists, try uploading a smaller file.',
            technical_details: error.error_message,
          };
        }
        return {
          title: 'Document Processing Failed',
          description: `The document processor encountered an error while analyzing the uploaded document.`,
          severity: 'error',
          agent_name: agentName,
          can_retry: true,
          suggested_action: 'Retry processing. If the error persists, try re-uploading the document.',
          technical_details: error.error_message,
        };
      }

      // Identity verification errors
      if (error.agent_type === 'identity_verifier') {
        return {
          title: 'Identity Verification Error',
          description: 'The identity verification agent was unable to complete its analysis. The case will require manual identity review.',
          severity: 'warning',
          agent_name: agentName,
          can_retry: true,
          suggested_action: 'Retry processing. Manual identity review may be required.',
          technical_details: error.error_message,
        };
      }

      // Sanctions screening errors
      if (error.agent_type === 'sanctions_screener') {
        return {
          title: 'Sanctions Screening Error',
          description: 'The sanctions screening agent encountered an error. IMPORTANT: The applicant has NOT been cleared against sanctions lists. Manual screening is required.',
          severity: 'critical',
          agent_name: agentName,
          can_retry: true,
          suggested_action: 'Retry processing immediately. If retry fails, perform manual sanctions screening before making any decisions.',
          technical_details: error.error_message,
        };
      }

      // API/network errors (generic)
      if (errorMsg.includes('timeout') || errorMsg.includes('timed out')) {
        return {
          title: `${agentName} Timeout`,
          description: `The ${agentName.toLowerCase()} service did not respond in time. This is usually a temporary issue.`,
          severity: 'warning',
          agent_name: agentName,
          can_retry: true,
          suggested_action: 'Wait 30 seconds and retry processing.',
          technical_details: error.error_message,
        };
      }

      if (errorMsg.includes('rate limit') || errorMsg.includes('429')) {
        return {
          title: `${agentName} Rate Limited`,
          description: `The ${agentName.toLowerCase()} service is temporarily rate limited. Processing will succeed on retry.`,
          severity: 'warning',
          agent_name: agentName,
          can_retry: true,
          suggested_action: 'Wait 60 seconds and retry processing.',
          technical_details: error.error_message,
        };
      }

      // Default error
      return {
        title: `${agentName} Error`,
        description: `The ${agentName.toLowerCase()} encountered an unexpected error during processing.`,
        severity: 'error',
        agent_name: agentName,
        can_retry: error.recoverable,
        suggested_action: error.recoverable
          ? 'Retry processing. If the issue persists, escalate for technical review.'
          : 'This error requires technical investigation. Escalate the case for manual review.',
        technical_details: error.error_message,
      };
    }

    /**
     * Get user-facing error summary for the entire pipeline state.
     */
    export function getUserFacingError(pipelineState: PipelineState): {
      title: string;
      errors: PipelineErrorDisplay[];
      can_retry: boolean;
      overall_severity: ErrorSeverity;
    } {
      const errors = pipelineState.errors.map(classifyPipelineError);
      const hasCritical = errors.some(e => e.severity === 'critical');
      const canRetry = errors.some(e => e.can_retry);

      // Check for partial success (some agents completed, some failed)
      const completedAgents = [
        pipelineState.document_result?.success,
        pipelineState.identity_result?.success,
        pipelineState.sanctions_result?.success,
        pipelineState.risk_result?.success,
        pipelineState.narrative_result?.success,
      ].filter(Boolean).length;

      const totalAgents = 5;

      let title: string;
      if (completedAgents === 0) {
        title = 'Processing Failed';
      } else if (completedAgents < totalAgents) {
        title = `Partial Processing (${completedAgents}/${totalAgents} agents completed)`;
      } else {
        title = 'Processing Complete with Warnings';
      }

      return {
        title,
        errors,
        can_retry: canRetry,
        overall_severity: hasCritical ? 'critical' : errors.length > 0 ? 'error' : 'info',
      };
    }

    /**
     * Get recovery strategy for current pipeline state.
     */
    export function getRecoveryStrategy(pipelineState: PipelineState): RecoveryStrategy {
      const errors = pipelineState.errors;
      const canRetry = errors.some(e => e.recoverable);

      // Check for sanctions screening failure — this REQUIRES human intervention
      const sanctionsError = errors.find(e => e.agent_type === 'sanctions_screener' || e.agent_type.includes('sanctions'));
      const requiresHuman = !!sanctionsError;

      const alternatives: string[] = [];
      if (canRetry) alternatives.push('Retry processing');
      if (requiresHuman) alternatives.push('Perform manual sanctions screening');
      alternatives.push('Escalate case for senior review');
      alternatives.push('Request additional documents from applicant');

      return {
        can_retry: canRetry,
        retry_message: canRetry
          ? 'Retrying will re-run all failed agents. Previously successful results are preserved.'
          : 'Automated retry is not available. Manual review required.',
        alternative_actions: alternatives,
        requires_human_intervention: requiresHuman,
      };
    }

    function formatAgentName(agentType: string): string {
      const names: Record<string, string> = {
        document_processor: 'Document Processor',
        identity_verifier: 'Identity Verifier',
        sanctions_screener: 'Sanctions Screener',
        risk_scorer: 'Risk Scorer',
        case_narrator: 'Case Narrator',
      };
      return names[agentType] || agentType;
    }
    ```

    2. Create `src/app/api/cases/[id]/retry/route.ts` — POST endpoint to retry failed processing:

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createServerSupabaseClient } from '@/lib/supabase/server';
    import { processCaseLifecycle } from '@/lib/pipeline/case-processor';

    export async function POST(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id: caseId } = await params;

      try {
        const supabase = createServerSupabaseClient();

        // Verify case exists
        const { data: caseData, error: caseError } = await supabase
          .from('cases')
          .select('id, status')
          .eq('id', caseId)
          .single();

        if (caseError || !caseData) {
          return NextResponse.json({ error: 'Case not found' }, { status: 404 });
        }

        // Can only retry cases in 'review' or 'pending' status (failed pipelines go to 'review')
        if (!['review', 'pending'].includes(caseData.status)) {
          return NextResponse.json(
            { error: `Cannot retry case with status '${caseData.status}'` },
            { status: 400 }
          );
        }

        // Reset case status to pending for reprocessing
        await supabase
          .from('cases')
          .update({
            status: 'pending',
            risk_score: null,
            risk_level: null,
            narrative: null,
            updated_at: new Date().toISOString(),
          })
          .eq('id', caseId);

        // Log retry to audit trail
        await supabase.from('audit_logs').insert({
          case_id: caseId,
          action: 'processing_retried',
          actor_type: 'officer',
          actor_id: 'demo-officer',
          details: { previous_status: caseData.status },
        });

        // Re-run the pipeline
        const pipelineState = await processCaseLifecycle(caseId);

        return NextResponse.json({
          success: pipelineState.stage === 'completed',
          pipeline_state: pipelineState,
          message: pipelineState.stage === 'completed'
            ? 'Retry successful. Case reprocessed and ready for review.'
            : `Retry completed with status: ${pipelineState.stage}`,
        });

      } catch (error) {
        return NextResponse.json(
          { error: error instanceof Error ? error.message : 'Retry failed' },
          { status: 500 }
        );
      }
    }
    ```

    IMPORTANT: The retry endpoint resets the case to 'pending', then re-runs the full pipeline. In a more sophisticated system, you'd only re-run failed agents. For the demo, full re-run is simpler and more reliable.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Error recovery module classifies all error types: OCR failures, timeouts, rate limits, network errors
    - Each error has user-facing title, description, severity, suggested action
    - Sanctions screening failures flagged as 'critical' severity
    - getUserFacingError provides pipeline-level error summary
    - getRecoveryStrategy returns retry info and alternative actions
    - Retry endpoint resets case and re-runs pipeline
    - Retry logged to audit trail
  </verify>
  <done>
    Error recovery module with user-facing error classification for all agent failure types. Retry endpoint allows reprocessing failed cases. Sanctions failures specifically flagged as critical requiring human intervention.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create processing error display component</name>
  <files>src/components/cases/processing-error-display.tsx</files>
  <action>
    Create `src/components/cases/processing-error-display.tsx` — UI component for displaying pipeline errors:

    ```typescript
    'use client';

    import { useState } from 'react';
    import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
    import { Button } from '@/components/ui/button';
    import { Badge } from '@/components/ui/badge';
    import { AlertCircle, AlertTriangle, Info, XCircle, RefreshCw, ChevronDown, ChevronUp } from 'lucide-react';
    import { PipelineErrorDisplay, ErrorSeverity } from '@/lib/pipeline/error-recovery';

    interface ProcessingErrorDisplayProps {
      caseId: string;
      title: string;
      errors: PipelineErrorDisplay[];
      canRetry: boolean;
      overallSeverity: ErrorSeverity;
      onRetry?: () => void;
      isRetrying?: boolean;
    }

    const severityConfig: Record<ErrorSeverity, {
      icon: typeof AlertCircle;
      color: string;
      bgColor: string;
      borderColor: string;
      badgeVariant: 'default' | 'secondary' | 'destructive' | 'outline';
    }> = {
      info: {
        icon: Info,
        color: 'text-blue-600',
        bgColor: 'bg-blue-50',
        borderColor: 'border-blue-200',
        badgeVariant: 'secondary',
      },
      warning: {
        icon: AlertTriangle,
        color: 'text-yellow-600',
        bgColor: 'bg-yellow-50',
        borderColor: 'border-yellow-200',
        badgeVariant: 'outline',
      },
      error: {
        icon: XCircle,
        color: 'text-red-600',
        bgColor: 'bg-red-50',
        borderColor: 'border-red-200',
        badgeVariant: 'destructive',
      },
      critical: {
        icon: AlertCircle,
        color: 'text-red-700',
        bgColor: 'bg-red-100',
        borderColor: 'border-red-300',
        badgeVariant: 'destructive',
      },
    };

    export function ProcessingErrorDisplay({
      caseId,
      title,
      errors,
      canRetry,
      overallSeverity,
      onRetry,
      isRetrying = false,
    }: ProcessingErrorDisplayProps) {
      const [expandedErrors, setExpandedErrors] = useState<Set<number>>(new Set());
      const config = severityConfig[overallSeverity];
      const Icon = config.icon;

      const toggleError = (index: number) => {
        setExpandedErrors(prev => {
          const next = new Set(prev);
          if (next.has(index)) {
            next.delete(index);
          } else {
            next.add(index);
          }
          return next;
        });
      };

      return (
        <Card className={`${config.borderColor} border-2`}>
          <CardHeader className={`${config.bgColor} rounded-t-lg`}>
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <Icon className={`h-5 w-5 ${config.color}`} />
                <CardTitle className="text-base">{title}</CardTitle>
                <Badge variant={config.badgeVariant}>
                  {errors.length} {errors.length === 1 ? 'issue' : 'issues'}
                </Badge>
              </div>
              {canRetry && onRetry && (
                <Button
                  onClick={onRetry}
                  disabled={isRetrying}
                  size="sm"
                  variant="outline"
                >
                  <RefreshCw className={`h-4 w-4 mr-2 ${isRetrying ? 'animate-spin' : ''}`} />
                  {isRetrying ? 'Retrying...' : 'Retry Processing'}
                </Button>
              )}
            </div>
          </CardHeader>
          <CardContent className="pt-4 space-y-3">
            {errors.map((error, index) => {
              const errorConfig = severityConfig[error.severity];
              const ErrorIcon = errorConfig.icon;
              const isExpanded = expandedErrors.has(index);

              return (
                <div
                  key={index}
                  className={`rounded-lg border ${errorConfig.borderColor} p-3`}
                >
                  <div
                    className="flex items-start justify-between cursor-pointer"
                    onClick={() => toggleError(index)}
                  >
                    <div className="flex items-start gap-2">
                      <ErrorIcon className={`h-4 w-4 mt-0.5 ${errorConfig.color}`} />
                      <div>
                        <p className="text-sm font-medium">{error.title}</p>
                        <p className="text-xs text-muted-foreground">{error.agent_name}</p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Badge variant={errorConfig.badgeVariant} className="text-xs">
                        {error.severity}
                      </Badge>
                      {isExpanded ? (
                        <ChevronUp className="h-4 w-4 text-muted-foreground" />
                      ) : (
                        <ChevronDown className="h-4 w-4 text-muted-foreground" />
                      )}
                    </div>
                  </div>

                  {isExpanded && (
                    <div className="mt-3 pl-6 space-y-2">
                      <p className="text-sm text-muted-foreground">{error.description}</p>
                      <div className="flex items-start gap-2">
                        <Badge variant="outline" className="text-xs shrink-0">Suggested Action</Badge>
                        <p className="text-sm">{error.suggested_action}</p>
                      </div>
                      {error.technical_details && (
                        <details className="text-xs text-muted-foreground">
                          <summary className="cursor-pointer hover:text-foreground">
                            Technical Details
                          </summary>
                          <pre className="mt-1 p-2 bg-muted rounded text-xs overflow-x-auto">
                            {error.technical_details}
                          </pre>
                        </details>
                      )}
                    </div>
                  )}
                </div>
              );
            })}
          </CardContent>
        </Card>
      );
    }
    ```

    IMPORTANT DESIGN:
    - Errors are collapsible — officer sees summary, can expand for details
    - Severity colors match standard alert patterns (blue/yellow/red)
    - Sanctions failures are always "critical" (red) because the applicant hasn't been cleared
    - Technical details hidden behind a disclosure widget — compliance officers don't need stack traces
    - Retry button prominent when available
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Component renders error list with severity-based color coding
    - Errors are collapsible with expand/collapse toggle
    - Critical errors (sanctions) use red styling
    - Retry button visible when canRetry is true
    - Technical details hidden behind expandable details element
    - Component handles empty errors array (no errors) gracefully
  </verify>
  <done>
    Processing error display component built with collapsible error cards, severity-based color coding, retry button, and hidden technical details. Compliance officers see clear error descriptions and suggested actions without technical jargon.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all files
2. Error recovery classifies: OCR failures, timeouts, rate limits, network errors, agent failures
3. Each error type has user-facing title, description, severity, suggested action
4. Sanctions screening failures always classified as 'critical'
5. ProcessingErrorDisplay renders errors with severity-based styling
6. Errors are collapsible with technical details hidden by default
7. Retry endpoint resets case and re-runs full pipeline
8. Retry action logged to audit trail
9. Recovery strategy recommends alternatives (manual screening, escalation, request more docs)
</verification>

<success_criteria>
- Error states handled gracefully with clear user feedback (CASE-03)
- OCR failures show specific remediation (re-upload clearer image)
- API timeouts show retry guidance (wait and retry)
- Sanctions failures flagged as critical (human must manually screen)
- Retry mechanism works for failed pipelines
- Error display is professional and compliance-appropriate (not developer error messages)
</success_criteria>

<output>
After completion, create `.planning/phases/08-case-lifecycle-integration/08-04-SUMMARY.md`
</output>

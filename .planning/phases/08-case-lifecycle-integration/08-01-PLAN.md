---
phase: 08-case-lifecycle-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/cases/[id]/documents/upload/route.ts
  - src/components/cases/document-upload.tsx
  - src/lib/supabase/storage.ts
  - supabase/migrations/008_document_storage.sql
autonomous: true

must_haves:
  truths:
    - "User can select and upload document files (PDF, JPG, PNG) through a drag-and-drop UI"
    - "Uploaded files are stored in Supabase Storage with metadata persisted to the documents table"
    - "Upload progress is visible to the user with file type and size validation"
    - "API route handles multipart file upload and returns document record with storage path"
  artifacts:
    - path: "src/app/api/cases/[id]/documents/upload/route.ts"
      provides: "POST endpoint for multipart document file upload to Supabase Storage"
      exports: ["POST"]
    - path: "src/components/cases/document-upload.tsx"
      provides: "Drag-and-drop document upload component with file validation and progress"
      contains: "DocumentUpload"
    - path: "src/lib/supabase/storage.ts"
      provides: "Supabase Storage helper functions for document file operations"
      exports: ["uploadDocument", "getDocumentSignedUrl", "deleteDocument"]
    - path: "supabase/migrations/008_document_storage.sql"
      provides: "Supabase Storage bucket and RLS policy for case documents"
      contains: "INSERT INTO storage.buckets"
  key_links:
    - from: "src/app/api/cases/[id]/documents/upload/route.ts"
      to: "src/lib/supabase/storage.ts"
      via: "calls uploadDocument to store file in Supabase Storage"
      pattern: "import.*uploadDocument.*from.*storage"
    - from: "src/app/api/cases/[id]/documents/upload/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "persists document metadata to documents table"
      pattern: "import.*createServerSupabaseClient.*from.*supabase"
    - from: "src/components/cases/document-upload.tsx"
      to: "src/app/api/cases/[id]/documents/upload/route.ts"
      via: "POSTs FormData to upload endpoint"
      pattern: "fetch.*api/cases.*documents/upload"
---

<objective>
Build the document upload flow — the entry point of the case lifecycle. A compliance officer uploads KYC documents (passport, ID, utility bill) through a drag-and-drop UI, files are stored in Supabase Storage, and document records are created in the database.

Purpose: This is step 1 of the golden path (CASE-01): "Upload documents -> agents activate..." Without document upload, the pipeline has nothing to process. This plan creates both the UI component and the server-side file handling.
Output: A working document upload component, Supabase Storage helpers, file upload API route, and storage bucket migration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/index.ts (Document, DocumentType)
@src/lib/supabase/server.ts (createServerSupabaseClient)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase Storage bucket migration and storage helpers</name>
  <files>supabase/migrations/008_document_storage.sql, src/lib/supabase/storage.ts</files>
  <action>
    1. Create `supabase/migrations/008_document_storage.sql` to set up the document storage bucket:

    ```sql
    -- Create storage bucket for case documents
    INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
    VALUES (
      'case-documents',
      'case-documents',
      false,
      10485760,  -- 10MB max file size
      ARRAY['image/jpeg', 'image/png', 'image/webp', 'application/pdf']
    ) ON CONFLICT (id) DO NOTHING;

    -- RLS policy: Allow authenticated users to upload (single-user demo, so permissive)
    CREATE POLICY "Allow uploads to case-documents" ON storage.objects
      FOR INSERT
      WITH CHECK (bucket_id = 'case-documents');

    CREATE POLICY "Allow reads from case-documents" ON storage.objects
      FOR SELECT
      USING (bucket_id = 'case-documents');

    CREATE POLICY "Allow deletes from case-documents" ON storage.objects
      FOR DELETE
      USING (bucket_id = 'case-documents');

    -- Add file_path column to documents table if not exists
    ALTER TABLE documents ADD COLUMN IF NOT EXISTS file_path TEXT;
    ALTER TABLE documents ADD COLUMN IF NOT EXISTS file_size INTEGER;
    ALTER TABLE documents ADD COLUMN IF NOT EXISTS mime_type TEXT;
    ALTER TABLE documents ADD COLUMN IF NOT EXISTS processing_status TEXT DEFAULT 'pending';
    ALTER TABLE documents ADD COLUMN IF NOT EXISTS processing_error TEXT;
    ALTER TABLE documents ADD COLUMN IF NOT EXISTS processing_time_ms INTEGER;
    ```

    2. Create `src/lib/supabase/storage.ts` with storage helper functions:

    ```typescript
    import { createServerSupabaseClient } from './server';

    const BUCKET_NAME = 'case-documents';

    /**
     * Upload a document file to Supabase Storage.
     * Files are stored under: {case_id}/{document_id}/{filename}
     */
    export async function uploadDocument(
      caseId: string,
      documentId: string,
      file: File,
    ): Promise<{ path: string; url: string }> {
      const supabase = createServerSupabaseClient();

      // Sanitize filename: replace spaces, keep extension
      const sanitized = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
      const storagePath = `${caseId}/${documentId}/${sanitized}`;

      const { data, error } = await supabase.storage
        .from(BUCKET_NAME)
        .upload(storagePath, file, {
          contentType: file.type,
          upsert: true,
        });

      if (error) {
        throw new Error(`Storage upload failed: ${error.message}`);
      }

      return {
        path: data.path,
        url: storagePath,
      };
    }

    /**
     * Get a signed URL for a stored document (valid for 1 hour).
     */
    export async function getDocumentSignedUrl(storagePath: string): Promise<string> {
      const supabase = createServerSupabaseClient();

      const { data, error } = await supabase.storage
        .from(BUCKET_NAME)
        .createSignedUrl(storagePath, 3600); // 1 hour expiry

      if (error) {
        throw new Error(`Failed to create signed URL: ${error.message}`);
      }

      return data.signedUrl;
    }

    /**
     * Delete a document from Supabase Storage.
     */
    export async function deleteDocument(storagePath: string): Promise<void> {
      const supabase = createServerSupabaseClient();

      const { error } = await supabase.storage
        .from(BUCKET_NAME)
        .remove([storagePath]);

      if (error) {
        throw new Error(`Failed to delete document: ${error.message}`);
      }
    }

    /**
     * Get public URL for a document (if bucket is public — ours is private, use signed URLs instead).
     */
    export function getDocumentPublicUrl(storagePath: string): string {
      // Note: Our bucket is private, so this won't work for direct access.
      // Use getDocumentSignedUrl instead. Keeping this for reference.
      return `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/${BUCKET_NAME}/${storagePath}`;
    }
    ```

    IMPORTANT: The `file` parameter in `uploadDocument` accepts a Web API `File` object. In the API route, we'll extract the file from `FormData`. The Supabase JS client can upload `File` objects directly.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `supabase/migrations/008_document_storage.sql` contains bucket creation and RLS policies
    - `src/lib/supabase/storage.ts` exports uploadDocument, getDocumentSignedUrl, deleteDocument
    - No hardcoded URLs or credentials
  </verify>
  <done>
    Supabase Storage bucket configured for case documents with 10MB limit and image/PDF MIME types. Storage helpers provide upload, signed URL generation, and delete operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create document upload API route and drag-and-drop UI component</name>
  <files>src/app/api/cases/[id]/documents/upload/route.ts, src/components/cases/document-upload.tsx</files>
  <action>
    1. Create `src/app/api/cases/[id]/documents/upload/route.ts` — POST endpoint handling multipart file uploads:

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createServerSupabaseClient } from '@/lib/supabase/server';
    import { uploadDocument } from '@/lib/supabase/storage';
    import { DocumentType } from '@/types';
    import { randomUUID } from 'crypto';

    const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'application/pdf'];
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

    export async function POST(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id: caseId } = await params;

      try {
        const supabase = createServerSupabaseClient();

        // Verify case exists
        const { data: caseData, error: caseError } = await supabase
          .from('cases')
          .select('id, status')
          .eq('id', caseId)
          .single();

        if (caseError || !caseData) {
          return NextResponse.json({ error: 'Case not found' }, { status: 404 });
        }

        // Parse FormData
        const formData = await request.formData();
        const file = formData.get('file') as File | null;
        const documentType = formData.get('document_type') as DocumentType | null;

        if (!file) {
          return NextResponse.json({ error: 'No file provided' }, { status: 400 });
        }

        if (!documentType) {
          return NextResponse.json({ error: 'document_type is required' }, { status: 400 });
        }

        // Validate file
        if (!ALLOWED_TYPES.includes(file.type)) {
          return NextResponse.json(
            { error: `Invalid file type: ${file.type}. Allowed: ${ALLOWED_TYPES.join(', ')}` },
            { status: 400 }
          );
        }

        if (file.size > MAX_FILE_SIZE) {
          return NextResponse.json(
            { error: `File too large: ${(file.size / 1024 / 1024).toFixed(1)}MB. Max: 10MB` },
            { status: 400 }
          );
        }

        // Generate document ID
        const documentId = randomUUID();

        // Upload to Supabase Storage
        const { path } = await uploadDocument(caseId, documentId, file);

        // Create document record in database
        const { data: document, error: insertError } = await supabase
          .from('documents')
          .insert({
            id: documentId,
            case_id: caseId,
            type: documentType,
            file_name: file.name,
            file_url: path,
            file_path: path,
            file_size: file.size,
            mime_type: file.type,
            processing_status: 'pending',
          })
          .select()
          .single();

        if (insertError) {
          throw new Error(`Failed to create document record: ${insertError.message}`);
        }

        return NextResponse.json({
          document,
          message: `Document uploaded successfully: ${file.name}`,
        }, { status: 201 });

      } catch (error) {
        return NextResponse.json(
          { error: error instanceof Error ? error.message : 'Upload failed' },
          { status: 500 }
        );
      }
    }
    ```

    2. Create `src/components/cases/document-upload.tsx` — drag-and-drop upload component:

    ```typescript
    'use client';

    import { useState, useCallback, useRef } from 'react';
    import { Card, CardContent } from '@/components/ui/card';
    import { Button } from '@/components/ui/button';
    import { Badge } from '@/components/ui/badge';
    import { Upload, File, X, CheckCircle2, AlertCircle, Loader2 } from 'lucide-react';
    import { DocumentType } from '@/types';

    interface UploadedDocument {
      id: string;
      file_name: string;
      type: DocumentType;
      status: 'uploading' | 'uploaded' | 'error';
      error?: string;
      progress: number;
    }

    interface DocumentUploadProps {
      caseId: string;
      onUploadComplete?: (documents: UploadedDocument[]) => void;
      onAllUploaded?: () => void;
      maxFiles?: number;
    }

    const DOCUMENT_TYPE_OPTIONS: { value: DocumentType; label: string }[] = [
      { value: 'passport', label: 'Passport' },
      { value: 'drivers_license', label: "Driver's License" },
      { value: 'utility_bill', label: 'Utility Bill' },
      { value: 'bank_statement', label: 'Bank Statement' },
      { value: 'corporate_doc', label: 'Corporate Document' },
    ];

    export function DocumentUpload({ caseId, onUploadComplete, onAllUploaded, maxFiles = 5 }: DocumentUploadProps) {
      const [documents, setDocuments] = useState<UploadedDocument[]>([]);
      const [isDragOver, setIsDragOver] = useState(false);
      const [selectedType, setSelectedType] = useState<DocumentType>('passport');
      const fileInputRef = useRef<HTMLInputElement>(null);

      const uploadFile = useCallback(async (file: File, docType: DocumentType) => {
        const tempId = `temp-${Date.now()}-${Math.random().toString(36).slice(2)}`;

        // Add to documents list as uploading
        const newDoc: UploadedDocument = {
          id: tempId,
          file_name: file.name,
          type: docType,
          status: 'uploading',
          progress: 0,
        };

        setDocuments(prev => [...prev, newDoc]);

        try {
          const formData = new FormData();
          formData.append('file', file);
          formData.append('document_type', docType);

          const response = await fetch(`/api/cases/${caseId}/documents/upload`, {
            method: 'POST',
            body: formData,
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Upload failed');
          }

          const data = await response.json();

          setDocuments(prev =>
            prev.map(d =>
              d.id === tempId
                ? { ...d, id: data.document.id, status: 'uploaded' as const, progress: 100 }
                : d
            )
          );

          return data.document;
        } catch (error) {
          setDocuments(prev =>
            prev.map(d =>
              d.id === tempId
                ? { ...d, status: 'error' as const, error: error instanceof Error ? error.message : 'Upload failed' }
                : d
            )
          );
          return null;
        }
      }, [caseId]);

      const handleFiles = useCallback(async (files: FileList | File[]) => {
        const fileArray = Array.from(files).slice(0, maxFiles - documents.length);

        const results = await Promise.all(
          fileArray.map(file => uploadFile(file, selectedType))
        );

        const uploaded = results.filter(Boolean);
        if (uploaded.length > 0) {
          onUploadComplete?.(documents);
        }

        // Check if all are done
        setDocuments(prev => {
          const allDone = prev.every(d => d.status !== 'uploading');
          if (allDone && prev.length > 0) {
            onAllUploaded?.();
          }
          return prev;
        });
      }, [documents.length, maxFiles, selectedType, uploadFile, onUploadComplete, onAllUploaded]);

      const handleDrop = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        setIsDragOver(false);
        if (e.dataTransfer.files.length > 0) {
          handleFiles(e.dataTransfer.files);
        }
      }, [handleFiles]);

      const handleDragOver = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        setIsDragOver(true);
      }, []);

      const handleDragLeave = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        setIsDragOver(false);
      }, []);

      const removeDocument = useCallback((docId: string) => {
        setDocuments(prev => prev.filter(d => d.id !== docId));
      }, []);

      return (
        <div className="space-y-4">
          {/* Document type selector */}
          <div className="flex gap-2 flex-wrap">
            {DOCUMENT_TYPE_OPTIONS.map(opt => (
              <Button
                key={opt.value}
                variant={selectedType === opt.value ? 'default' : 'outline'}
                size="sm"
                onClick={() => setSelectedType(opt.value)}
              >
                {opt.label}
              </Button>
            ))}
          </div>

          {/* Drop zone */}
          <div
            onDrop={handleDrop}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onClick={() => fileInputRef.current?.click()}
            className={`
              border-2 border-dashed rounded-lg p-8 text-center cursor-pointer
              transition-colors duration-200
              ${isDragOver
                ? 'border-primary bg-primary/5'
                : 'border-muted-foreground/25 hover:border-primary/50'
              }
              ${documents.length >= maxFiles ? 'opacity-50 pointer-events-none' : ''}
            `}
          >
            <Upload className="mx-auto h-8 w-8 text-muted-foreground mb-3" />
            <p className="text-sm font-medium">
              Drop files here or click to browse
            </p>
            <p className="text-xs text-muted-foreground mt-1">
              PDF, JPG, PNG up to 10MB. Max {maxFiles} files.
            </p>
            <input
              ref={fileInputRef}
              type="file"
              className="hidden"
              accept=".pdf,.jpg,.jpeg,.png,.webp"
              multiple
              onChange={(e) => {
                if (e.target.files) handleFiles(e.target.files);
                e.target.value = '';
              }}
            />
          </div>

          {/* Uploaded documents list */}
          {documents.length > 0 && (
            <div className="space-y-2">
              {documents.map(doc => (
                <Card key={doc.id} className="p-3">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      {doc.status === 'uploading' && (
                        <Loader2 className="h-4 w-4 animate-spin text-primary" />
                      )}
                      {doc.status === 'uploaded' && (
                        <CheckCircle2 className="h-4 w-4 text-green-500" />
                      )}
                      {doc.status === 'error' && (
                        <AlertCircle className="h-4 w-4 text-red-500" />
                      )}
                      <File className="h-4 w-4 text-muted-foreground" />
                      <div>
                        <p className="text-sm font-medium">{doc.file_name}</p>
                        <div className="flex gap-2 items-center">
                          <Badge variant="outline" className="text-xs">
                            {doc.type.replace('_', ' ')}
                          </Badge>
                          {doc.error && (
                            <span className="text-xs text-red-500">{doc.error}</span>
                          )}
                        </div>
                      </div>
                    </div>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={(e) => {
                        e.stopPropagation();
                        removeDocument(doc.id);
                      }}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                </Card>
              ))}
            </div>
          )}
        </div>
      );
    }
    ```

    IMPORTANT: Use Next.js 15 dynamic route params convention — `params` is a Promise that must be awaited.
    IMPORTANT: The upload component uses client-side state only. It does NOT manage global state. The parent page component will use `onAllUploaded` to trigger the next step (processing).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - API route at `src/app/api/cases/[id]/documents/upload/route.ts` exports POST
    - API route validates: file presence, document_type, file type, file size, case existence
    - API route creates document record in Supabase with file_path, file_size, mime_type
    - Component at `src/components/cases/document-upload.tsx` exports DocumentUpload
    - Component supports drag-and-drop and click-to-browse
    - Component shows upload status (uploading/uploaded/error) for each file
    - Component supports document type selection
  </verify>
  <done>
    Document upload flow complete: drag-and-drop UI component with file validation and progress, API route with multipart handling and Supabase Storage, database persistence with document metadata. Files stored in Supabase Storage under case-documents bucket.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all files
2. Supabase migration creates case-documents bucket with proper MIME type restrictions
3. Storage helpers upload/retrieve/delete files in Supabase Storage
4. API route handles FormData upload with validation (type, size, existence)
5. Document records created with file_path pointing to Supabase Storage
6. UI component supports drag-and-drop, click-to-browse, and shows status per file
7. Document type selector allows user to tag each upload (passport, license, etc.)
</verification>

<success_criteria>
- Documents can be uploaded through the UI and stored in Supabase Storage (CASE-01 step 1)
- File validation prevents invalid uploads (wrong type, too large)
- Document metadata persisted to database with storage path for later OCR processing
- Upload status visible to user with error handling for failed uploads
</success_criteria>

<output>
After completion, create `.planning/phases/08-case-lifecycle-integration/08-01-SUMMARY.md`
</output>

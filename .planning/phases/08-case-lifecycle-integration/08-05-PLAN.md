---
phase: 08-case-lifecycle-integration
plan: 05
type: execute
wave: 3
depends_on: ["08-02", "08-03", "08-04"]
files_modified:
  - src/app/cases/new/page.tsx
  - src/app/api/cases/[id]/progress/route.ts
  - src/lib/pipeline/__tests__/golden-path.test.ts
autonomous: true

must_haves:
  truths:
    - "The golden path works end-to-end: create case -> upload docs -> trigger processing -> agents run with visible delays -> risk profile populates -> case reaches 'review' status"
    - "SSE endpoint streams real-time processing progress to the client"
    - "New case page combines document upload, processing trigger, and progress display into a single workflow"
    - "Integration test validates the full pipeline without a running server"
  artifacts:
    - path: "src/app/cases/new/page.tsx"
      provides: "New case page combining create, upload, process, and progress display"
      contains: "NewCasePage"
    - path: "src/app/api/cases/[id]/progress/route.ts"
      provides: "SSE endpoint streaming pipeline progress events to the client"
      exports: ["GET"]
    - path: "src/lib/pipeline/__tests__/golden-path.test.ts"
      provides: "Integration test validating the complete case lifecycle"
      contains: "Golden Path"
  key_links:
    - from: "src/app/cases/new/page.tsx"
      to: "src/app/api/cases/create/route.ts"
      via: "creates case via POST /api/cases/create"
      pattern: "fetch.*api/cases/create"
    - from: "src/app/cases/new/page.tsx"
      to: "src/components/cases/document-upload.tsx"
      via: "renders DocumentUpload component"
      pattern: "import.*DocumentUpload"
    - from: "src/app/cases/new/page.tsx"
      to: "src/app/api/cases/[id]/process/route.ts"
      via: "triggers processing via POST /api/cases/{id}/process"
      pattern: "fetch.*api/cases.*process"
    - from: "src/app/cases/new/page.tsx"
      to: "src/app/api/cases/[id]/progress/route.ts"
      via: "subscribes to SSE for real-time progress"
      pattern: "EventSource.*api/cases.*progress"
---

<objective>
Build the golden path page, SSE progress endpoint, and integration test that prove the complete case lifecycle works end-to-end. This is the single most important plan in Phase 8 — it's the page you'd show in the demo video.

Purpose: This plan creates the unified new-case workflow page that walks a compliance officer through: enter applicant info -> upload documents -> click "Process" -> watch agents work in real-time -> see results. It also validates everything with an integration test. Success criteria #1 from the roadmap ("Upload documents -> agents activate in parallel -> risk profile populates -> officer reviews -> decision recorded -> audit complete") is verified here.
Output: New case page, SSE progress endpoint, and passing golden path integration test.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-case-lifecycle-integration/08-02-SUMMARY.md
@.planning/phases/08-case-lifecycle-integration/08-03-SUMMARY.md
@.planning/phases/08-case-lifecycle-integration/08-04-SUMMARY.md
@src/lib/pipeline/case-processor.ts
@src/lib/pipeline/progress-emitter.ts
@src/components/cases/document-upload.tsx
@src/components/cases/processing-error-display.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSE progress endpoint and new case workflow page</name>
  <files>src/app/api/cases/[id]/progress/route.ts, src/app/cases/new/page.tsx</files>
  <action>
    1. Create `src/app/api/cases/[id]/progress/route.ts` — SSE endpoint streaming pipeline progress:

    ```typescript
    import { NextRequest } from 'next/server';
    import { getProgressEmitter } from '@/lib/pipeline/progress-emitter';

    /**
     * Server-Sent Events endpoint for real-time pipeline progress.
     * The client connects with EventSource and receives events as agents complete.
     */
    export async function GET(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id: caseId } = await params;

      const encoder = new TextEncoder();
      const stream = new ReadableStream({
        start(controller) {
          const emitter = getProgressEmitter(caseId);

          // Send initial connection event
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ type: 'connected', case_id: caseId })}\n\n`)
          );

          if (!emitter) {
            // No active pipeline — send status and close
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify({ type: 'no_pipeline', case_id: caseId, message: 'No active processing pipeline' })}\n\n`)
            );
            controller.close();
            return;
          }

          // Send all existing events (catch up)
          for (const event of emitter.getEvents()) {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify({ type: 'progress', ...event })}\n\n`)
            );
          }

          // Subscribe to new events
          const unsubscribe = emitter.on((event) => {
            try {
              controller.enqueue(
                encoder.encode(`data: ${JSON.stringify({ type: 'progress', ...event })}\n\n`)
              );

              // Close stream when pipeline completes or fails
              if (event.status === 'completed' && (event.stage === 'completed' || event.stage === 'failed')) {
                setTimeout(() => {
                  try {
                    controller.enqueue(
                      encoder.encode(`data: ${JSON.stringify({ type: 'done', case_id: caseId })}\n\n`)
                    );
                    controller.close();
                  } catch {
                    // Stream may already be closed
                  }
                }, 500);
              }
            } catch {
              // Client disconnected
              unsubscribe();
            }
          });

          // Clean up on client disconnect
          request.signal.addEventListener('abort', () => {
            unsubscribe();
          });
        },
      });

      return new Response(stream, {
        headers: {
          'Content-Type': 'text/event-stream',
          'Cache-Control': 'no-cache',
          'Connection': 'keep-alive',
        },
      });
    }
    ```

    2. Create `src/app/cases/new/page.tsx` — the golden path new case workflow page:

    ```typescript
    'use client';

    import { useState, useCallback, useEffect, useRef } from 'react';
    import { useRouter } from 'next/navigation';
    import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
    import { Button } from '@/components/ui/button';
    import { Input } from '@/components/ui/input';
    import { Badge } from '@/components/ui/badge';
    import { Separator } from '@/components/ui/separator';
    import {
      User, FileText, Cpu, CheckCircle2, Loader2, AlertCircle,
      ArrowRight, Play, Eye
    } from 'lucide-react';
    import { DocumentUpload } from '@/components/cases/document-upload';
    import { ProcessingErrorDisplay } from '@/components/cases/processing-error-display';
    import { PipelineErrorDisplay as PipelineErrorType } from '@/lib/pipeline/error-recovery';
    import { Case } from '@/types';

    type WorkflowStep = 'applicant' | 'documents' | 'processing' | 'complete' | 'error';

    interface ProgressEvent {
      type: string;
      stage?: string;
      agent_type?: string;
      status?: string;
      message?: string;
      confidence?: number;
      duration_ms?: number;
    }

    export default function NewCasePage() {
      const router = useRouter();
      const [step, setStep] = useState<WorkflowStep>('applicant');
      const [caseId, setCaseId] = useState<string | null>(null);
      const [applicantName, setApplicantName] = useState('');
      const [applicantEmail, setApplicantEmail] = useState('');
      const [isCreating, setIsCreating] = useState(false);
      const [isProcessing, setIsProcessing] = useState(false);
      const [progressEvents, setProgressEvents] = useState<ProgressEvent[]>([]);
      const [pipelineResult, setPipelineResult] = useState<any>(null);
      const [errors, setErrors] = useState<PipelineErrorType[]>([]);
      const eventSourceRef = useRef<EventSource | null>(null);

      // Step 1: Create case
      const handleCreateCase = useCallback(async () => {
        if (!applicantName || !applicantEmail) return;

        setIsCreating(true);
        try {
          const response = await fetch('/api/cases/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              applicant_name: applicantName,
              applicant_email: applicantEmail,
            }),
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to create case');
          }

          const data = await response.json();
          setCaseId(data.case.id);
          setStep('documents');
        } catch (error) {
          console.error('Failed to create case:', error);
        } finally {
          setIsCreating(false);
        }
      }, [applicantName, applicantEmail]);

      // Step 2: After documents uploaded, move to processing
      const handleDocumentsUploaded = useCallback(() => {
        // Documents are uploaded, ready to process
      }, []);

      // Step 3: Start processing
      const handleStartProcessing = useCallback(async () => {
        if (!caseId) return;

        setIsProcessing(true);
        setStep('processing');
        setProgressEvents([]);

        // Connect to SSE for real-time progress
        const eventSource = new EventSource(`/api/cases/${caseId}/progress`);
        eventSourceRef.current = eventSource;

        eventSource.onmessage = (event) => {
          const data: ProgressEvent = JSON.parse(event.data);

          if (data.type === 'progress') {
            setProgressEvents(prev => [...prev, data]);
          }

          if (data.type === 'done') {
            eventSource.close();
          }
        };

        eventSource.onerror = () => {
          eventSource.close();
        };

        // Trigger processing
        try {
          const response = await fetch(`/api/cases/${caseId}/process`, {
            method: 'POST',
          });

          const result = await response.json();
          setPipelineResult(result);

          if (result.success) {
            setStep('complete');
          } else {
            // Pipeline had errors — show error state
            setStep('error');
          }
        } catch (error) {
          setStep('error');
        } finally {
          setIsProcessing(false);
          eventSource.close();
        }
      }, [caseId]);

      // Handle retry
      const handleRetry = useCallback(async () => {
        if (!caseId) return;

        setIsProcessing(true);
        setStep('processing');
        setProgressEvents([]);

        try {
          const response = await fetch(`/api/cases/${caseId}/retry`, {
            method: 'POST',
          });

          const result = await response.json();
          setPipelineResult(result);

          if (result.success) {
            setStep('complete');
          } else {
            setStep('error');
          }
        } catch (error) {
          setStep('error');
        } finally {
          setIsProcessing(false);
        }
      }, [caseId]);

      // Cleanup SSE on unmount
      useEffect(() => {
        return () => {
          eventSourceRef.current?.close();
        };
      }, []);

      return (
        <div className="container max-w-3xl mx-auto py-8 px-4">
          <h1 className="text-2xl font-bold mb-2">New KYC Case</h1>
          <p className="text-muted-foreground mb-6">
            Create a new case, upload identity documents, and run AI-powered compliance checks.
          </p>

          {/* Progress indicator */}
          <div className="flex items-center gap-2 mb-8">
            {(['applicant', 'documents', 'processing', 'complete'] as const).map((s, i) => (
              <div key={s} className="flex items-center gap-2">
                <div className={`
                  w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium
                  ${step === s ? 'bg-primary text-primary-foreground' :
                    (['applicant', 'documents', 'processing', 'complete'].indexOf(step) > i ||
                     step === 'error')
                    ? 'bg-primary/20 text-primary' : 'bg-muted text-muted-foreground'}
                `}>
                  {i + 1}
                </div>
                {i < 3 && <div className="w-12 h-0.5 bg-muted" />}
              </div>
            ))}
          </div>

          {/* Step 1: Applicant Info */}
          {step === 'applicant' && (
            <Card>
              <CardHeader>
                <div className="flex items-center gap-2">
                  <User className="h-5 w-5" />
                  <CardTitle>Applicant Information</CardTitle>
                </div>
                <CardDescription>Enter the applicant details to begin the KYC review.</CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <label className="text-sm font-medium">Full Name</label>
                  <Input
                    placeholder="e.g. John Michael Smith"
                    value={applicantName}
                    onChange={(e) => setApplicantName(e.target.value)}
                  />
                </div>
                <div>
                  <label className="text-sm font-medium">Email Address</label>
                  <Input
                    placeholder="e.g. john.smith@example.com"
                    type="email"
                    value={applicantEmail}
                    onChange={(e) => setApplicantEmail(e.target.value)}
                  />
                </div>
                <Button
                  onClick={handleCreateCase}
                  disabled={!applicantName || !applicantEmail || isCreating}
                  className="w-full"
                >
                  {isCreating ? (
                    <><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Creating Case...</>
                  ) : (
                    <>Create Case <ArrowRight className="h-4 w-4 ml-2" /></>
                  )}
                </Button>
              </CardContent>
            </Card>
          )}

          {/* Step 2: Document Upload */}
          {step === 'documents' && caseId && (
            <Card>
              <CardHeader>
                <div className="flex items-center gap-2">
                  <FileText className="h-5 w-5" />
                  <CardTitle>Upload Documents</CardTitle>
                </div>
                <CardDescription>
                  Upload identity documents for {applicantName}. Supported: passport, driver's license, utility bill, bank statement, corporate documents.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-4">
                <DocumentUpload
                  caseId={caseId}
                  onAllUploaded={handleDocumentsUploaded}
                />
                <Separator />
                <Button
                  onClick={handleStartProcessing}
                  className="w-full"
                  size="lg"
                >
                  <Play className="h-4 w-4 mr-2" />
                  Start AI Processing
                </Button>
              </CardContent>
            </Card>
          )}

          {/* Step 3: Processing */}
          {step === 'processing' && (
            <Card>
              <CardHeader>
                <div className="flex items-center gap-2">
                  <Cpu className="h-5 w-5 animate-pulse" />
                  <CardTitle>Processing Case</CardTitle>
                </div>
                <CardDescription>
                  AI agents are analyzing {applicantName}'s documents in parallel...
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  {progressEvents.map((event, i) => (
                    <div key={i} className="flex items-start gap-3">
                      {event.status === 'completed' ? (
                        <CheckCircle2 className="h-4 w-4 text-green-500 mt-0.5 shrink-0" />
                      ) : event.status === 'failed' ? (
                        <AlertCircle className="h-4 w-4 text-red-500 mt-0.5 shrink-0" />
                      ) : (
                        <Loader2 className="h-4 w-4 animate-spin text-primary mt-0.5 shrink-0" />
                      )}
                      <div>
                        <p className="text-sm">{event.message}</p>
                        {event.confidence !== undefined && event.confidence > 0 && (
                          <p className="text-xs text-muted-foreground">
                            Confidence: {(event.confidence * 100).toFixed(0)}%
                            {event.duration_ms ? ` | ${(event.duration_ms / 1000).toFixed(1)}s` : ''}
                          </p>
                        )}
                      </div>
                    </div>
                  ))}
                  {isProcessing && (
                    <div className="flex items-center gap-2 text-muted-foreground">
                      <Loader2 className="h-4 w-4 animate-spin" />
                      <span className="text-sm">Agents working...</span>
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          )}

          {/* Step 4: Complete */}
          {step === 'complete' && pipelineResult && (
            <Card className="border-green-200">
              <CardHeader className="bg-green-50 rounded-t-lg">
                <div className="flex items-center gap-2">
                  <CheckCircle2 className="h-5 w-5 text-green-600" />
                  <CardTitle>Processing Complete</CardTitle>
                </div>
                <CardDescription>
                  All AI agents have completed their analysis for {applicantName}.
                </CardDescription>
              </CardHeader>
              <CardContent className="pt-4 space-y-4">
                {pipelineResult.pipeline_state?.risk_result?.data && (
                  <div className="flex items-center gap-4">
                    <div>
                      <p className="text-sm text-muted-foreground">Risk Score</p>
                      <p className="text-3xl font-bold">
                        {pipelineResult.pipeline_state.risk_result.data.risk_score}/100
                      </p>
                    </div>
                    <Badge variant={
                      pipelineResult.pipeline_state.risk_result.data.risk_level === 'low' ? 'secondary' :
                      pipelineResult.pipeline_state.risk_result.data.risk_level === 'medium' ? 'outline' :
                      'destructive'
                    }>
                      {pipelineResult.pipeline_state.risk_result.data.risk_level?.toUpperCase()}
                    </Badge>
                  </div>
                )}
                <Separator />
                <Button
                  onClick={() => router.push(`/cases/${caseId}`)}
                  className="w-full"
                >
                  <Eye className="h-4 w-4 mr-2" />
                  View Full Risk Profile & Make Decision
                </Button>
              </CardContent>
            </Card>
          )}

          {/* Error State */}
          {step === 'error' && (
            <div className="space-y-4">
              <ProcessingErrorDisplay
                caseId={caseId || ''}
                title="Processing Encountered Issues"
                errors={errors}
                canRetry={true}
                overallSeverity="error"
                onRetry={handleRetry}
                isRetrying={isProcessing}
              />
              {pipelineResult?.pipeline_state?.risk_result?.data && (
                <Card>
                  <CardContent className="pt-4">
                    <p className="text-sm text-muted-foreground mb-2">
                      Some agents completed before errors occurred. Partial results available.
                    </p>
                    <Button
                      variant="outline"
                      onClick={() => router.push(`/cases/${caseId}`)}
                    >
                      View Partial Results
                    </Button>
                  </CardContent>
                </Card>
              )}
            </div>
          )}
        </div>
      );
    }
    ```

    IMPORTANT DESIGN NOTES:
    - The workflow is a 4-step wizard: Applicant -> Documents -> Processing -> Complete
    - SSE connection is established BEFORE triggering processing so we don't miss early events
    - The "Start AI Processing" button is the dramatic moment in the demo — clicking it kicks off all agents
    - Progress events stream in real-time showing each agent starting and completing
    - On completion, the user is directed to the full risk profile page (from Phase 6)
    - Error state shows the ProcessingErrorDisplay component with retry capability
    - Use Next.js 15 `params` as Promise
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - SSE endpoint streams events as text/event-stream
    - SSE sends catch-up events for existing progress
    - SSE closes when pipeline completes
    - New case page has 4-step workflow: applicant -> documents -> processing -> complete
    - Create case calls POST /api/cases/create
    - Document upload uses DocumentUpload component
    - Processing trigger calls POST /api/cases/{id}/process
    - Progress events rendered in real-time
    - Complete state shows risk score and links to full profile
    - Error state shows ProcessingErrorDisplay with retry
  </verify>
  <done>
    Golden path page built: 4-step wizard from applicant info through AI processing to results. SSE endpoint provides real-time progress streaming. Complete user flow from case creation to review-ready state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create golden path integration test</name>
  <files>src/lib/pipeline/__tests__/golden-path.test.ts</files>
  <action>
    Create `src/lib/pipeline/__tests__/golden-path.test.ts` — integration test that validates the complete case lifecycle without a running server:

    ```typescript
    /**
     * Golden Path Integration Test
     *
     * Validates the complete case lifecycle:
     * 1. Case creation
     * 2. Pipeline processing with all agents
     * 3. Delay simulation (agents take visible time)
     * 4. Confidence routing evaluation
     * 5. Results persistence (agent_runs, case updates)
     * 6. Progress event emission
     *
     * Run with: npx tsx --tsconfig tsconfig.json src/lib/pipeline/__tests__/golden-path.test.ts
     *
     * NOTE: This test exercises the pipeline logic without Supabase.
     * It tests the orchestrator, delay simulator, confidence router, and progress emitter.
     * Database persistence is tested via API endpoints in manual testing.
     */

    import { processCase, createPipelineState, registerAgent } from '@/lib/agents/orchestrator';
    import { registerAllStubs } from '@/lib/agents/stubs';
    import { simulateAgentDelay, getExpectedDuration, AGENT_DELAY_CONFIG } from '@/lib/pipeline/delay-simulator';
    import { evaluateConfidenceRouting, CONFIDENCE_THRESHOLDS } from '@/lib/pipeline/confidence-router';
    import { createProgressEmitter } from '@/lib/pipeline/progress-emitter';
    import { PipelineState } from '@/types';

    let passed = 0;
    let failed = 0;

    function assert(condition: boolean, message: string): void {
      if (condition) {
        console.log(`  PASS: ${message}`);
        passed++;
      } else {
        console.error(`  FAIL: ${message}`);
        failed++;
      }
    }

    async function testGoldenPathPipeline(): Promise<void> {
      console.log('\n--- Test: Golden Path Pipeline (all agents succeed) ---');

      registerAllStubs();

      const stages: string[] = [];
      const startTime = Date.now();

      const result = await processCase(
        {
          case_id: 'golden-path-001',
          documents: [{
            id: 'doc-001',
            file_url: '/test/passport.jpg',
            file_name: 'passport.jpg',
            type: 'passport',
          }],
          applicant_name: 'John Smith',
          applicant_email: 'john@test.com',
        },
        (state: PipelineState) => {
          stages.push(state.stage);
        },
      );

      const duration = Date.now() - startTime;

      assert(result.stage === 'completed', `Pipeline completed (got: ${result.stage})`);
      assert(result.errors.length === 0, `No errors (got: ${result.errors.length})`);

      // All 5 agent results populated
      assert(result.document_result !== null, 'Document result populated');
      assert(result.identity_result !== null, 'Identity result populated');
      assert(result.sanctions_result !== null, 'Sanctions result populated');
      assert(result.risk_result !== null, 'Risk result populated');
      assert(result.narrative_result !== null, 'Narrative result populated');

      // All agents succeeded
      assert(result.document_result!.success === true, 'Document processor succeeded');
      assert(result.identity_result!.success === true, 'Identity verifier succeeded');
      assert(result.sanctions_result!.success === true, 'Sanctions screener succeeded');
      assert(result.risk_result!.success === true, 'Risk scorer succeeded');
      assert(result.narrative_result!.success === true, 'Case narrator succeeded');

      // Risk score present
      assert(result.risk_result!.data!.risk_score >= 0, 'Risk score >= 0');
      assert(result.risk_result!.data!.risk_score <= 100, 'Risk score <= 100');

      // Narrative present
      assert(result.narrative_result!.data!.narrative.length > 50, 'Narrative has content');
      assert(result.narrative_result!.data!.key_findings.length > 0, 'Has key findings');
      assert(
        ['approve', 'deny', 'escalate'].includes(result.narrative_result!.data!.recommended_action),
        'Recommended action is valid'
      );

      // Stage transitions correct
      assert(stages.includes('initialized'), 'Has initialized stage');
      assert(stages.includes('document_processing'), 'Has document_processing stage');
      assert(stages.includes('parallel_verification'), 'Has parallel_verification stage');
      assert(stages.includes('risk_scoring'), 'Has risk_scoring stage');
      assert(stages.includes('narrative_generation'), 'Has narrative_generation stage');
      assert(stages.includes('completed'), 'Has completed stage');

      console.log(`  Pipeline took ${duration}ms`);
    }

    async function testDelaySimulator(): Promise<void> {
      console.log('\n--- Test: Delay Simulator ---');

      // Test that delays are within expected range
      const start = Date.now();
      const delay = await simulateAgentDelay('document_processing');
      const elapsed = Date.now() - start;

      assert(delay >= AGENT_DELAY_CONFIG.document_processing.min * 0.9, `Delay >= min (got: ${delay}ms)`);
      assert(delay <= AGENT_DELAY_CONFIG.document_processing.max * 1.1, `Delay <= max (got: ${delay}ms)`);
      assert(elapsed >= AGENT_DELAY_CONFIG.document_processing.min * 0.8, `Actual elapsed >= min`);

      // Test skip delay
      const skippedDelay = await simulateAgentDelay('document_processing', { skipDelay: true });
      assert(skippedDelay === 0, 'Skip delay returns 0');

      // Test unknown agent (should return 0)
      const unknownDelay = await simulateAgentDelay('unknown_agent');
      assert(unknownDelay === 0, 'Unknown agent delay is 0');

      // Test expected duration calculation
      const expected = getExpectedDuration();
      assert(expected.min > 8000, `Expected min > 8s (got: ${expected.min}ms)`);
      assert(expected.max < 25000, `Expected max < 25s (got: ${expected.max}ms)`);
    }

    async function testConfidenceRoutingCleanCase(): Promise<void> {
      console.log('\n--- Test: Confidence Routing (clean case) ---');

      registerAllStubs();

      const result = await processCase(
        {
          case_id: 'routing-clean-001',
          documents: [{ id: 'doc-001', file_url: '/test/passport.jpg', file_name: 'passport.jpg', type: 'passport' }],
          applicant_name: 'Clean Applicant',
          applicant_email: 'clean@test.com',
        },
      );

      const routing = evaluateConfidenceRouting(result);

      // Clean stub case should have few or no routing concerns
      assert(routing.overall_confidence > 0, `Overall confidence > 0 (got: ${routing.overall_confidence})`);
      console.log(`  Routing result: ${routing.recommended_action}, ${routing.routing_reasons.length} reasons`);
      if (routing.routing_reasons.length > 0) {
        routing.routing_reasons.forEach(r => console.log(`    - ${r}`));
      }
    }

    async function testConfidenceRoutingFailedAgent(): Promise<void> {
      console.log('\n--- Test: Confidence Routing (failed agent) ---');

      // Create a pipeline state with a failed sanctions screener
      const state: PipelineState = {
        case_id: 'routing-fail-001',
        stage: 'completed',
        started_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        document_result: {
          success: true, data: null, error: null, confidence: 0.95,
          duration_ms: 1000, agent_type: 'document_processor' as any, metadata: {},
        },
        identity_result: {
          success: true, data: { verified: true, matches: [], discrepancies: [], verification_summary: '' } as any,
          error: null, confidence: 0.9, duration_ms: 500, agent_type: 'identity_verifier' as any, metadata: {},
        },
        sanctions_result: {
          success: false, data: null, error: 'API timeout',
          confidence: 0, duration_ms: 0, agent_type: 'sanctions_screener' as any, metadata: {},
        },
        risk_result: {
          success: true, data: { risk_score: 45, risk_level: 'medium', risk_factors: [], requires_manual_review: true, scoring_summary: '' } as any,
          error: null, confidence: 0.6, duration_ms: 800, agent_type: 'risk_scorer' as any, metadata: {},
        },
        narrative_result: {
          success: true, data: { narrative: 'Test', key_findings: [], recommended_action: 'escalate', evidence_links: [] } as any,
          error: null, confidence: 0.7, duration_ms: 1200, agent_type: 'case_narrator' as any, metadata: {},
        },
        errors: [],
        retry_count: 0,
      };

      const routing = evaluateConfidenceRouting(state);

      assert(routing.requires_manual_review === true, 'Failed agent triggers manual review');
      assert(routing.low_confidence_agents.includes('sanctions_screener'), 'Sanctions screener flagged as low confidence');
      assert(routing.routing_reasons.length > 0, 'Has routing reasons');

      console.log(`  Routing: ${routing.recommended_action}`);
      routing.routing_reasons.forEach(r => console.log(`    - ${r}`));
    }

    async function testProgressEmitter(): Promise<void> {
      console.log('\n--- Test: Progress Emitter ---');

      const emitter = createProgressEmitter('test-emitter-001');
      const received: any[] = [];

      emitter.on((event) => {
        received.push(event);
      });

      emitter.emit({ stage: 'initialized', status: 'started', message: 'Starting...' });
      emitter.emit({ stage: 'document_processing', status: 'started', message: 'Processing docs...' });
      emitter.emit({ stage: 'completed', status: 'completed', message: 'Done!' });

      assert(received.length === 3, `Received 3 events (got: ${received.length})`);
      assert(received[0].case_id === 'test-emitter-001', 'Events have case_id');
      assert(received[0].timestamp !== undefined, 'Events have timestamp');
      assert(emitter.getEvents().length === 3, 'Events stored for catch-up');
    }

    // Run all tests
    async function main(): Promise<void> {
      console.log('=== Phase 8: Golden Path Integration Tests ===');

      await testProgressEmitter();
      await testDelaySimulator();
      await testGoldenPathPipeline();
      await testConfidenceRoutingCleanCase();
      await testConfidenceRoutingFailedAgent();

      console.log(`\n=== Results: ${passed} passed, ${failed} failed ===`);

      if (failed > 0) {
        process.exit(1);
      }
    }

    main().catch((err) => {
      console.error('Test runner failed:', err);
      process.exit(1);
    });
    ```

    IMPORTANT NOTES:
    - This test does NOT require Supabase or a running server
    - It tests the pipeline logic, delay simulator, confidence router, and progress emitter
    - Database persistence is tested via API endpoint manual testing (curl)
    - The golden path test uses stub agents (from Phase 2) — they simulate realistic delays and return typed data
    - Run with: `npx tsx --tsconfig tsconfig.json src/lib/pipeline/__tests__/golden-path.test.ts`
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx tsx --tsconfig tsconfig.json src/lib/pipeline/__tests__/golden-path.test.ts` exits with code 0
    - Golden path test: pipeline completes with all 5 agent results
    - Delay simulator test: delays within configured range
    - Confidence routing test (clean): evaluates successfully
    - Confidence routing test (failed agent): triggers manual review
    - Progress emitter test: events emitted and stored correctly

    Manual golden path verification (after dev server started):
    ```bash
    # 1. Create case
    curl -X POST http://localhost:3000/api/cases/create \
      -H "Content-Type: application/json" \
      -d '{"applicant_name":"Test User","applicant_email":"test@example.com"}'

    # 2. Upload document (use case_id from step 1)
    curl -X POST http://localhost:3000/api/cases/{case_id}/documents/upload \
      -F "file=@test-passport.jpg" \
      -F "document_type=passport"

    # 3. Trigger processing
    curl -X POST http://localhost:3000/api/cases/{case_id}/process

    # 4. Check progress (SSE — use httpie or browser)
    curl -N http://localhost:3000/api/cases/{case_id}/progress
    ```
  </verify>
  <done>
    Golden path integration test validates: full pipeline processing, delay simulation, confidence routing for clean and failed cases, and progress emission. New case page provides the complete demo-ready workflow from applicant info through AI processing to results.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all files
2. Integration test passes: `npx tsx --tsconfig tsconfig.json src/lib/pipeline/__tests__/golden-path.test.ts`
3. SSE endpoint streams progress events in real-time
4. New case page: applicant form -> document upload -> processing with progress -> completion
5. Processing progress visible with agent status indicators
6. Completion shows risk score and links to full profile
7. Error state shows with retry capability
8. Full manual test: create case -> upload doc -> process -> see results at /cases/{id}

Golden path validation checklist:
- [ ] Create case via form
- [ ] Upload document(s) via drag-and-drop
- [ ] Click "Start AI Processing"
- [ ] Watch agents appear to work (12-18s total)
- [ ] See risk score on completion
- [ ] Navigate to full risk profile
- [ ] (If errors) See error display with retry option
</verification>

<success_criteria>
- Golden path works end-to-end: create -> upload -> process -> review (CASE-01)
- Processing takes 12-18 seconds with visible agent activity (CASE-02)
- Real-time progress visible via SSE (CASE-02)
- Error state shows clear feedback with retry (CASE-03)
- Integration test validates pipeline logic without server
- Page is demo-video ready (clean workflow, visual progress, clear completion)
</success_criteria>

<output>
After completion, create `.planning/phases/08-case-lifecycle-integration/08-05-SUMMARY.md`
</output>

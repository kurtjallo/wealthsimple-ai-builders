---
phase: 05-risk-scoring-narrative
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/agents/case-narrator.ts
  - src/lib/agents/narrator-prompts.ts
autonomous: true

must_haves:
  truths:
    - "Case Narrator agent generates a human-readable risk assessment narrative from all agent results"
    - "Narrative includes: summary, key findings, recommended action, and evidence links"
    - "Each claim in the narrative links back to a specific agent result or data point"
    - "Recommended action is approve/deny/escalate with clear reasoning"
    - "Agent registers with the orchestrator via registerAgent pattern from Phase 2"
  artifacts:
    - path: "src/lib/agents/case-narrator.ts"
      provides: "Case Narrator agent handler that registers with orchestrator"
      exports: ["caseNarratorHandler", "registerCaseNarrator"]
    - path: "src/lib/agents/narrator-prompts.ts"
      provides: "System prompts and prompt templates for narrative generation"
      exports: ["NARRATOR_SYSTEM_PROMPT", "buildNarrativePrompt"]
  key_links:
    - from: "src/lib/agents/case-narrator.ts"
      to: "src/lib/agents/base-agent.ts"
      via: "uses runAgent pattern from Phase 2"
      pattern: "import.*from.*base-agent"
    - from: "src/lib/agents/case-narrator.ts"
      to: "src/lib/agents/orchestrator.ts"
      via: "registers handler with registerAgent"
      pattern: "registerAgent.*case_narrator"
    - from: "src/lib/agents/case-narrator.ts"
      to: "src/lib/agents/narrator-prompts.ts"
      via: "imports prompt builder"
      pattern: "import.*buildNarrativePrompt.*from.*narrator-prompts"
---

<objective>
Build the Case Narrator agent (ORCH-06) — the final agent in the pipeline that synthesizes all agent results into a human-readable risk assessment narrative with linked evidence.

Purpose: The compliance officer shouldn't read raw agent outputs. The Case Narrator transforms machine data into a structured narrative: "Here's what we found, here's what's concerning, and here's what we recommend." Every claim links back to specific evidence. This is the final output the officer reviews before making their approve/deny/escalate decision.

Output: A Case Narrator agent handler that generates structured narratives with key findings, evidence links, and recommended actions — registered with the Phase 2 orchestrator.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/agents.ts (CaseNarratorInput, CaseNarratorOutput, AgentResult, DocumentProcessorOutput, IdentityVerifierOutput, SanctionsScreenerOutput, RiskScorerOutput)
@src/lib/agents/base-agent.ts (runAgent, AgentHandler)
@src/lib/agents/orchestrator.ts (registerAgent)
@src/lib/agents/agent-config.ts (AGENT_CONFIGS.case_narrator — model: gemini-2.5-pro, temperature: 0.3)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create narrator prompt templates</name>
  <files>src/lib/agents/narrator-prompts.ts</files>
  <action>
    Create `src/lib/agents/narrator-prompts.ts` with the system prompt and prompt builder for narrative generation.

    **System prompt:**
    ```typescript
    export const NARRATOR_SYSTEM_PROMPT = `You are the Case Narrator agent in a KYC/AML compliance system. Your job is to synthesize the results from multiple specialized agents into a clear, structured risk assessment narrative for a compliance officer.

Your output must be STRUCTURED and EVIDENCE-LINKED:
- Every factual claim must reference a specific source (document, verification, screening result)
- Use precise language suitable for regulatory documentation
- Do not speculate — only report what the agents found
- Clearly distinguish between verified facts and uncertain findings
- Always provide a recommended action with reasoning

You write for a senior compliance officer who needs to make an approve/deny/escalate decision within minutes. Be concise but complete.`;
    ```

    **Prompt builder function:**
    ```typescript
    export function buildNarrativePrompt(input: CaseNarratorInput): string
    ```

    The prompt builder takes the CaseNarratorInput and constructs a detailed prompt that includes:

    1. **Applicant context** — name, case_id
    2. **Document Processing Results** — from input.document_result:
       - Which documents were processed
       - Extracted fields summary (names, DOB, addresses found)
       - Document quality scores
       - Any warnings or issues
    3. **Identity Verification Results** — from input.identity_result:
       - Verification status (verified/unverified)
       - Which fields matched/didn't match
       - Discrepancies found
    4. **Sanctions Screening Results** — from input.sanctions_result:
       - Whether flagged
       - Which lists checked
       - Any matches found (with details)
    5. **Risk Scoring Results** — from input.risk_result:
       - Composite risk score and level
       - Risk factors breakdown
       - Whether manual review is required
       - Scoring summary

    The prompt should instruct Gemini to return a JSON response matching this structure:
    ```json
    {
      "narrative": "A 2-3 paragraph assessment...",
      "key_findings": ["Finding 1", "Finding 2", ...],
      "recommended_action": "approve | deny | escalate",
      "evidence_links": [
        { "claim": "Passport verified with 95% confidence", "source": "Document Processor - passport extraction", "confidence": 0.95 },
        ...
      ]
    }
    ```

    Handle gracefully when agent results have `success: false` — note in the prompt that certain data is unavailable and instruct the narrative to reflect the uncertainty.

    IMPORTANT: The prompt must explicitly say to respond with ONLY the JSON object, no markdown code fences, no preamble. This allows direct JSON.parse on the response.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - NARRATOR_SYSTEM_PROMPT is a non-empty string with compliance-appropriate language
    - buildNarrativePrompt accepts CaseNarratorInput and returns a string
    - buildNarrativePrompt handles cases where agent results have success === false
    - Prompt instructs Gemini to return valid JSON matching CaseNarratorOutput shape
  </verify>
  <done>Narrator prompt templates created. System prompt establishes compliance tone and evidence-linking requirement. Prompt builder serializes all agent results into a comprehensive context for narrative generation.</done>
</task>

<task type="auto">
  <name>Task 2: Create Case Narrator agent handler and register with orchestrator</name>
  <files>src/lib/agents/case-narrator.ts</files>
  <action>
    Create `src/lib/agents/case-narrator.ts` — the Case Narrator agent that integrates with the Phase 2 orchestrator.

    Follow the exact same patterns as the Risk Scorer (Plan 01) and Phase 2 base agent:

    **Agent handler function:**
    ```typescript
    import { GoogleGenerativeAI } from '@google/generative-ai';
    import { CaseNarratorInput, CaseNarratorOutput, AgentConfig } from '@/types';
    import { NARRATOR_SYSTEM_PROMPT, buildNarrativePrompt } from './narrator-prompts';

    export async function caseNarratorHandler(
      input: CaseNarratorInput,
      client: GoogleGenerativeAI,
      config: AgentConfig,
    ): Promise<CaseNarratorOutput> {
      const prompt = buildNarrativePrompt(input);

      const model = client.getGenerativeModel({ model: config.model });
      const result = await model.generateContent({
        contents: [{ role: 'user', parts: [{ text: prompt }] }],
        systemInstruction: NARRATOR_SYSTEM_PROMPT,
      });

      const responseText = result.response.text() || '';

      // Parse the JSON response from Gemini
      try {
        const parsed = JSON.parse(responseText);

        // Validate the required fields exist
        return {
          narrative: parsed.narrative || 'Unable to generate narrative.',
          key_findings: Array.isArray(parsed.key_findings) ? parsed.key_findings : [],
          recommended_action: validateAction(parsed.recommended_action),
          evidence_links: Array.isArray(parsed.evidence_links)
            ? parsed.evidence_links.map((link: any) => ({
                claim: String(link.claim || ''),
                source: String(link.source || ''),
                confidence: typeof link.confidence === 'number' ? link.confidence : 0,
              }))
            : [],
        };
      } catch (parseError) {
        // If JSON parse fails, use the raw text as narrative and provide defaults
        return {
          narrative: responseText || 'Unable to generate narrative — LLM response was not valid JSON.',
          key_findings: ['Narrative generation encountered a formatting issue. Raw assessment available above.'],
          recommended_action: 'escalate',
          evidence_links: [],
        };
      }
    }

    function validateAction(action: unknown): string {
      const validActions = ['approve', 'deny', 'escalate'];
      if (typeof action === 'string' && validActions.includes(action)) {
        return action;
      }
      return 'escalate'; // Default to escalate if unclear — safest option
    }
    ```

    Key design choices:
    - **JSON parsing with fallback** — if Gemini doesn't return valid JSON, use raw text as narrative and default to 'escalate' (safest option for compliance)
    - **Input validation on evidence_links** — coerce types to match CaseNarratorOutput even if Gemini returns slightly different shapes
    - **Default to escalate** — when in doubt, escalate. A false escalation is far less costly than a false approval in compliance.

    **Registration function:**
    ```typescript
    import { registerAgent } from './orchestrator';

    export function registerCaseNarrator(): void {
      registerAgent('case_narrator', caseNarratorHandler);
    }
    ```

    The handler signature matches what `runAgent` expects: `(input: TInput, client: GoogleGenerativeAI, config: AgentConfig) => Promise<TOutput>`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `caseNarratorHandler` signature matches `(input: CaseNarratorInput, client: GoogleGenerativeAI, config: AgentConfig) => Promise<CaseNarratorOutput>`
    - `registerCaseNarrator` calls `registerAgent('case_narrator', caseNarratorHandler)`
    - Handler uses system prompt from narrator-prompts.ts
    - Handler uses buildNarrativePrompt to construct the user message
    - JSON parse error falls back gracefully (narrative = raw text, action = escalate)
    - Return type matches CaseNarratorOutput from src/types/agents.ts exactly (narrative, key_findings, recommended_action, evidence_links)
  </verify>
  <done>Case Narrator agent handler built. Uses Gemini with structured JSON output to generate compliance narratives. Falls back to escalate on any parsing failure. Registers with orchestrator via registerAgent. Follows Phase 2 base-agent pattern exactly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new files
2. Narrator system prompt establishes compliance-appropriate tone
3. buildNarrativePrompt includes all four upstream agent results
4. caseNarratorHandler parses JSON and falls back gracefully
5. Default action is 'escalate' (safest for compliance — never auto-approve)
6. registerCaseNarrator wires into orchestrator registry
7. Handler signature matches Phase 2 base-agent pattern
</verification>

<success_criteria>
- Case Narrator generates structured narrative with linked evidence (ORCH-06)
- Narrative includes summary, key findings, recommended action, evidence links
- Every factual claim references a specific agent result
- JSON parse failure defaults to escalate (safe compliance behavior)
- Agent integrates with Phase 2 orchestrator pattern (registerAgent)
</success_criteria>

<output>
After completion, create `.planning/phases/05-risk-scoring-narrative/05-02-SUMMARY.md`
</output>

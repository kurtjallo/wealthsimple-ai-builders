---
phase: 05-risk-scoring-narrative
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/lib/agents/register-all.ts
  - src/app/api/cases/[id]/risk/route.ts
  - src/app/api/cases/[id]/narrative/route.ts
autonomous: true

must_haves:
  truths:
    - "Both Risk Scorer and Case Narrator agents are registered with the orchestrator in a single setup call"
    - "API endpoint allows triggering risk scoring for a case and persists result to agent_runs"
    - "API endpoint allows triggering narrative generation for a case and persists result to agent_runs"
    - "Case record is updated with risk_score, risk_level, and narrative after agent execution"
  artifacts:
    - path: "src/lib/agents/register-all.ts"
      provides: "Single entry point to register all agent handlers with the orchestrator"
      exports: ["registerAllAgents"]
    - path: "src/app/api/cases/[id]/risk/route.ts"
      provides: "POST endpoint to trigger risk scoring for a case"
      exports: ["POST"]
    - path: "src/app/api/cases/[id]/narrative/route.ts"
      provides: "POST endpoint to trigger narrative generation for a case"
      exports: ["POST"]
  key_links:
    - from: "src/lib/agents/register-all.ts"
      to: "src/lib/agents/risk-scorer.ts"
      via: "imports and calls registerRiskScorer"
      pattern: "import.*registerRiskScorer"
    - from: "src/lib/agents/register-all.ts"
      to: "src/lib/agents/case-narrator.ts"
      via: "imports and calls registerCaseNarrator"
      pattern: "import.*registerCaseNarrator"
    - from: "src/app/api/cases/[id]/risk/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "reads case data and writes agent_run results"
      pattern: "import.*supabase"
---

<objective>
Wire the Risk Scorer and Case Narrator agents into the orchestrator and create API endpoints for triggering them individually. This enables both the orchestrator pipeline and direct API access for testing and dashboard integration.

Purpose: Phase 6 (Dashboard) and Phase 8 (Case Lifecycle) need API endpoints to trigger risk scoring and narrative generation. This plan creates those endpoints while also ensuring both agents register with the orchestrator for the full pipeline flow.

Output: Agent registration module, risk scoring API endpoint, narrative generation API endpoint — all wired to Supabase for persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-risk-scoring-narrative/05-01-SUMMARY.md
@.planning/phases/05-risk-scoring-narrative/05-02-SUMMARY.md
@src/lib/agents/orchestrator.ts (registerAgent, processCase)
@src/lib/supabase/server.ts (createServerSupabaseClient)
@src/types/agents.ts (RiskScorerInput, CaseNarratorInput)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent registration module</name>
  <files>src/lib/agents/register-all.ts</files>
  <action>
    Create `src/lib/agents/register-all.ts` — single entry point for registering all agent handlers.

    ```typescript
    import { registerRiskScorer } from './risk-scorer';
    import { registerCaseNarrator } from './case-narrator';

    let registered = false;

    /**
     * Register all agent handlers with the orchestrator.
     * Safe to call multiple times — only registers once.
     *
     * Call this at app startup or before processing any case.
     * As more agents are built (Phases 3, 4), add their registration here.
     */
    export function registerAllAgents(): void {
      if (registered) return;

      registerRiskScorer();
      registerCaseNarrator();

      // TODO: Phase 3 — registerDocumentProcessor();
      // TODO: Phase 4 — registerIdentityVerifier();
      // TODO: Phase 4 — registerSanctionsScreener();

      registered = true;
    }
    ```

    This is the central wiring point. When Phases 3 and 4 are executed, their agents will add registration lines here. The `registered` guard prevents double-registration in serverless environments where modules may be re-imported.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `registerAllAgents` imports and calls both registerRiskScorer and registerCaseNarrator
    - Double-call protection via the `registered` boolean
  </verify>
  <done>Central agent registration module created. Both Risk Scorer and Case Narrator register on first call. Extensible for future agents.</done>
</task>

<task type="auto">
  <name>Task 2: Create risk scoring and narrative API endpoints</name>
  <files>src/app/api/cases/[id]/risk/route.ts, src/app/api/cases/[id]/narrative/route.ts</files>
  <action>
    **Create `src/app/api/cases/[id]/risk/route.ts`:**

    POST endpoint that triggers risk scoring for a specific case.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createServerSupabaseClient } from '@/lib/supabase/server';
    import { registerAllAgents } from '@/lib/agents/register-all';
    import { runAgent } from '@/lib/agents/base-agent';
    import { AGENT_CONFIGS } from '@/lib/agents/agent-config';
    import { riskScorerHandler } from '@/lib/agents/risk-scorer';

    // Ensure agents are registered
    registerAllAgents();

    export async function POST(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id: caseId } = await params;

      try {
        const supabase = createServerSupabaseClient();

        // 1. Load case data
        const { data: caseData, error: caseError } = await supabase
          .from('cases')
          .select('*')
          .eq('id', caseId)
          .single();

        if (caseError || !caseData) {
          return NextResponse.json({ error: 'Case not found' }, { status: 404 });
        }

        // 2. Load latest completed agent results for this case
        const { data: agentRuns } = await supabase
          .from('agent_runs')
          .select('*')
          .eq('case_id', caseId)
          .in('agent_type', ['document_processor', 'identity_verifier', 'sanctions_screener'])
          .eq('status', 'completed')
          .order('completed_at', { ascending: false });

        // 3. Build RiskScorerInput from agent_runs
        const docRun = agentRuns?.find(r => r.agent_type === 'document_processor');
        const idRun = agentRuns?.find(r => r.agent_type === 'identity_verifier');
        const sanctionsRun = agentRuns?.find(r => r.agent_type === 'sanctions_screener');

        if (!docRun && !idRun && !sanctionsRun) {
          return NextResponse.json(
            { error: 'No upstream agent results found. Run document processing, identity verification, and sanctions screening first.' },
            { status: 400 }
          );
        }

        // Build AgentResult objects from stored runs
        const buildResult = (run: any) => ({
          success: run?.status === 'completed',
          data: run?.output || null,
          error: run?.error || null,
          confidence: run?.confidence || 0,
          duration_ms: 0,
          agent_type: run?.agent_type,
          metadata: {},
        });

        const riskInput = {
          case_id: caseId,
          document_result: buildResult(docRun),
          identity_result: buildResult(idRun),
          sanctions_result: buildResult(sanctionsRun),
        };

        // 4. Run risk scorer agent
        const result = await runAgent(
          'risk_scorer',
          riskInput,
          AGENT_CONFIGS.risk_scorer,
          riskScorerHandler,
        );

        // 5. Persist agent run to Supabase
        await supabase.from('agent_runs').insert({
          case_id: caseId,
          agent_type: 'risk_scorer',
          status: result.success ? 'completed' : 'failed',
          started_at: new Date(Date.now() - result.duration_ms).toISOString(),
          completed_at: new Date().toISOString(),
          input: riskInput,
          output: result.data,
          confidence: result.confidence,
          error: result.error,
        });

        // 6. Update case with risk score if successful
        if (result.success && result.data) {
          await supabase.from('cases').update({
            risk_score: result.data.risk_score,
            risk_level: result.data.risk_level,
            status: result.data.requires_manual_review ? 'review' : caseData.status,
          }).eq('id', caseId);
        }

        return NextResponse.json(result);
      } catch (error) {
        return NextResponse.json(
          { error: error instanceof Error ? error.message : 'Internal error' },
          { status: 500 }
        );
      }
    }
    ```

    **Create `src/app/api/cases/[id]/narrative/route.ts`:**

    POST endpoint that triggers narrative generation for a specific case. Same structural pattern as the risk endpoint.

    Implementation:
    1. Load case data from Supabase
    2. Load all 4 completed agent results (document_processor, identity_verifier, sanctions_screener, risk_scorer)
    3. Require risk_scorer to have run first — return 400 if not found: "Risk scoring must complete before narrative generation."
    4. Build CaseNarratorInput from stored agent_runs:
       ```typescript
       const narrativeInput = {
         case_id: caseId,
         applicant_name: caseData.applicant_name,
         document_result: buildResult(docRun),
         identity_result: buildResult(idRun),
         sanctions_result: buildResult(sanctionsRun),
         risk_result: buildResult(riskRun),
       };
       ```
    5. Call `runAgent('case_narrator', narrativeInput, AGENT_CONFIGS.case_narrator, caseNarratorHandler)`
    6. Persist to agent_runs table
    7. Update `cases.narrative` with the generated narrative text
    8. Update `cases.status` to 'review' if not already in a terminal state

    IMPORTANT: Use Next.js 15 dynamic route params — `params` is a Promise that must be awaited.

    IMPORTANT: Both endpoints call `registerAllAgents()` at module level to ensure agents are wired up before any request.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Both API routes export POST handlers
    - Risk endpoint: POST /api/cases/[id]/risk — triggers risk scoring, persists to agent_runs, updates cases
    - Narrative endpoint: POST /api/cases/[id]/narrative — triggers narrative gen, persists to agent_runs, updates cases.narrative
    - Both endpoints handle missing upstream results gracefully (400 with clear message)
    - Both endpoints persist agent_runs records for audit trail
    - With valid case and upstream results: endpoints return agent results with 200
    - With missing case: 404
    - With missing upstream results: 400 with helpful error message
  </verify>
  <done>API endpoints for risk scoring and narrative generation created. Both persist results to agent_runs table and update the case record. Endpoints are ready for dashboard integration (Phase 6) and case lifecycle (Phase 8).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new files
2. registerAllAgents wires both agents into the orchestrator
3. POST /api/cases/[id]/risk triggers scoring and returns RiskScorerOutput
4. POST /api/cases/[id]/narrative triggers narrative and returns CaseNarratorOutput
5. Both endpoints persist agent_run records to Supabase
6. Both endpoints update the case record (risk_score, risk_level, narrative, status)
7. Missing upstream results return 400 with clear error message
</verification>

<success_criteria>
- Both agents registered with orchestrator for full pipeline execution
- API endpoints provide direct access for testing and dashboard integration
- Agent results persisted to agent_runs table (audit trail requirement for Phase 9)
- Case record updated with risk score and narrative
- Endpoints handle edge cases (missing case, missing upstream results)
</success_criteria>

<output>
After completion, create `.planning/phases/05-risk-scoring-narrative/05-03-SUMMARY.md`
</output>

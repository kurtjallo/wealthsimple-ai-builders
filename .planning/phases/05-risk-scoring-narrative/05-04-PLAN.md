---
phase: 05-risk-scoring-narrative
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - src/agents/orchestrator/risk-scoring-step.ts
  - src/lib/supabase/risk-assessment-repo.ts
autonomous: true

must_haves:
  truths:
    - "Orchestrator invokes Risk Scorer then Case Narrator in sequence as part of the case processing pipeline"
    - "Risk assessment and narrative are persisted to Supabase after generation"
    - "Auto-escalation on critical risk score updates case status and notifies"
    - "Errors in risk scoring or narration are handled gracefully without crashing the pipeline"
  artifacts:
    - path: "src/agents/orchestrator/risk-scoring-step.ts"
      provides: "Orchestration step that runs risk scoring + narration pipeline"
      exports: ["executeRiskScoringStep"]
    - path: "src/lib/supabase/risk-assessment-repo.ts"
      provides: "Supabase persistence for risk assessments and narratives"
      exports: ["saveRiskAssessment", "saveCaseNarrative", "getRiskAssessmentByCaseId", "getCaseNarrativeByCaseId"]
  key_links:
    - from: "src/agents/orchestrator/risk-scoring-step.ts"
      to: "src/agents/risk-scorer/index.ts"
      via: "calls runRiskScorer with agent signals"
      pattern: "import.*runRiskScorer"
    - from: "src/agents/orchestrator/risk-scoring-step.ts"
      to: "src/agents/case-narrator/index.ts"
      via: "calls runCaseNarrator with risk assessment"
      pattern: "import.*runCaseNarrator"
    - from: "src/agents/orchestrator/risk-scoring-step.ts"
      to: "src/lib/supabase/risk-assessment-repo.ts"
      via: "persists results after generation"
      pattern: "import.*saveRiskAssessment.*saveCaseNarrative"
    - from: "src/lib/supabase/risk-assessment-repo.ts"
      to: "supabase/migrations/05_risk_assessment.sql"
      via: "queries tables defined in migration"
      pattern: "risk_assessments|case_narratives"
---

<objective>
Wire the Risk Scorer and Case Narrator agents into the orchestration pipeline with Supabase persistence and auto-escalation handling.

Purpose: This is the integration glue that makes the agents usable in the real pipeline. Without this, the agents are isolated modules. This plan connects them to the orchestrator, persists results for the dashboard, and implements the auto-escalation workflow for critical risk cases.

Output: An orchestration step function that the main orchestrator calls after document processing and screening are complete, plus a Supabase repository for reading/writing risk data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-risk-scoring-narrative/05-01-SUMMARY.md
@.planning/phases/05-risk-scoring-narrative/05-02-SUMMARY.md
@.planning/phases/05-risk-scoring-narrative/05-03-SUMMARY.md
@src/types/risk.ts
@src/types/narrative.ts
@src/agents/risk-scorer/index.ts
@src/agents/case-narrator/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase repository for risk assessments and narratives</name>
  <files>src/lib/supabase/risk-assessment-repo.ts</files>
  <action>
Create `src/lib/supabase/risk-assessment-repo.ts` — data access layer for the risk_assessments and case_narratives tables.

Import the Supabase client from wherever Phase 1 established it (check `src/lib/supabase/client.ts` or similar). Import types from `@/types/risk` and `@/types/narrative`.

**Function 1: `saveRiskAssessment(assessment: RiskAssessment): Promise<string>`**
- Insert into `risk_assessments` table
- Map TypeScript fields to snake_case DB columns:
  - assessment.score.compositeScore → composite_score
  - assessment.score.category → risk_category
  - assessment.score.componentScores.documentRisk → document_risk_score
  - assessment.score.componentScores.identityRisk → identity_risk_score
  - assessment.score.componentScores.sanctionsRisk → sanctions_risk_score
  - assessment.score.componentScores.pepRisk → pep_risk_score
  - assessment.score.confidence.overall → overall_confidence
  - assessment.score.confidence.breakdown → confidence_breakdown (JSONB)
  - assessment.signals → agent_signals (JSONB)
  - assessment.score.autoEscalate → auto_escalate
  - assessment.score.escalationReason → escalation_reason
  - assessment.assessedAt → assessed_at
  - assessment.assessedBy → assessed_by
- Return the inserted row's UUID

**Function 2: `saveCaseNarrative(narrative: CaseNarrative): Promise<string>`**
- Insert into `case_narratives` table
- Map TypeScript fields to snake_case DB columns:
  - narrative.summary → summary
  - narrative.keyFindings → key_findings (JSONB)
  - narrative.riskFactors → risk_factors (JSONB)
  - narrative.recommendedAction → recommended_action (JSONB)
  - narrative.evidenceLinks → evidence_links (JSONB)
  - narrative.generatedAt → generated_at
  - narrative.generatedBy → generated_by
  - narrative.modelUsed → model_used
- Return the inserted row's UUID

**Function 3: `getRiskAssessmentByCaseId(caseId: string): Promise<RiskAssessment | null>`**
- Query `risk_assessments` WHERE case_id = caseId, ORDER BY created_at DESC, LIMIT 1
- Map snake_case columns back to TypeScript types
- Return null if not found

**Function 4: `getCaseNarrativeByCaseId(caseId: string): Promise<CaseNarrative | null>`**
- Query `case_narratives` WHERE case_id = caseId, ORDER BY created_at DESC, LIMIT 1
- Map snake_case columns back to TypeScript types
- Return null if not found

Follow the Supabase query patterns established in Phase 1. Use the `@supabase/supabase-js` client. Handle errors by throwing descriptive errors (let the caller handle).
  </action>
  <verify>
1. `npx tsc --noEmit src/lib/supabase/risk-assessment-repo.ts` — compiles
2. All four functions exported and typed correctly
3. Field mapping covers all columns in the migration schema
4. JSONB fields are properly serialized/deserialized
  </verify>
  <done>Supabase repository provides full CRUD for risk assessments and case narratives. Field mapping between TypeScript camelCase and PostgreSQL snake_case is complete. Queries return latest assessment/narrative per case.</done>
</task>

<task type="auto">
  <name>Task 2: Create orchestration step for risk scoring pipeline</name>
  <files>src/agents/orchestrator/risk-scoring-step.ts</files>
  <action>
Create `src/agents/orchestrator/risk-scoring-step.ts` — the orchestration step that the main orchestrator calls after document processing and screening complete.

```typescript
interface RiskScoringStepInput {
  caseId: string;
  signals: {
    document: DocumentSignal;
    identity: IdentitySignal;
    sanctions: SanctionsSignal;
    pep: PEPSignal;
  };
}

interface RiskScoringStepOutput {
  riskAssessment: RiskAssessment;
  caseNarrative: CaseNarrative;
  autoEscalated: boolean;
}
```

**Function: `executeRiskScoringStep(input: RiskScoringStepInput): Promise<RiskScoringStepOutput>`**

Sequence:
1. **Run Risk Scorer:**
   - Call `runRiskScorer(input.signals)` from risk-scorer agent
   - Set caseId on the returned RiskAssessment
   - Save to Supabase via `saveRiskAssessment()`
   - Log: "Risk assessment complete for case {caseId}: {category} ({score}/100)"

2. **Run Case Narrator:**
   - Call `runCaseNarrator(riskAssessment, input.signals)` from case-narrator agent
   - Save to Supabase via `saveCaseNarrative()`
   - Log: "Case narrative generated for case {caseId}: {recommendedAction.action}"

3. **Handle auto-escalation:**
   - If `riskAssessment.score.autoEscalate === true`:
     - Update the case status in Supabase to 'escalated' (use whatever case update pattern Phase 2 established)
     - Log: "ALERT: Case {caseId} auto-escalated — {escalationReason}"
     - Set `autoEscalated = true` in output
   - Otherwise: `autoEscalated = false`

4. **Return** `{ riskAssessment, caseNarrative, autoEscalated }`

**Error handling:**
- If Risk Scorer fails: throw with context ("Risk scoring failed for case {caseId}: {error.message}")
- If Case Narrator fails: still save the risk assessment (it completed), throw with context for the narrative failure
- If Supabase save fails: log the error but don't lose the in-memory results — return them anyway and let the caller decide

This function is designed to be called by the main orchestrator (from Phase 2) as a step in the pipeline. The orchestrator collects signals from Phase 3 and Phase 4 agents, then passes them here.

Follow the orchestrator step patterns from Phase 2. Check `src/agents/orchestrator/` for existing step files to match the pattern.
  </action>
  <verify>
1. `npx tsc --noEmit src/agents/orchestrator/risk-scoring-step.ts` — compiles
2. Function calls Risk Scorer before Case Narrator (narrator needs risk score)
3. Both results persisted to Supabase
4. Auto-escalation triggers on critical risk
5. Partial failure handling: risk assessment saved even if narrator fails
6. Input/output types are clean and well-defined
  </verify>
  <done>Orchestration step wires Risk Scorer → Case Narrator → Supabase persistence → auto-escalation in a single callable function. Handles partial failures gracefully. Returns complete output for downstream use (dashboard, audit).</done>
</task>

</tasks>

<verification>
1. Both files compile without TypeScript errors
2. `executeRiskScoringStep` calls runRiskScorer then runCaseNarrator in sequence
3. Both results are persisted to Supabase
4. Auto-escalation updates case status when risk is critical
5. Error handling allows partial success (risk saved even if narrative fails)
6. Repository functions correctly map between TypeScript types and Supabase columns
</verification>

<success_criteria>
- Orchestrator can call `executeRiskScoringStep(caseId, signals)` and get back both risk assessment and narrative
- Results are persisted in Supabase for dashboard display
- Critical risk cases are auto-escalated
- Graceful error handling for partial failures
- Clean API that downstream phases (6, 7, 8) can consume
</success_criteria>

<output>
After completion, create `.planning/phases/05-risk-scoring-narrative/05-04-SUMMARY.md`
</output>

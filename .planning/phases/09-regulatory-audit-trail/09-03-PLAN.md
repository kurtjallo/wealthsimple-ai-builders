---
phase: 09-regulatory-audit-trail
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/app/api/cases/[id]/audit/route.ts
  - src/app/api/cases/[id]/audit/export/route.ts
  - src/components/audit/audit-trail-viewer.tsx
autonomous: true

must_haves:
  truths:
    - "Audit trail is viewable within the dashboard for any case"
    - "Audit trail shows a chronological timeline of all events: agent actions, human decisions, system events"
    - "Each audit entry displays: timestamp, actor (agent or officer), action, and summary details"
    - "Audit trail is filterable by event type (agent actions, human decisions, all)"
    - "Audit trail is exportable as CSV for compliance review"
  artifacts:
    - path: "src/app/api/cases/[id]/audit/route.ts"
      provides: "GET endpoint returning the full audit trail for a case"
      exports: ["GET"]
    - path: "src/app/api/cases/[id]/audit/export/route.ts"
      provides: "GET endpoint returning audit trail as downloadable CSV"
      exports: ["GET"]
    - path: "src/components/audit/audit-trail-viewer.tsx"
      provides: "React component displaying audit trail timeline with filtering"
      exports: ["AuditTrailViewer"]
  key_links:
    - from: "src/app/api/cases/[id]/audit/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "queries audit_logs table for a case"
      pattern: "import.*createServerSupabaseClient.*from.*supabase/server"
    - from: "src/app/api/cases/[id]/audit/export/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "queries audit_logs for CSV export"
      pattern: "import.*createServerSupabaseClient.*from.*supabase/server"
    - from: "src/components/audit/audit-trail-viewer.tsx"
      to: "/api/cases/[id]/audit"
      via: "fetches audit trail data from API"
      pattern: "fetch.*api/cases.*audit"
---

<objective>
Build the audit trail viewer and export functionality. A compliance officer must be able to view the complete audit trail for any case within the dashboard (chronological timeline of agent actions, human decisions, and system events) and export it as CSV for compliance review or external reporting.

Purpose: REG-04 (FINTRAC/PCMLTFA record-keeping) and DASH-05 (audit trail logging) require that the audit trail is not just stored but also accessible and exportable. This is a key demo talking point — it shows the system is production-aware and built for regulatory scrutiny.

Output: API endpoints for reading and exporting audit data, and a React component for viewing the audit timeline with filtering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-regulatory-audit-trail/09-01-SUMMARY.md
@src/types/index.ts (AuditLog, ActorType, AgentType)
@src/lib/supabase/server.ts (createServerSupabaseClient)
@src/lib/audit/types.ts (AuditEventType, AgentAuditPayload, HumanDecisionAuditPayload, SystemAuditPayload)
@src/lib/audit/constants.ts (AUDIT_ACTIONS)
@src/components/ui/card.tsx (shadcn Card component)
@src/components/ui/badge.tsx (shadcn Badge component)
@src/components/ui/scroll-area.tsx (shadcn ScrollArea component)
@src/components/ui/tabs.tsx (shadcn Tabs component)
@src/components/ui/button.tsx (shadcn Button component)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit trail API endpoints (read + CSV export)</name>
  <files>src/app/api/cases/[id]/audit/route.ts, src/app/api/cases/[id]/audit/export/route.ts</files>
  <action>
    **1. Create `src/app/api/cases/[id]/audit/route.ts`:**

    GET endpoint that returns the full audit trail for a case, ordered chronologically.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createServerSupabaseClient } from '@/lib/supabase/server';

    export async function GET(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id: caseId } = await params;

      try {
        const supabase = createServerSupabaseClient();

        // Parse optional filter from query params
        const { searchParams } = new URL(request.url);
        const eventType = searchParams.get('event_type'); // 'agent_action' | 'human_decision' | 'system_event' | null (all)
        const limit = parseInt(searchParams.get('limit') || '100', 10);
        const offset = parseInt(searchParams.get('offset') || '0', 10);

        // Build query
        let query = supabase
          .from('audit_logs')
          .select('*', { count: 'exact' })
          .eq('case_id', caseId)
          .order('created_at', { ascending: true })
          .range(offset, offset + limit - 1);

        // Apply event_type filter if provided
        // Filter on actor_type since event_type column may not exist yet
        if (eventType === 'agent_action') {
          query = query.eq('actor_type', 'agent');
        } else if (eventType === 'human_decision') {
          query = query.eq('actor_type', 'officer');
        } else if (eventType === 'system_event') {
          query = query.eq('actor_type', 'system');
        }

        const { data: auditLogs, error, count } = await query;

        if (error) {
          return NextResponse.json(
            { error: 'Failed to fetch audit trail: ' + error.message },
            { status: 500 },
          );
        }

        // Enrich audit log entries with human-readable labels
        const enrichedLogs = (auditLogs || []).map(log => ({
          ...log,
          // Add display-friendly fields
          actor_label: getActorLabel(log.actor_type, log.actor_id),
          action_label: getActionLabel(log.action),
          summary: getEventSummary(log),
          timestamp_formatted: new Date(log.created_at).toLocaleString('en-CA', {
            dateStyle: 'medium',
            timeStyle: 'medium',
          }),
        }));

        return NextResponse.json({
          case_id: caseId,
          audit_trail: enrichedLogs,
          total_count: count || 0,
          limit,
          offset,
          fintrac_notice: 'This audit trail meets FINTRAC/PCMLTFA record-keeping requirements. Records must be retained for 5+ years.',
        });
      } catch (error) {
        return NextResponse.json(
          { error: error instanceof Error ? error.message : 'Internal server error' },
          { status: 500 },
        );
      }
    }

    // Helper: Human-readable actor label
    function getActorLabel(actorType: string, actorId: string): string {
      switch (actorType) {
        case 'agent':
          const agentNames: Record<string, string> = {
            document_processor: 'Document Processor Agent',
            identity_verifier: 'Identity Verifier Agent',
            sanctions_screener: 'Sanctions Screener Agent',
            risk_scorer: 'Risk Scorer Agent',
            case_narrator: 'Case Narrator Agent',
            orchestrator: 'Orchestrator',
          };
          return agentNames[actorId] || `Agent: ${actorId}`;
        case 'officer':
          return `Officer: ${actorId}`;
        case 'system':
          return 'System';
        default:
          return actorId;
      }
    }

    // Helper: Human-readable action label
    function getActionLabel(action: string): string {
      const labels: Record<string, string> = {
        'agent.started': 'Agent Started',
        'agent.completed': 'Agent Completed',
        'agent.failed': 'Agent Failed',
        'decision.approved': 'Case Approved',
        'decision.denied': 'Case Denied',
        'decision.escalated': 'Case Escalated',
        'decision.str_referred': 'STR Referral',
        'case.created': 'Case Created',
        'case.status_changed': 'Status Changed',
        'case.assigned': 'Case Assigned',
        'case.documents_uploaded': 'Documents Uploaded',
        'pipeline.started': 'Pipeline Started',
        'pipeline.completed': 'Pipeline Completed',
        'pipeline.failed': 'Pipeline Failed',
        'system.error': 'System Error',
        'system.export_generated': 'Audit Export Generated',
      };
      return labels[action] || action;
    }

    // Helper: Generate one-line summary from audit log details
    function getEventSummary(log: Record<string, unknown>): string {
      const details = log.details as Record<string, unknown> | null;
      if (!details) return String(log.action);

      const eventType = details.event_type;

      if (eventType === 'agent_action') {
        const success = details.success ? 'completed' : 'failed';
        const confidence = typeof details.confidence === 'number'
          ? ` (confidence: ${(details.confidence as number * 100).toFixed(0)}%)`
          : '';
        return `${details.agent_type} ${success}${confidence}. ${details.output_summary || ''}`.trim();
      }

      if (eventType === 'human_decision') {
        return `Officer ${details.officer_id} ${details.decision}: "${details.justification}"`;
      }

      if (eventType === 'system_event' || eventType === 'case_lifecycle') {
        return String(details.description || log.action);
      }

      return String(log.action);
    }
    ```

    **2. Create `src/app/api/cases/[id]/audit/export/route.ts`:**

    GET endpoint that returns the audit trail as a downloadable CSV file.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createServerSupabaseClient } from '@/lib/supabase/server';
    import { logSystemEvent, AUDIT_ACTIONS } from '@/lib/audit/logger';

    export async function GET(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      const { id: caseId } = await params;

      try {
        const supabase = createServerSupabaseClient();

        // Fetch ALL audit logs for this case (no pagination for export)
        const { data: auditLogs, error } = await supabase
          .from('audit_logs')
          .select('*')
          .eq('case_id', caseId)
          .order('created_at', { ascending: true });

        if (error) {
          return NextResponse.json(
            { error: 'Failed to fetch audit trail: ' + error.message },
            { status: 500 },
          );
        }

        if (!auditLogs || auditLogs.length === 0) {
          return NextResponse.json(
            { error: 'No audit trail found for this case' },
            { status: 404 },
          );
        }

        // Build CSV content
        const csvHeaders = [
          'Timestamp',
          'Actor Type',
          'Actor ID',
          'Action',
          'Event Type',
          'Details Summary',
          'Confidence',
          'Justification',
          'Case ID',
          'Audit Log ID',
        ];

        const csvRows = auditLogs.map(log => {
          const details = log.details as Record<string, unknown> | null;
          const eventType = details?.event_type || '';
          const confidence = details?.confidence != null ? String(details.confidence) : '';
          const justification = details?.justification || details?.description || '';
          const summary = getExportSummary(log);

          return [
            log.created_at,
            log.actor_type,
            log.actor_id,
            log.action,
            String(eventType),
            summary,
            confidence,
            String(justification),
            log.case_id,
            log.id,
          ].map(field => `"${String(field).replace(/"/g, '""')}"`);
        });

        const csvContent = [
          csvHeaders.join(','),
          ...csvRows.map(row => row.join(',')),
        ].join('\n');

        // Add FINTRAC compliance header as a comment row
        const fintracHeader = `"# FINTRAC/PCMLTFA Audit Trail Export - Case ${caseId} - Generated ${new Date().toISOString()} - Records must be retained for 5+ years"`;
        const fullCsv = fintracHeader + '\n' + csvContent;

        // Log that an export was generated (audit the audit)
        await logSystemEvent(caseId, AUDIT_ACTIONS.EXPORT_GENERATED, {
          description: `Audit trail exported as CSV. ${auditLogs.length} entries.`,
          metadata: { format: 'csv', entry_count: auditLogs.length },
        });

        // Return as downloadable CSV
        return new NextResponse(fullCsv, {
          status: 200,
          headers: {
            'Content-Type': 'text/csv; charset=utf-8',
            'Content-Disposition': `attachment; filename="audit-trail-${caseId}-${new Date().toISOString().split('T')[0]}.csv"`,
          },
        });
      } catch (error) {
        return NextResponse.json(
          { error: error instanceof Error ? error.message : 'Internal server error' },
          { status: 500 },
        );
      }
    }

    function getExportSummary(log: Record<string, unknown>): string {
      const details = log.details as Record<string, unknown> | null;
      if (!details) return String(log.action);

      if (details.event_type === 'agent_action') {
        return `${details.agent_type}: ${details.output_summary || (details.success ? 'completed' : 'failed')}`;
      }
      if (details.event_type === 'human_decision') {
        return `${details.decision}: ${details.justification}`;
      }
      return String(details.description || log.action);
    }
    ```

    IMPORTANT: Use Next.js 15 dynamic route params — `params` is a Promise.
    IMPORTANT: The CSV export also logs itself to the audit trail (audit the audit — this shows the system is thorough).
  </action>
  <verify>
    - `npx tsc --noEmit` passes for both API routes
    - GET /api/cases/[id]/audit returns JSON with audit_trail array, total_count, fintrac_notice
    - GET /api/cases/[id]/audit?event_type=agent_action filters to agent events only
    - GET /api/cases/[id]/audit?event_type=human_decision filters to officer decisions only
    - GET /api/cases/[id]/audit/export returns CSV with Content-Disposition header
    - CSV includes FINTRAC compliance header row
    - CSV has proper column headers and escaped fields
    - Export endpoint logs itself to audit trail (EXPORT_GENERATED action)
    - Both endpoints handle missing case / empty results gracefully
  </verify>
  <done>Audit trail API endpoints created. Read endpoint returns enriched audit entries with human-readable labels, filtering, and pagination. Export endpoint returns downloadable CSV with FINTRAC compliance header. Export itself is audited.</done>
</task>

<task type="auto">
  <name>Task 2: Create AuditTrailViewer React component</name>
  <files>src/components/audit/audit-trail-viewer.tsx</files>
  <action>
    Create `src/components/audit/audit-trail-viewer.tsx` — a React component that displays the audit trail as a timeline within the dashboard case view.

    ```typescript
    'use client';

    import { useState, useEffect, useCallback } from 'react';
    import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
    import { Badge } from '@/components/ui/badge';
    import { Button } from '@/components/ui/button';
    import { ScrollArea } from '@/components/ui/scroll-area';
    import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
    import {
      Download,
      Bot,
      User,
      Monitor,
      CheckCircle,
      XCircle,
      AlertTriangle,
      Clock,
      FileText,
      Shield,
    } from 'lucide-react';

    interface AuditEntry {
      id: string;
      case_id: string;
      action: string;
      actor_type: string;
      actor_id: string;
      details: Record<string, unknown> | null;
      created_at: string;
      // Enriched fields from API
      actor_label: string;
      action_label: string;
      summary: string;
      timestamp_formatted: string;
    }

    interface AuditTrailViewerProps {
      caseId: string;
    }

    export function AuditTrailViewer({ caseId }: AuditTrailViewerProps) {
      const [entries, setEntries] = useState<AuditEntry[]>([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);
      const [filter, setFilter] = useState<string>('all');
      const [totalCount, setTotalCount] = useState(0);
      const [exporting, setExporting] = useState(false);

      const fetchAuditTrail = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
          const filterParam = filter !== 'all' ? `?event_type=${filter}` : '';
          const response = await fetch(`/api/cases/${caseId}/audit${filterParam}`);
          if (!response.ok) {
            throw new Error('Failed to load audit trail');
          }
          const data = await response.json();
          setEntries(data.audit_trail || []);
          setTotalCount(data.total_count || 0);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Unknown error');
        } finally {
          setLoading(false);
        }
      }, [caseId, filter]);

      useEffect(() => {
        fetchAuditTrail();
      }, [fetchAuditTrail]);

      const handleExportCSV = async () => {
        setExporting(true);
        try {
          const response = await fetch(`/api/cases/${caseId}/audit/export`);
          if (!response.ok) throw new Error('Export failed');

          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `audit-trail-${caseId}-${new Date().toISOString().split('T')[0]}.csv`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        } catch (err) {
          setError('Failed to export audit trail');
        } finally {
          setExporting(false);
        }
      };

      const getActorIcon = (actorType: string) => {
        switch (actorType) {
          case 'agent': return <Bot className="h-4 w-4" />;
          case 'officer': return <User className="h-4 w-4" />;
          case 'system': return <Monitor className="h-4 w-4" />;
          default: return <Monitor className="h-4 w-4" />;
        }
      };

      const getActionIcon = (action: string) => {
        if (action.includes('completed') || action.includes('approved')) {
          return <CheckCircle className="h-4 w-4 text-green-500" />;
        }
        if (action.includes('failed') || action.includes('denied')) {
          return <XCircle className="h-4 w-4 text-red-500" />;
        }
        if (action.includes('escalated') || action.includes('str')) {
          return <AlertTriangle className="h-4 w-4 text-amber-500" />;
        }
        if (action.includes('started') || action.includes('created')) {
          return <Clock className="h-4 w-4 text-blue-500" />;
        }
        return <FileText className="h-4 w-4 text-muted-foreground" />;
      };

      const getActorBadgeVariant = (actorType: string): 'default' | 'secondary' | 'outline' => {
        switch (actorType) {
          case 'agent': return 'secondary';
          case 'officer': return 'default';
          case 'system': return 'outline';
          default: return 'outline';
        }
      };

      return (
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-4">
            <div className="flex items-center gap-2">
              <Shield className="h-5 w-5 text-muted-foreground" />
              <CardTitle className="text-lg">Audit Trail</CardTitle>
              <Badge variant="outline" className="text-xs">
                {totalCount} entries
              </Badge>
            </div>
            <Button
              variant="outline"
              size="sm"
              onClick={handleExportCSV}
              disabled={exporting || entries.length === 0}
            >
              <Download className="h-4 w-4 mr-2" />
              {exporting ? 'Exporting...' : 'Export CSV'}
            </Button>
          </CardHeader>
          <CardContent>
            <Tabs value={filter} onValueChange={setFilter}>
              <TabsList className="mb-4">
                <TabsTrigger value="all">All Events</TabsTrigger>
                <TabsTrigger value="agent_action">Agent Actions</TabsTrigger>
                <TabsTrigger value="human_decision">Decisions</TabsTrigger>
                <TabsTrigger value="system_event">System</TabsTrigger>
              </TabsList>

              <TabsContent value={filter} className="mt-0">
                {loading ? (
                  <div className="flex items-center justify-center py-8 text-muted-foreground">
                    Loading audit trail...
                  </div>
                ) : error ? (
                  <div className="flex items-center justify-center py-8 text-red-500">
                    {error}
                  </div>
                ) : entries.length === 0 ? (
                  <div className="flex items-center justify-center py-8 text-muted-foreground">
                    No audit entries found
                  </div>
                ) : (
                  <ScrollArea className="h-[400px] pr-4">
                    <div className="space-y-1">
                      {entries.map((entry, index) => (
                        <div
                          key={entry.id}
                          className="flex gap-3 py-3 border-b border-border/50 last:border-0"
                        >
                          {/* Timeline indicator */}
                          <div className="flex flex-col items-center pt-1">
                            <div className="flex h-6 w-6 items-center justify-center rounded-full bg-muted">
                              {getActorIcon(entry.actor_type)}
                            </div>
                            {index < entries.length - 1 && (
                              <div className="w-px flex-1 bg-border mt-1" />
                            )}
                          </div>

                          {/* Entry content */}
                          <div className="flex-1 min-w-0">
                            <div className="flex items-center gap-2 flex-wrap">
                              {getActionIcon(entry.action)}
                              <span className="font-medium text-sm">
                                {entry.action_label}
                              </span>
                              <Badge variant={getActorBadgeVariant(entry.actor_type)} className="text-xs">
                                {entry.actor_label}
                              </Badge>
                            </div>
                            <p className="text-sm text-muted-foreground mt-1 truncate">
                              {entry.summary}
                            </p>
                            <p className="text-xs text-muted-foreground/70 mt-0.5">
                              {entry.timestamp_formatted}
                            </p>

                            {/* Show confidence for agent actions */}
                            {entry.details && (entry.details as Record<string, unknown>).confidence != null && (
                              <div className="mt-1">
                                <Badge variant="outline" className="text-xs">
                                  Confidence: {((entry.details as Record<string, unknown>).confidence as number * 100).toFixed(0)}%
                                </Badge>
                              </div>
                            )}

                            {/* Show justification for human decisions */}
                            {entry.details && (entry.details as Record<string, unknown>).justification && (
                              <div className="mt-1 text-xs bg-muted/50 rounded px-2 py-1">
                                <span className="font-medium">Justification:</span>{' '}
                                {String((entry.details as Record<string, unknown>).justification)}
                              </div>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  </ScrollArea>
                )}
              </TabsContent>
            </Tabs>

            {/* FINTRAC compliance footer */}
            <div className="mt-4 pt-3 border-t text-xs text-muted-foreground/60 flex items-center gap-1">
              <Shield className="h-3 w-3" />
              FINTRAC/PCMLTFA compliant audit trail. Records retained for 5+ years.
            </div>
          </CardContent>
        </Card>
      );
    }
    ```

    KEY DESIGN DECISIONS:
    1. **Timeline layout** — Each entry has a timeline dot with actor icon, action icon with color coding, and summary text. This is easy to scan quickly.
    2. **Tab filtering** — Filter by All, Agent Actions, Decisions, System events. Uses the API's event_type query param.
    3. **Confidence badges** — Agent action entries show confidence score as a badge.
    4. **Justification display** — Human decision entries show the justification text inline.
    5. **CSV export button** — Downloads the full audit trail as CSV via the export endpoint.
    6. **FINTRAC footer** — Subtle compliance badge at the bottom. Shows the system is regulation-aware.
    7. **Uses shadcn components** — Card, Badge, Button, ScrollArea, Tabs from the existing component library.

    IMPORTANT: This component uses `'use client'` directive — it fetches data client-side and manages filter state. It should be embedded in the case detail page (from Phase 6/8).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Component exports AuditTrailViewer
    - AuditTrailViewer accepts caseId prop
    - Component fetches from /api/cases/{caseId}/audit on mount
    - Tab filter changes trigger re-fetch with event_type query param
    - Export CSV button triggers download from /api/cases/{caseId}/audit/export
    - Loading, error, and empty states all handled
    - Timeline shows actor icon (Bot/User/Monitor), action icon (color-coded), summary, timestamp
    - Agent entries show confidence badge
    - Human decision entries show justification text
    - FINTRAC compliance footer present
    - All imports use existing shadcn components (Card, Badge, Button, ScrollArea, Tabs)
  </verify>
  <done>Audit trail viewer component built with timeline layout, tab filtering (all/agent/decision/system), CSV export, confidence badges for agents, justification display for decisions, and FINTRAC compliance footer. Ready to embed in case detail page.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new files
2. GET /api/cases/[id]/audit returns enriched audit entries with actor_label, action_label, summary
3. GET /api/cases/[id]/audit?event_type=agent_action filters correctly
4. GET /api/cases/[id]/audit/export returns downloadable CSV with proper headers
5. CSV includes FINTRAC compliance header and all required columns
6. AuditTrailViewer component renders timeline with filtering and export
7. Component handles loading, error, and empty states
8. Agent entries show confidence, human entries show justification
</verification>

<success_criteria>
- Audit trail viewable within the dashboard for any case (DASH-05, REG-04)
- Chronological timeline shows all events with actor, action, and details
- Filterable by event type (agent actions, human decisions, system events)
- Exportable as CSV with FINTRAC compliance header for external review (REG-04)
- Export action is itself audited (shows thoroughness)
</success_criteria>

<output>
After completion, create `.planning/phases/09-regulatory-audit-trail/09-03-SUMMARY.md`
</output>

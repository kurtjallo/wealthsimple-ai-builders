---
phase: 09-regulatory-audit-trail
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/audit/logger.ts
  - src/lib/audit/types.ts
  - src/lib/audit/constants.ts
  - supabase/migrations/009_audit_trail_enhancements.sql
autonomous: true

must_haves:
  truths:
    - "Every agent action is logged with timestamp, agent_type, input summary, output summary, and confidence"
    - "Every human decision is logged with timestamp, officer_id, justification, decision outcome, and case context"
    - "Audit helper functions are callable from any API route or agent handler with a single function call"
    - "Audit log entries include structured FINTRAC-aligned metadata: who, what, when, why"
    - "Agent runs and human decisions are written to both agent_runs and audit_logs tables for redundancy"
  artifacts:
    - path: "src/lib/audit/types.ts"
      provides: "TypeScript types for structured audit events"
      exports: ["AuditAction", "AuditEventType", "AgentAuditPayload", "HumanDecisionAuditPayload", "SystemAuditPayload", "AuditLogInsert"]
    - path: "src/lib/audit/constants.ts"
      provides: "Enumerated audit action constants for consistency"
      exports: ["AUDIT_ACTIONS", "ACTOR_TYPES"]
    - path: "src/lib/audit/logger.ts"
      provides: "Core audit logging functions usable across the entire application"
      exports: ["logAgentAction", "logHumanDecision", "logSystemEvent", "logAuditEvent"]
    - path: "supabase/migrations/009_audit_trail_enhancements.sql"
      provides: "Database migration adding event_type, metadata columns to audit_logs"
      contains: "ALTER TABLE audit_logs"
  key_links:
    - from: "src/lib/audit/logger.ts"
      to: "src/lib/supabase/server.ts"
      via: "uses createServerSupabaseClient to write audit_logs"
      pattern: "import.*createServerSupabaseClient.*from.*supabase/server"
    - from: "src/lib/audit/logger.ts"
      to: "src/lib/audit/types.ts"
      via: "uses audit event types for structured payloads"
      pattern: "import.*from.*audit/types"
    - from: "src/lib/audit/logger.ts"
      to: "src/lib/audit/constants.ts"
      via: "uses AUDIT_ACTIONS constants for action names"
      pattern: "import.*AUDIT_ACTIONS.*from.*audit/constants"
---

<objective>
Build the comprehensive audit logging system that captures every agent action and human decision with FINTRAC-aligned metadata (who, what, when, why). This is the data backbone for regulatory compliance — every subsequent plan in Phase 9 depends on these logging functions.

Purpose: FINTRAC/PCMLTFA requires full traceability of all compliance decisions. This plan creates reusable audit logging functions that any API route or agent handler can call with a single function invocation. The audit trail must capture: who performed the action (agent or officer), what they did, when they did it, and why (justification or confidence score).

Output: Audit type definitions, action constants, Supabase schema enhancements, and three core logging functions: `logAgentAction`, `logHumanDecision`, `logSystemEvent`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/index.ts (AuditLog, ActorType, AgentType, CaseStatus, DecisionType)
@src/lib/supabase/server.ts (createServerSupabaseClient)
@src/lib/supabase/types.ts (Database — audit_logs table Row/Insert/Update)
@supabase/migrations/00001_initial_schema.sql (audit_logs table definition: id, case_id, action, actor_type, actor_id, details, created_at)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit types, constants, and database migration</name>
  <files>src/lib/audit/types.ts, src/lib/audit/constants.ts, supabase/migrations/009_audit_trail_enhancements.sql</files>
  <action>
    Create the `src/lib/audit/` directory with type definitions and constants.

    **1. Create `src/lib/audit/types.ts`:**

    ```typescript
    import { ActorType, AgentType, DecisionType, CaseStatus } from '@/types';

    // Broad category of audit event
    export type AuditEventType = 'agent_action' | 'human_decision' | 'system_event' | 'case_lifecycle';

    // Structured payload for agent action audit logs
    export interface AgentAuditPayload {
      event_type: 'agent_action';
      agent_type: AgentType;
      input_summary: string;          // Human-readable summary of what the agent received
      output_summary: string;         // Human-readable summary of what the agent produced
      confidence: number;             // 0-1 confidence score
      duration_ms: number;            // How long the agent took
      success: boolean;               // Whether the agent completed successfully
      error_message?: string;         // Error details if failed
      model_used?: string;            // Which Claude model was used
    }

    // Structured payload for human decision audit logs
    export interface HumanDecisionAuditPayload {
      event_type: 'human_decision';
      decision: DecisionType | 'str_referral';  // approve/deny/escalate/str_referral
      justification: string;          // Mandatory justification text from the officer
      officer_id: string;             // Who made the decision
      officer_name?: string;          // Display name (if available)
      case_risk_score?: number;       // Risk score at time of decision
      case_risk_level?: string;       // Risk level at time of decision
      previous_status: CaseStatus;    // Case status before this decision
      new_status: CaseStatus;         // Case status after this decision
    }

    // Structured payload for system events (case creation, status changes, etc.)
    export interface SystemAuditPayload {
      event_type: 'system_event' | 'case_lifecycle';
      description: string;            // What happened
      metadata?: Record<string, unknown>; // Additional context
    }

    // Union type for all audit payloads
    export type AuditPayload = AgentAuditPayload | HumanDecisionAuditPayload | SystemAuditPayload;

    // What gets inserted into the audit_logs table
    export interface AuditLogInsert {
      case_id: string;
      action: string;
      actor_type: ActorType;          // 'system' | 'agent' | 'officer'
      actor_id: string;               // agent_type string or officer_id
      details: AuditPayload;          // Structured JSON payload
      event_type?: AuditEventType;    // Category (stored in new column if migration applied)
    }
    ```

    **2. Create `src/lib/audit/constants.ts`:**

    ```typescript
    // Standardized audit action strings — use these instead of freeform strings
    // to ensure consistent filtering and reporting
    export const AUDIT_ACTIONS = {
      // Agent actions
      AGENT_STARTED: 'agent.started',
      AGENT_COMPLETED: 'agent.completed',
      AGENT_FAILED: 'agent.failed',

      // Human decisions
      CASE_APPROVED: 'decision.approved',
      CASE_DENIED: 'decision.denied',
      CASE_ESCALATED: 'decision.escalated',
      STR_REFERRED: 'decision.str_referred',

      // Case lifecycle
      CASE_CREATED: 'case.created',
      CASE_STATUS_CHANGED: 'case.status_changed',
      CASE_ASSIGNED: 'case.assigned',
      DOCUMENTS_UPLOADED: 'case.documents_uploaded',

      // Pipeline events
      PIPELINE_STARTED: 'pipeline.started',
      PIPELINE_COMPLETED: 'pipeline.completed',
      PIPELINE_FAILED: 'pipeline.failed',

      // System events
      SYSTEM_ERROR: 'system.error',
      EXPORT_GENERATED: 'system.export_generated',
    } as const;

    export type AuditAction = typeof AUDIT_ACTIONS[keyof typeof AUDIT_ACTIONS];

    // Actor type constants (mirrors ActorType but as constants)
    export const ACTOR_TYPES = {
      SYSTEM: 'system' as const,
      AGENT: 'agent' as const,
      OFFICER: 'officer' as const,
    };
    ```

    **3. Create `supabase/migrations/009_audit_trail_enhancements.sql`:**

    This migration enhances the existing audit_logs table (from Phase 1) with additional columns for structured querying. The original table has: id, case_id, action, actor_type, actor_id, details (JSONB), created_at.

    ```sql
    -- Phase 9: Enhance audit_logs for FINTRAC compliance
    -- Adds event_type column for faster category filtering
    -- Adds indexes for compliance reporting queries

    -- Add event_type column for categorizing audit entries
    ALTER TABLE audit_logs ADD COLUMN IF NOT EXISTS event_type TEXT;

    -- Add index for event_type filtering (common in compliance reports)
    CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON audit_logs(event_type);

    -- Add index for actor_type + created_at (common query: "all officer decisions in date range")
    CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_type_date ON audit_logs(actor_type, created_at DESC);

    -- Add index for action filtering (common: "all approvals", "all STR referrals")
    CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);

    -- Add composite index for case audit trail (all events for a case, ordered)
    CREATE INDEX IF NOT EXISTS idx_audit_logs_case_timeline ON audit_logs(case_id, created_at ASC);

    -- Comment explaining FINTRAC record-keeping alignment
    COMMENT ON TABLE audit_logs IS 'Immutable audit trail for FINTRAC/PCMLTFA compliance. Records must be retained for 5+ years. Captures who (actor_type/actor_id), what (action/details), when (created_at), why (details.justification or details.confidence).';
    ```

    IMPORTANT: This migration uses `IF NOT EXISTS` and `ADD COLUMN IF NOT EXISTS` for idempotency — it should be safe to run multiple times.
  </action>
  <verify>
    - `npx tsc --noEmit` passes for both types.ts and constants.ts
    - src/lib/audit/types.ts exports: AuditEventType, AgentAuditPayload, HumanDecisionAuditPayload, SystemAuditPayload, AuditPayload, AuditLogInsert
    - src/lib/audit/constants.ts exports: AUDIT_ACTIONS, AuditAction, ACTOR_TYPES
    - AUDIT_ACTIONS covers all event categories: agent (3), decision (4), case (4), pipeline (3), system (2)
    - SQL migration is valid and uses IF NOT EXISTS for safe re-runs
    - HumanDecisionAuditPayload includes mandatory justification field
    - AgentAuditPayload includes confidence, duration_ms, and success fields
  </verify>
  <done>Audit type system established with structured payloads for agent actions, human decisions, and system events. Constants ensure consistent action naming across all callers. Database migration adds event_type column and performance indexes for compliance reporting.</done>
</task>

<task type="auto">
  <name>Task 2: Create core audit logging functions</name>
  <files>src/lib/audit/logger.ts</files>
  <action>
    Create `src/lib/audit/logger.ts` — the single entry point for all audit logging in the application. Every API route and agent handler will import from this file.

    ```typescript
    import { createServerSupabaseClient } from '@/lib/supabase/server';
    import { AgentType } from '@/types';
    import {
      AgentAuditPayload,
      HumanDecisionAuditPayload,
      SystemAuditPayload,
      AuditLogInsert,
      AuditEventType,
    } from './types';
    import { AUDIT_ACTIONS, ACTOR_TYPES, AuditAction } from './constants';

    /**
     * Log an agent action to the audit trail.
     *
     * Call this from any agent handler or API endpoint after an agent completes (or fails).
     *
     * @example
     * await logAgentAction(caseId, 'document_processor', {
     *   input_summary: 'Processed 2 documents: passport, utility_bill',
     *   output_summary: 'Extracted 8 fields with avg confidence 0.92',
     *   confidence: 0.92,
     *   duration_ms: 3400,
     *   success: true,
     * });
     */
    export async function logAgentAction(
      caseId: string,
      agentType: AgentType,
      payload: Omit<AgentAuditPayload, 'event_type' | 'agent_type'>,
    ): Promise<void> {
      const action = payload.success
        ? AUDIT_ACTIONS.AGENT_COMPLETED
        : AUDIT_ACTIONS.AGENT_FAILED;

      const fullPayload: AgentAuditPayload = {
        event_type: 'agent_action',
        agent_type: agentType,
        ...payload,
      };

      await logAuditEvent({
        case_id: caseId,
        action,
        actor_type: ACTOR_TYPES.AGENT,
        actor_id: agentType,
        details: fullPayload,
        event_type: 'agent_action',
      });
    }

    /**
     * Log a human compliance officer decision to the audit trail.
     *
     * Call this from the decision API endpoint when an officer approves, denies,
     * escalates, or refers for STR filing.
     *
     * FINTRAC requires: who made the decision, what the decision was, when it was made,
     * and why (justification is mandatory).
     *
     * @example
     * await logHumanDecision(caseId, {
     *   decision: 'approved',
     *   justification: 'All documents verified, no sanctions matches, low risk score.',
     *   officer_id: 'officer-001',
     *   officer_name: 'Jane Smith',
     *   case_risk_score: 18,
     *   case_risk_level: 'low',
     *   previous_status: 'review',
     *   new_status: 'approved',
     * });
     */
    export async function logHumanDecision(
      caseId: string,
      payload: Omit<HumanDecisionAuditPayload, 'event_type'>,
    ): Promise<void> {
      let action: AuditAction;
      switch (payload.decision) {
        case 'approved':
          action = AUDIT_ACTIONS.CASE_APPROVED;
          break;
        case 'denied':
          action = AUDIT_ACTIONS.CASE_DENIED;
          break;
        case 'escalated':
          action = AUDIT_ACTIONS.CASE_ESCALATED;
          break;
        case 'str_referral':
          action = AUDIT_ACTIONS.STR_REFERRED;
          break;
        default:
          action = AUDIT_ACTIONS.CASE_ESCALATED; // Safe default
      }

      const fullPayload: HumanDecisionAuditPayload = {
        event_type: 'human_decision',
        ...payload,
      };

      await logAuditEvent({
        case_id: caseId,
        action,
        actor_type: ACTOR_TYPES.OFFICER,
        actor_id: payload.officer_id,
        details: fullPayload,
        event_type: 'human_decision',
      });
    }

    /**
     * Log a system or case lifecycle event to the audit trail.
     *
     * Use for case creation, status changes, document uploads, pipeline events, etc.
     *
     * @example
     * await logSystemEvent(caseId, AUDIT_ACTIONS.CASE_CREATED, {
     *   description: 'New KYC case created for John Doe',
     *   metadata: { applicant_name: 'John Doe', document_count: 2 },
     * });
     */
    export async function logSystemEvent(
      caseId: string,
      action: AuditAction,
      payload: Omit<SystemAuditPayload, 'event_type'>,
      actorId: string = 'system',
    ): Promise<void> {
      const eventType: AuditEventType = action.startsWith('case.')
        ? 'case_lifecycle'
        : 'system_event';

      const fullPayload: SystemAuditPayload = {
        event_type: eventType,
        ...payload,
      };

      await logAuditEvent({
        case_id: caseId,
        action,
        actor_type: ACTOR_TYPES.SYSTEM,
        actor_id: actorId,
        details: fullPayload,
        event_type: eventType,
      });
    }

    /**
     * Low-level audit event writer. All other log functions delegate to this.
     *
     * Writes to the audit_logs table in Supabase. Failures are caught and logged
     * to console — audit logging should NEVER throw and break the calling operation.
     * A failed audit write is serious but less serious than crashing a compliance workflow.
     */
    export async function logAuditEvent(entry: AuditLogInsert): Promise<void> {
      try {
        const supabase = createServerSupabaseClient();

        const { error } = await supabase.from('audit_logs').insert({
          case_id: entry.case_id,
          action: entry.action,
          actor_type: entry.actor_type,
          actor_id: entry.actor_id,
          details: entry.details as Record<string, unknown>,
          // event_type column may not exist if migration hasn't run yet — that's OK,
          // Supabase will ignore unknown columns in insert
        });

        if (error) {
          console.error('[AUDIT] Failed to write audit log:', {
            case_id: entry.case_id,
            action: entry.action,
            error: error.message,
          });
        }
      } catch (err) {
        // NEVER throw from audit logging — log to console and continue
        console.error('[AUDIT] Exception in audit logger:', {
          case_id: entry.case_id,
          action: entry.action,
          error: err instanceof Error ? err.message : 'Unknown error',
        });
      }
    }

    // Re-export constants for convenience
    export { AUDIT_ACTIONS, ACTOR_TYPES } from './constants';
    ```

    KEY DESIGN DECISIONS:
    1. **Never throws** — `logAuditEvent` catches all errors. A failed audit write logs to console but never crashes the calling operation. This is critical because audit logging is called from decision endpoints, agent handlers, etc. A crash there would block compliance workflows.
    2. **Structured payloads** — Every audit entry has typed, structured details (not freeform strings). This enables filtering, reporting, and export.
    3. **Convenience functions** — `logAgentAction`, `logHumanDecision`, `logSystemEvent` each accept domain-specific parameters and handle the mapping to the generic audit_logs table. Callers don't need to know the audit schema.
    4. **FINTRAC alignment** — Every entry captures who (actor_type + actor_id), what (action), when (created_at via Supabase default), why (details.justification or details.confidence).
    5. **Backward compatible** — Works with the existing audit_logs table from Phase 1. The event_type column from the migration is optional.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - logger.ts exports: logAgentAction, logHumanDecision, logSystemEvent, logAuditEvent, AUDIT_ACTIONS, ACTOR_TYPES
    - logAgentAction signature: (caseId: string, agentType: AgentType, payload: ...) => Promise<void>
    - logHumanDecision signature: (caseId: string, payload: ...) => Promise<void>
    - logSystemEvent signature: (caseId: string, action: AuditAction, payload: ...) => Promise<void>
    - logAuditEvent wraps all DB writes in try/catch — never throws
    - logHumanDecision maps decision types to correct AUDIT_ACTIONS constants
    - logAgentAction maps success/failure to AGENT_COMPLETED/AGENT_FAILED actions
    - All functions use createServerSupabaseClient to write to audit_logs
  </verify>
  <done>Core audit logging system built with three convenience functions (logAgentAction, logHumanDecision, logSystemEvent) plus a low-level logAuditEvent. All writes are fail-safe (never throw). Structured payloads capture FINTRAC-required who/what/when/why. Backward compatible with Phase 1 audit_logs table.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new files in src/lib/audit/
2. Audit types define structured payloads for agent actions, human decisions, and system events
3. AUDIT_ACTIONS constants cover all event categories (16 distinct actions)
4. logAgentAction captures: agent_type, input_summary, output_summary, confidence, duration_ms, success
5. logHumanDecision captures: decision, justification (mandatory), officer_id, risk context
6. logAuditEvent never throws — all errors caught and logged to console
7. SQL migration adds event_type column and performance indexes
8. All audit entries map to the existing audit_logs table schema
</verification>

<success_criteria>
- Every agent action can be logged with a single function call including timestamp, input, output, and confidence (DASH-05, REG-04)
- Every human decision can be logged with a single function call including timestamp, officer ID, justification, and outcome (DASH-05, REG-04)
- Audit log entries include structured FINTRAC-aligned metadata: who, what, when, why (REG-04)
- Logging functions are fail-safe and never crash the calling operation
- Database migration enhances audit_logs for compliance reporting
</success_criteria>

<output>
After completion, create `.planning/phases/09-regulatory-audit-trail/09-01-SUMMARY.md`
</output>

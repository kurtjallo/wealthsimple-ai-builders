---
phase: 06-dashboard-core
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - src/app/api/cases/[id]/decision/route.ts
  - src/components/cases/decision-workflow.tsx
  - src/app/dashboard/cases/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "POST /api/cases/[id]/decision accepts { decision, justification } and validates both fields"
    - "Decision endpoint requires justification to be non-empty (mandatory justification field)"
    - "Decision endpoint updates case status to match decision (approved/denied/escalated) and records justification"
    - "Decision endpoint creates an audit_log entry recording the officer's decision with timestamp"
    - "Decision workflow UI shows three action buttons: Approve, Deny, Escalate"
    - "Selecting an action opens a confirmation dialog with mandatory justification textarea"
    - "After submitting decision, case status updates immediately in the UI without page reload"
    - "Decision workflow only appears for cases in 'review' status without existing decision"
  artifacts:
    - path: "src/app/api/cases/[id]/decision/route.ts"
      provides: "POST endpoint to record officer decision with mandatory justification"
      exports: ["POST"]
    - path: "src/components/cases/decision-workflow.tsx"
      provides: "Decision UI with action buttons, confirmation dialog, and justification textarea"
      exports: ["DecisionWorkflow"]
  key_links:
    - from: "src/components/cases/decision-workflow.tsx"
      to: "/api/cases/[id]/decision"
      via: "POSTs decision with justification to API"
      pattern: "fetch.*api/cases.*decision"
    - from: "src/app/api/cases/[id]/decision/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "updates cases table and inserts audit_log"
      pattern: "import.*createServerSupabaseClient"
    - from: "src/app/dashboard/cases/[id]/page.tsx"
      to: "src/components/cases/decision-workflow.tsx"
      via: "renders DecisionWorkflow for review cases"
      pattern: "import.*DecisionWorkflow"
---

<objective>
Build the decision workflow (DASH-04) — the mechanism for a compliance officer to Approve, Deny, or Escalate a case with mandatory justification. Includes the API endpoint that records the decision + audit trail, and the UI components for the decision interaction.

Purpose: This is the critical human-in-the-loop control point. AI processes the case and presents evidence, but a human officer makes the final call. The mandatory justification creates an audit trail explaining WHY the decision was made — a regulatory requirement. The UI must make the process clear, deliberate, and auditable.

Output: Decision API endpoint with validation, decision workflow component with confirmation dialog, and integration into the case detail page.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-dashboard-core/06-01-SUMMARY.md
@.planning/phases/06-dashboard-core/06-02-SUMMARY.md
@.planning/phases/06-dashboard-core/06-03-SUMMARY.md
@src/types/index.ts (Case, CaseStatus, DecisionType, AuditLog)
@src/lib/supabase/server.ts (createServerSupabaseClient)
@src/lib/constants.ts (DECISION_CONFIG)
@src/app/dashboard/cases/[id]/page.tsx (case detail page — replace decision placeholder)
@src/components/ui/dialog.tsx (shadcn Dialog)
@src/components/ui/textarea.tsx (shadcn Textarea)
@src/components/ui/button.tsx (shadcn Button)
@src/components/ui/alert.tsx (shadcn Alert)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create decision API endpoint with validation and audit logging</name>
  <files>src/app/api/cases/[id]/decision/route.ts</files>
  <action>
    Create `src/app/api/cases/[id]/decision/route.ts` — POST endpoint that records a compliance officer's decision.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createServerSupabaseClient } from '@/lib/supabase/server';

    const VALID_DECISIONS = ['approved', 'denied', 'escalated'] as const;
    type Decision = typeof VALID_DECISIONS[number];

    interface DecisionRequest {
      decision: Decision;
      justification: string;
      officer_id?: string;  // Optional — defaults to 'compliance-officer-1' for demo
    }

    export async function POST(
      request: NextRequest,
      { params }: { params: Promise<{ id: string }> }
    ) {
      try {
        const { id: caseId } = await params;
        const supabase = createServerSupabaseClient();

        // Parse and validate request body
        const body: DecisionRequest = await request.json();

        // Validate decision
        if (!body.decision || !VALID_DECISIONS.includes(body.decision)) {
          return NextResponse.json(
            {
              error: 'Invalid decision',
              details: `Decision must be one of: ${VALID_DECISIONS.join(', ')}`,
            },
            { status: 400 }
          );
        }

        // Validate justification — MANDATORY
        if (!body.justification || body.justification.trim().length === 0) {
          return NextResponse.json(
            {
              error: 'Justification required',
              details: 'A written justification is mandatory for all compliance decisions.',
            },
            { status: 400 }
          );
        }

        // Minimum justification length — prevent trivial entries
        if (body.justification.trim().length < 10) {
          return NextResponse.json(
            {
              error: 'Justification too short',
              details: 'Justification must be at least 10 characters. Please provide a meaningful explanation for your decision.',
            },
            { status: 400 }
          );
        }

        const officerId = body.officer_id || 'compliance-officer-1';

        // Verify case exists and is in a reviewable state
        const { data: caseData, error: caseError } = await supabase
          .from('cases')
          .select('id, status, decision')
          .eq('id', caseId)
          .single();

        if (caseError || !caseData) {
          return NextResponse.json(
            { error: 'Case not found' },
            { status: 404 }
          );
        }

        // Prevent decisions on cases not in review
        if (caseData.status !== 'review') {
          return NextResponse.json(
            {
              error: 'Case not reviewable',
              details: `Case is in '${caseData.status}' status. Only cases in 'review' status can receive decisions.`,
            },
            { status: 409 }
          );
        }

        // Prevent duplicate decisions
        if (caseData.decision) {
          return NextResponse.json(
            {
              error: 'Decision already made',
              details: `This case already has a decision: ${caseData.decision}. Decisions cannot be changed.`,
            },
            { status: 409 }
          );
        }

        // Map decision to case status
        const newStatus = body.decision; // approved, denied, escalated map directly to CaseStatus

        // Update case with decision
        const { error: updateError } = await supabase
          .from('cases')
          .update({
            status: newStatus,
            decision: body.decision,
            decision_justification: body.justification.trim(),
            officer_id: officerId,
          })
          .eq('id', caseId);

        if (updateError) {
          console.error('Error updating case:', updateError);
          return NextResponse.json(
            { error: 'Failed to record decision' },
            { status: 500 }
          );
        }

        // Create audit log entry
        const { error: auditError } = await supabase
          .from('audit_logs')
          .insert({
            case_id: caseId,
            action: `case_${body.decision}`,
            actor_type: 'officer',
            actor_id: officerId,
            details: {
              decision: body.decision,
              justification: body.justification.trim(),
              previous_status: caseData.status,
              new_status: newStatus,
              timestamp: new Date().toISOString(),
            },
          });

        if (auditError) {
          // Log but don't fail — the decision was recorded successfully
          console.error('Error creating audit log:', auditError);
        }

        // Return updated case
        const { data: updatedCase } = await supabase
          .from('cases')
          .select('*')
          .eq('id', caseId)
          .single();

        return NextResponse.json({
          success: true,
          case: updatedCase,
          message: `Case ${body.decision} successfully.`,
        });
      } catch (error) {
        console.error('Decision API error:', error);
        return NextResponse.json(
          { error: error instanceof Error ? error.message : 'Internal error' },
          { status: 500 }
        );
      }
    }
    ```

    KEY DESIGN DECISIONS:
    - **Mandatory justification with minimum length** — prevents trivial "ok" entries. Compliance requires meaningful explanations.
    - **Status guard** — only cases in 'review' status can receive decisions. Prevents decisions on pending/processing cases.
    - **Duplicate guard** — decisions are immutable. Once made, cannot be changed. (Phase 9 can add override workflow if needed.)
    - **Audit log** — every decision creates an audit_log entry with full context: who, what, why, when, and previous state. This is the foundation for Phase 9 regulatory compliance.
    - **Non-blocking audit** — if audit log insert fails, the decision still stands. We log the error but don't roll back the decision.
    - **Officer ID** — defaults to 'compliance-officer-1' for the demo. Phase 9 can add real auth.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - POST /api/cases/[id]/decision with valid body returns 200 with { success: true, case: {...} }
    - POST with missing justification returns 400 with "Justification required"
    - POST with justification < 10 chars returns 400 with "Justification too short"
    - POST with invalid decision returns 400 with "Invalid decision"
    - POST on non-existent case returns 404
    - POST on case not in 'review' status returns 409 with "Case not reviewable"
    - POST on case with existing decision returns 409 with "Decision already made"
    - After successful decision: case status updated, decision and justification recorded, audit_log entry created
    - Test with curl:
      ```
      curl -X POST http://localhost:3000/api/cases/CASE_UUID/decision \
        -H "Content-Type: application/json" \
        -d '{"decision":"approved","justification":"All documents verified, no sanctions hits, low risk score."}'
      ```
  </verify>
  <done>Decision API endpoint created with comprehensive validation. Mandatory justification enforced. Case status updated immediately. Audit trail created for every decision. Guards against invalid state transitions and duplicate decisions.</done>
</task>

<task type="auto">
  <name>Task 2: Create decision workflow UI component and integrate into case detail page</name>
  <files>src/components/cases/decision-workflow.tsx, src/app/dashboard/cases/[id]/page.tsx</files>
  <action>
    **Create `src/components/cases/decision-workflow.tsx`:**

    Decision workflow with three action buttons, confirmation dialog, and mandatory justification textarea.

    ```typescript
    'use client';

    import { useState } from 'react';
    import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
    import { Button } from '@/components/ui/button';
    import { Textarea } from '@/components/ui/textarea';
    import {
      Dialog,
      DialogContent,
      DialogDescription,
      DialogFooter,
      DialogHeader,
      DialogTitle,
    } from '@/components/ui/dialog';
    import { Alert, AlertDescription } from '@/components/ui/alert';
    import { Badge } from '@/components/ui/badge';
    import { cn } from '@/lib/utils';
    import {
      CheckCircle2,
      XCircle,
      AlertTriangle,
      Loader2,
      Scale,
      AlertCircle,
    } from 'lucide-react';

    type DecisionType = 'approved' | 'denied' | 'escalated';

    interface DecisionWorkflowProps {
      caseId: string;
      onDecisionMade: (decision: DecisionType, justification: string) => void;
    }

    const DECISION_OPTIONS: Array<{
      value: DecisionType;
      label: string;
      description: string;
      icon: React.ComponentType<{ className?: string }>;
      buttonVariant: 'default' | 'destructive' | 'outline';
      confirmClass: string;
      dialogTitle: string;
      dialogDescription: string;
    }> = [
      {
        value: 'approved',
        label: 'Approve',
        description: 'Clear the applicant — all checks passed',
        icon: CheckCircle2,
        buttonVariant: 'default',
        confirmClass: 'bg-emerald-600 hover:bg-emerald-700 text-white',
        dialogTitle: 'Approve This Case',
        dialogDescription: 'You are approving this KYC application. The applicant will be cleared for account opening. This decision is final and will be recorded in the audit trail.',
      },
      {
        value: 'denied',
        label: 'Deny',
        description: 'Reject the application — significant concerns identified',
        icon: XCircle,
        buttonVariant: 'destructive',
        confirmClass: 'bg-red-600 hover:bg-red-700 text-white',
        dialogTitle: 'Deny This Case',
        dialogDescription: 'You are denying this KYC application. The applicant will not be cleared for account opening. This decision is final and will be recorded in the audit trail.',
      },
      {
        value: 'escalated',
        label: 'Escalate',
        description: 'Refer to senior compliance — further review needed',
        icon: AlertTriangle,
        buttonVariant: 'outline',
        confirmClass: 'bg-purple-600 hover:bg-purple-700 text-white',
        dialogTitle: 'Escalate This Case',
        dialogDescription: 'You are escalating this case to senior compliance for further review. Please provide context explaining why escalation is needed.',
      },
    ];

    export function DecisionWorkflow({ caseId, onDecisionMade }: DecisionWorkflowProps) {
      const [selectedDecision, setSelectedDecision] = useState<DecisionType | null>(null);
      const [justification, setJustification] = useState('');
      const [isSubmitting, setIsSubmitting] = useState(false);
      const [error, setError] = useState<string | null>(null);
      const [dialogOpen, setDialogOpen] = useState(false);

      const selectedOption = DECISION_OPTIONS.find(o => o.value === selectedDecision);

      const handleSelectDecision = (decision: DecisionType) => {
        setSelectedDecision(decision);
        setJustification('');
        setError(null);
        setDialogOpen(true);
      };

      const handleSubmit = async () => {
        if (!selectedDecision) return;

        if (justification.trim().length < 10) {
          setError('Please provide a meaningful justification (at least 10 characters).');
          return;
        }

        setIsSubmitting(true);
        setError(null);

        try {
          const response = await fetch(`/api/cases/${caseId}/decision`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              decision: selectedDecision,
              justification: justification.trim(),
            }),
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || data.details || 'Failed to submit decision');
          }

          // Success — notify parent
          setDialogOpen(false);
          onDecisionMade(selectedDecision, justification.trim());
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to submit decision');
        } finally {
          setIsSubmitting(false);
        }
      };

      const handleClose = () => {
        if (!isSubmitting) {
          setDialogOpen(false);
          setSelectedDecision(null);
          setJustification('');
          setError(null);
        }
      };

      return (
        <>
          <Card className="border-primary/20">
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Scale className="h-4 w-4" />
                Officer Decision
              </CardTitle>
              <CardDescription>
                Review the evidence above and make your compliance decision. A written justification is required for audit purposes.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid gap-3 sm:grid-cols-3">
                {DECISION_OPTIONS.map((option) => {
                  const Icon = option.icon;
                  return (
                    <Button
                      key={option.value}
                      variant={option.buttonVariant}
                      className={cn(
                        'h-auto flex-col gap-2 py-4',
                        option.value === 'approved' && 'border-emerald-200 hover:bg-emerald-50 hover:text-emerald-700',
                        option.value === 'escalated' && 'border-purple-200 hover:bg-purple-50 hover:text-purple-700',
                      )}
                      onClick={() => handleSelectDecision(option.value)}
                    >
                      <Icon className="h-5 w-5" />
                      <span className="font-medium">{option.label}</span>
                      <span className="text-xs font-normal opacity-70 text-center">
                        {option.description}
                      </span>
                    </Button>
                  );
                })}
              </div>
            </CardContent>
          </Card>

          {/* Confirmation Dialog */}
          <Dialog open={dialogOpen} onOpenChange={handleClose}>
            <DialogContent className="sm:max-w-lg">
              <DialogHeader>
                <DialogTitle className="flex items-center gap-2">
                  {selectedOption && (
                    <>
                      <selectedOption.icon className="h-5 w-5" />
                      {selectedOption.dialogTitle}
                    </>
                  )}
                </DialogTitle>
                <DialogDescription>
                  {selectedOption?.dialogDescription}
                </DialogDescription>
              </DialogHeader>

              <div className="space-y-4 py-2">
                <div>
                  <label
                    htmlFor="justification"
                    className="block text-sm font-medium mb-2"
                  >
                    Justification <span className="text-destructive">*</span>
                  </label>
                  <Textarea
                    id="justification"
                    placeholder="Explain your reasoning for this decision. Reference specific evidence from the risk profile and agent findings..."
                    value={justification}
                    onChange={(e) => {
                      setJustification(e.target.value);
                      if (error) setError(null);
                    }}
                    rows={4}
                    className="resize-none"
                    disabled={isSubmitting}
                  />
                  <p className="mt-1.5 text-xs text-muted-foreground">
                    {justification.trim().length}/10 minimum characters
                    {justification.trim().length >= 10 && (
                      <span className="ml-1 text-emerald-600">
                        <CheckCircle2 className="inline h-3 w-3" /> Meets minimum
                      </span>
                    )}
                  </p>
                </div>

                {error && (
                  <Alert variant="destructive">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription>{error}</AlertDescription>
                  </Alert>
                )}
              </div>

              <DialogFooter className="gap-2 sm:gap-0">
                <Button
                  variant="outline"
                  onClick={handleClose}
                  disabled={isSubmitting}
                >
                  Cancel
                </Button>
                <Button
                  onClick={handleSubmit}
                  disabled={isSubmitting || justification.trim().length < 10}
                  className={cn(
                    selectedOption?.confirmClass,
                    'gap-1.5',
                  )}
                >
                  {isSubmitting ? (
                    <>
                      <Loader2 className="h-4 w-4 animate-spin" />
                      Submitting...
                    </>
                  ) : (
                    <>
                      Confirm {selectedOption?.label}
                    </>
                  )}
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </>
      );
    }
    ```

    **Update `src/app/dashboard/cases/[id]/page.tsx`:**

    Replace the decision placeholder with the actual DecisionWorkflow component.

    Changes to make:
    1. Add import: `import { DecisionWorkflow } from '@/components/cases/decision-workflow';`
    2. Add state for tracking if decision was just made:
       ```typescript
       const [decisionMade, setDecisionMade] = useState(false);
       ```
    3. Replace the decision placeholder card (the one with `border-dashed border-2` and "Decision workflow will appear here") with:
       ```typescript
       {caseData.status === 'review' && !caseData.decision && !decisionMade && (
         <DecisionWorkflow
           caseId={caseData.id}
           onDecisionMade={(decision, justification) => {
             // Update local state immediately without refetch
             setCaseData(prev => prev ? {
               ...prev,
               status: decision,
               decision: decision,
               decision_justification: justification,
             } : null);
             setDecisionMade(true);
           }}
         />
       )}
       ```
    4. The existing decision display card (showing decision badge and justification when `caseData.decision` exists) stays as-is — it will show after `onDecisionMade` updates the local state.

    IMPORTANT: Read the existing file first before modifying. Only change the decision-related sections. Do not modify the risk profile, narrative, agent results, or evidence sections.

    The `onDecisionMade` callback updates local state immediately so the UI reflects the decision without a full page reload. The case status badge in the header also updates because it reads from `caseData.status`.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Navigate to case detail page for a case in 'review' status — decision workflow appears
    - Three buttons visible: Approve (green), Deny (red), Escalate (purple)
    - Clicking any button opens confirmation dialog with justification textarea
    - Submit button is disabled until justification has 10+ characters
    - Character counter shows progress toward minimum
    - Submitting with valid justification: dialog closes, case status updates immediately, decision badge appears
    - Error from API (e.g., case already decided): error alert appears in dialog
    - Cancel button closes dialog without submitting
    - Decision workflow does NOT appear for cases not in 'review' status
    - Decision workflow does NOT appear for cases that already have a decision
    - After making a decision, the page shows the decision badge and justification without reload
  </verify>
  <done>Decision workflow complete. Three-button UI with confirmation dialog and mandatory justification. API endpoint validates, records decision, updates case status, and creates audit log. UI updates immediately after decision. Regulatory-compliant with immutable decisions and mandatory documentation. (DASH-04)</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new/modified files
2. POST /api/cases/[id]/decision validates decision, justification, case status, and uniqueness
3. Missing or short justification returns 400 with clear error
4. Successful decision returns updated case with new status
5. Audit log entry created with full decision context
6. Decision workflow renders three action buttons for review cases
7. Confirmation dialog requires mandatory justification before submission
8. Case status updates immediately in UI after decision (no page reload needed)
9. Decision workflow hidden for non-review cases and cases with existing decisions
10. Error states displayed clearly in dialog
</verification>

<success_criteria>
- Officer can Approve, Deny, or Escalate with mandatory justification field (DASH-04 - Phase 6 Success Criterion #3)
- Decision is recorded and case status updates immediately (Phase 6 Success Criterion #4)
- Mandatory justification enforced — no empty or trivial entries accepted
- Audit trail created for every decision (foundation for Phase 9 REG-04)
- Decision is immutable once made — cannot be changed
- UI updates immediately without page reload
- Human-in-the-loop enforced — AI recommends, human decides (REG-01, REG-02)
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard-core/06-04-SUMMARY.md`
</output>

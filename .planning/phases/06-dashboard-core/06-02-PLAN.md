---
phase: 06-dashboard-core
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/app/api/cases/route.ts
  - src/app/dashboard/cases/page.tsx
  - src/components/cases/case-queue-table.tsx
  - src/components/cases/case-status-badge.tsx
  - src/components/cases/case-risk-badge.tsx
autonomous: true

must_haves:
  truths:
    - "GET /api/cases returns paginated list of cases from Supabase ordered by created_at desc"
    - "GET /api/cases?status=review filters cases by status"
    - "Case queue page displays a table of cases with applicant name, status, risk level, and created date"
    - "Each case row is clickable and links to /dashboard/cases/[id] for the detail view"
    - "Status badges use color-coded indicators matching STATUS_CONFIG from constants"
    - "Risk level badges show color-coded risk indicators matching RISK_LEVEL_CONFIG"
    - "Case queue shows cases in three implicit groups: pending/processing, review (ready), and completed (approved/denied/escalated)"
  artifacts:
    - path: "src/app/api/cases/route.ts"
      provides: "GET endpoint for listing cases with optional status filter"
      exports: ["GET"]
    - path: "src/app/dashboard/cases/page.tsx"
      provides: "Case queue page with tabbed view by status group"
      contains: "CaseQueueTable"
    - path: "src/components/cases/case-queue-table.tsx"
      provides: "Reusable table component rendering case list"
      exports: ["CaseQueueTable"]
    - path: "src/components/cases/case-status-badge.tsx"
      provides: "Status badge component using STATUS_CONFIG"
      exports: ["CaseStatusBadge"]
    - path: "src/components/cases/case-risk-badge.tsx"
      provides: "Risk level badge component using RISK_LEVEL_CONFIG"
      exports: ["CaseRiskBadge"]
  key_links:
    - from: "src/app/dashboard/cases/page.tsx"
      to: "src/components/cases/case-queue-table.tsx"
      via: "renders CaseQueueTable with fetched case data"
      pattern: "import.*CaseQueueTable.*from"
    - from: "src/app/dashboard/cases/page.tsx"
      to: "/api/cases"
      via: "fetches case list from API route"
      pattern: "fetch.*api/cases"
    - from: "src/components/cases/case-queue-table.tsx"
      to: "src/components/cases/case-status-badge.tsx"
      via: "renders CaseStatusBadge for each row"
      pattern: "import.*CaseStatusBadge"
    - from: "src/components/cases/case-queue-table.tsx"
      to: "/dashboard/cases/[id]"
      via: "links each row to case detail page"
      pattern: "href.*dashboard/cases"
    - from: "src/app/api/cases/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "queries cases table"
      pattern: "import.*createServerSupabaseClient"
---

<objective>
Build the case queue page (DASH-01) — the compliance officer's primary work surface showing all KYC cases organized by status with the API route to fetch case data from Supabase.

Purpose: The case queue is the first thing a compliance officer sees. It shows pending cases that need processing, cases ready for review, and completed cases. Each case links to the detail view (Plan 03). This is the core navigation hub for the compliance workflow.

Output: API route for listing cases, case queue page with tabbed status groups, reusable case table and badge components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-dashboard-core/06-01-SUMMARY.md
@src/types/index.ts (Case, CaseStatus, RiskLevel)
@src/lib/supabase/server.ts (createServerSupabaseClient)
@src/lib/constants.ts (STATUS_CONFIG, RISK_LEVEL_CONFIG, NAV_ITEMS)
@src/components/layout/dashboard-shell.tsx (DashboardShell)
@src/components/ui/table.tsx (shadcn Table components)
@src/components/ui/tabs.tsx (shadcn Tabs components)
@src/components/ui/badge.tsx (shadcn Badge)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cases API route and reusable badge components</name>
  <files>src/app/api/cases/route.ts, src/components/cases/case-status-badge.tsx, src/components/cases/case-risk-badge.tsx</files>
  <action>
    **Create `src/app/api/cases/route.ts`:**

    GET endpoint that returns cases from Supabase with optional status filtering.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { createServerSupabaseClient } from '@/lib/supabase/server';

    export async function GET(request: NextRequest) {
      try {
        const supabase = createServerSupabaseClient();
        const { searchParams } = new URL(request.url);

        const status = searchParams.get('status');
        const limit = parseInt(searchParams.get('limit') || '50', 10);
        const offset = parseInt(searchParams.get('offset') || '0', 10);

        let query = supabase
          .from('cases')
          .select('*', { count: 'exact' })
          .order('created_at', { ascending: false })
          .range(offset, offset + limit - 1);

        // Filter by status if provided
        if (status) {
          // Support comma-separated status values for grouping
          // e.g., ?status=pending,processing
          const statuses = status.split(',').map(s => s.trim());
          if (statuses.length === 1) {
            query = query.eq('status', statuses[0]);
          } else {
            query = query.in('status', statuses);
          }
        }

        const { data: cases, error, count } = await query;

        if (error) {
          console.error('Error fetching cases:', error);
          return NextResponse.json(
            { error: 'Failed to fetch cases' },
            { status: 500 }
          );
        }

        return NextResponse.json({
          cases: cases || [],
          total: count || 0,
          limit,
          offset,
        });
      } catch (error) {
        console.error('Cases API error:', error);
        return NextResponse.json(
          { error: error instanceof Error ? error.message : 'Internal error' },
          { status: 500 }
        );
      }
    }
    ```

    **Create `src/components/cases/case-status-badge.tsx`:**

    Reusable badge component for case status display. Uses STATUS_CONFIG from constants.

    ```typescript
    import { Badge } from '@/components/ui/badge';
    import { STATUS_CONFIG } from '@/lib/constants';
    import { CaseStatus } from '@/types';
    import { cn } from '@/lib/utils';

    interface CaseStatusBadgeProps {
      status: CaseStatus;
      className?: string;
    }

    export function CaseStatusBadge({ status, className }: CaseStatusBadgeProps) {
      const config = STATUS_CONFIG[status];

      if (!config) {
        return <Badge variant="outline">{status}</Badge>;
      }

      return (
        <Badge
          variant="outline"
          className={cn(config.className, 'font-medium', className)}
        >
          {config.label}
        </Badge>
      );
    }
    ```

    **Create `src/components/cases/case-risk-badge.tsx`:**

    Reusable badge component for risk level display. Uses RISK_LEVEL_CONFIG from constants.

    ```typescript
    import { Badge } from '@/components/ui/badge';
    import { RISK_LEVEL_CONFIG } from '@/lib/constants';
    import { RiskLevel } from '@/types';
    import { cn } from '@/lib/utils';

    interface CaseRiskBadgeProps {
      riskLevel: RiskLevel | null;
      riskScore?: number | null;
      className?: string;
    }

    export function CaseRiskBadge({ riskLevel, riskScore, className }: CaseRiskBadgeProps) {
      if (!riskLevel) {
        return (
          <Badge variant="outline" className={cn('text-muted-foreground', className)}>
            Not Scored
          </Badge>
        );
      }

      const config = RISK_LEVEL_CONFIG[riskLevel];

      return (
        <Badge
          variant="outline"
          className={cn(config.className, 'gap-1.5 font-medium', className)}
        >
          <div className={cn('h-2 w-2 rounded-full', config.dotColor)} />
          {config.label}
          {riskScore !== null && riskScore !== undefined && (
            <span className="ml-1 opacity-70">({riskScore})</span>
          )}
        </Badge>
      );
    }
    ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - API route exports GET handler
    - CaseStatusBadge renders correct colors for all 6 status values
    - CaseRiskBadge renders correct colors for all 4 risk levels + null state
    - API route supports ?status= query parameter with comma-separated values
    - API route returns { cases, total, limit, offset } shape
  </verify>
  <done>Cases API route and reusable badge components created. API supports status filtering and pagination. Badge components use centralized config for consistent display.</done>
</task>

<task type="auto">
  <name>Task 2: Create case queue page with tabbed table view</name>
  <files>src/components/cases/case-queue-table.tsx, src/app/dashboard/cases/page.tsx</files>
  <action>
    **Create `src/components/cases/case-queue-table.tsx`:**

    Reusable table component that displays a list of cases.

    ```typescript
    'use client';

    import Link from 'next/link';
    import { Case } from '@/types';
    import { CaseStatusBadge } from './case-status-badge';
    import { CaseRiskBadge } from './case-risk-badge';
    import {
      Table,
      TableBody,
      TableCell,
      TableHead,
      TableHeader,
      TableRow,
    } from '@/components/ui/table';
    import { cn } from '@/lib/utils';

    interface CaseQueueTableProps {
      cases: Case[];
      emptyMessage?: string;
    }

    export function CaseQueueTable({ cases, emptyMessage = 'No cases found.' }: CaseQueueTableProps) {
      if (cases.length === 0) {
        return (
          <div className="flex items-center justify-center py-12 text-sm text-muted-foreground">
            {emptyMessage}
          </div>
        );
      }

      return (
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[250px]">Applicant</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Risk Level</TableHead>
              <TableHead>Decision</TableHead>
              <TableHead className="text-right">Created</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {cases.map((caseItem) => (
              <TableRow
                key={caseItem.id}
                className="cursor-pointer hover:bg-muted/50"
              >
                <TableCell>
                  <Link
                    href={`/dashboard/cases/${caseItem.id}`}
                    className="block"
                  >
                    <div className="font-medium">{caseItem.applicant_name}</div>
                    {caseItem.applicant_email && (
                      <div className="text-xs text-muted-foreground">
                        {caseItem.applicant_email}
                      </div>
                    )}
                  </Link>
                </TableCell>
                <TableCell>
                  <Link href={`/dashboard/cases/${caseItem.id}`}>
                    <CaseStatusBadge status={caseItem.status} />
                  </Link>
                </TableCell>
                <TableCell>
                  <Link href={`/dashboard/cases/${caseItem.id}`}>
                    <CaseRiskBadge
                      riskLevel={caseItem.risk_level}
                      riskScore={caseItem.risk_score}
                    />
                  </Link>
                </TableCell>
                <TableCell>
                  <Link href={`/dashboard/cases/${caseItem.id}`}>
                    <span className={cn(
                      'text-sm',
                      caseItem.decision ? 'font-medium' : 'text-muted-foreground'
                    )}>
                      {caseItem.decision
                        ? caseItem.decision.charAt(0).toUpperCase() + caseItem.decision.slice(1)
                        : 'Pending'}
                    </span>
                  </Link>
                </TableCell>
                <TableCell className="text-right">
                  <Link href={`/dashboard/cases/${caseItem.id}`}>
                    <span className="text-sm text-muted-foreground">
                      {formatDate(caseItem.created_at)}
                    </span>
                  </Link>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      );
    }

    function formatDate(dateString: string): string {
      const date = new Date(dateString);
      return new Intl.DateTimeFormat('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
      }).format(date);
    }
    ```

    **Create `src/app/dashboard/cases/page.tsx`:**

    Case queue page with tabs for different status groups.

    ```typescript
    'use client';

    import { useEffect, useState, useCallback } from 'react';
    import { Case } from '@/types';
    import { DashboardShell } from '@/components/layout/dashboard-shell';
    import { CaseQueueTable } from '@/components/cases/case-queue-table';
    import { Card, CardContent } from '@/components/ui/card';
    import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
    import { Badge } from '@/components/ui/badge';
    import { Loader2 } from 'lucide-react';

    // Status groups for tabs
    const STATUS_GROUPS = {
      'in-progress': {
        label: 'In Progress',
        statuses: 'pending,processing',
        emptyMessage: 'No cases currently being processed.',
      },
      'review': {
        label: 'Ready for Review',
        statuses: 'review',
        emptyMessage: 'No cases awaiting review.',
      },
      'completed': {
        label: 'Completed',
        statuses: 'approved,denied,escalated',
        emptyMessage: 'No completed cases yet.',
      },
    } as const;

    type StatusGroup = keyof typeof STATUS_GROUPS;

    interface CaseResponse {
      cases: Case[];
      total: number;
    }

    export default function CaseQueuePage() {
      const [activeTab, setActiveTab] = useState<StatusGroup>('review');
      const [casesByGroup, setCasesByGroup] = useState<Record<StatusGroup, Case[]>>({
        'in-progress': [],
        'review': [],
        'completed': [],
      });
      const [countsByGroup, setCountsByGroup] = useState<Record<StatusGroup, number>>({
        'in-progress': 0,
        'review': 0,
        'completed': 0,
      });
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState<string | null>(null);

      const fetchCases = useCallback(async () => {
        setLoading(true);
        setError(null);

        try {
          // Fetch all three groups in parallel
          const results = await Promise.all(
            (Object.keys(STATUS_GROUPS) as StatusGroup[]).map(async (group) => {
              const response = await fetch(
                `/api/cases?status=${STATUS_GROUPS[group].statuses}&limit=50`
              );
              if (!response.ok) {
                throw new Error(`Failed to fetch ${group} cases`);
              }
              const data: CaseResponse = await response.json();
              return { group, cases: data.cases, total: data.total };
            })
          );

          const newCases: Record<StatusGroup, Case[]> = {
            'in-progress': [],
            'review': [],
            'completed': [],
          };
          const newCounts: Record<StatusGroup, number> = {
            'in-progress': 0,
            'review': 0,
            'completed': 0,
          };

          for (const result of results) {
            newCases[result.group] = result.cases;
            newCounts[result.group] = result.total;
          }

          setCasesByGroup(newCases);
          setCountsByGroup(newCounts);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to load cases');
        } finally {
          setLoading(false);
        }
      }, []);

      useEffect(() => {
        fetchCases();
      }, [fetchCases]);

      return (
        <DashboardShell
          title="Case Queue"
          description="Review and manage KYC/AML compliance cases"
        >
          <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as StatusGroup)}>
            <TabsList>
              {(Object.keys(STATUS_GROUPS) as StatusGroup[]).map((group) => (
                <TabsTrigger key={group} value={group} className="gap-2">
                  {STATUS_GROUPS[group].label}
                  <Badge variant="secondary" className="ml-1 h-5 px-1.5 text-xs">
                    {countsByGroup[group]}
                  </Badge>
                </TabsTrigger>
              ))}
            </TabsList>

            {loading ? (
              <div className="flex items-center justify-center py-12">
                <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
                <span className="ml-2 text-sm text-muted-foreground">Loading cases...</span>
              </div>
            ) : error ? (
              <Card className="mt-4">
                <CardContent className="py-8 text-center">
                  <p className="text-sm text-destructive">{error}</p>
                  <button
                    onClick={fetchCases}
                    className="mt-2 text-sm text-primary underline"
                  >
                    Retry
                  </button>
                </CardContent>
              </Card>
            ) : (
              (Object.keys(STATUS_GROUPS) as StatusGroup[]).map((group) => (
                <TabsContent key={group} value={group}>
                  <Card>
                    <CardContent className="p-0">
                      <CaseQueueTable
                        cases={casesByGroup[group]}
                        emptyMessage={STATUS_GROUPS[group].emptyMessage}
                      />
                    </CardContent>
                  </Card>
                </TabsContent>
              ))
            )}
          </Tabs>
        </DashboardShell>
      );
    }
    ```

    KEY DESIGN DECISIONS:
    - **Tabs for status groups** — "In Progress" (pending + processing), "Ready for Review" (review), "Completed" (approved + denied + escalated). This matches the compliance workflow: officer focuses on "Ready for Review" tab.
    - **Default tab is "review"** — most actionable for the compliance officer. They want to see cases waiting for their decision.
    - **Parallel fetch** — all three groups fetched simultaneously for fast initial load.
    - **Each row links to detail page** — the entire row is clickable, navigating to /dashboard/cases/[id] (built in Plan 03).
    - **Count badges on tabs** — shows at a glance how many cases are in each state.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run dev` and navigate to /dashboard/cases — page renders with tabs
    - Three tabs visible: "In Progress", "Ready for Review", "Completed" with count badges
    - With no cases in DB: shows appropriate empty messages per tab
    - With test cases in DB: table renders with applicant name, status badge, risk badge, decision, and date
    - Clicking a row navigates to /dashboard/cases/[id]
    - Status badges show correct colors (pending=slate, processing=blue, review=amber, approved=green, denied=red, escalated=purple)
    - Risk badges show correct colors (low=green, medium=amber, high=orange, critical=red) or "Not Scored" for null
    - Sidebar "Case Queue" link is highlighted when on /dashboard/cases
    - Loading spinner appears while fetching
    - Error state shows retry button
  </verify>
  <done>Case queue page complete with tabbed status groups, parallel data fetching, and interactive case table. Each row links to case detail view. API route supports status filtering and pagination. Reusable badge components render consistent status and risk indicators. (DASH-01)</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all new files
2. GET /api/cases returns JSON with { cases, total, limit, offset }
3. GET /api/cases?status=review returns only review cases
4. GET /api/cases?status=pending,processing returns both pending and processing cases
5. /dashboard/cases page renders with three tabs and case counts
6. Case table shows applicant name, status badge, risk badge, decision, and date
7. Clicking a case row navigates to /dashboard/cases/[id]
8. Empty states show helpful messages per tab
9. Loading and error states render correctly
</verification>

<success_criteria>
- Case queue displays pending, in-review, and completed cases with status indicators (DASH-01 - Phase 6 Success Criterion #1)
- Status badges are color-coded and consistent across the application
- Risk level badges show severity with color and score
- Case queue is the primary navigation hub for the compliance workflow
- API route provides flexible case listing with status filtering
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard-core/06-02-SUMMARY.md`
</output>

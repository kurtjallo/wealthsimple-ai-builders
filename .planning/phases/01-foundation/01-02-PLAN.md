---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - supabase/migrations/00001_initial_schema.sql
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/types.ts
  - src/app/api/health/route.ts
autonomous: true

must_haves:
  truths:
    - "Supabase database has cases, documents, agent_runs, and audit_logs tables"
    - "Application can read and write to Supabase from both client and server"
    - "Health check endpoint confirms database connectivity"
    - "Database types are generated and match the TypeScript domain types"
  artifacts:
    - path: "supabase/migrations/00001_initial_schema.sql"
      provides: "Complete database schema DDL"
      contains: "CREATE TABLE cases"
    - path: "src/lib/supabase/client.ts"
      provides: "Browser-side Supabase client"
      contains: "createBrowserClient"
    - path: "src/lib/supabase/server.ts"
      provides: "Server-side Supabase client"
      contains: "createServerClient"
    - path: "src/lib/supabase/types.ts"
      provides: "Database type definitions matching schema"
      contains: "Database"
  key_links:
    - from: "src/lib/supabase/client.ts"
      to: "NEXT_PUBLIC_SUPABASE_URL"
      via: "environment variable"
      pattern: "process.env.NEXT_PUBLIC_SUPABASE_URL"
    - from: "src/lib/supabase/server.ts"
      to: "SUPABASE_SERVICE_ROLE_KEY"
      via: "environment variable"
      pattern: "process.env.SUPABASE_SERVICE_ROLE_KEY"
    - from: "src/app/api/health/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "import and query"
      pattern: "import.*supabase"
---

<objective>
Set up the complete Supabase database schema for the KYC/AML system and create client/server Supabase utilities. The schema covers cases, documents, agent runs, and audit logs — the four core tables that the entire application builds on.

Purpose: Establish the data layer that all agents, API routes, and dashboard components will read from and write to.
Output: SQL migration file, typed Supabase clients (browser + server), and a health check that proves DB connectivity.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase database schema migration</name>
  <files>supabase/migrations/00001_initial_schema.sql</files>
  <action>
    Create `supabase/migrations/00001_initial_schema.sql` with the complete KYC/AML schema.

    IMPORTANT: This is a plain SQL file. It will be run directly against Supabase via the SQL editor or CLI. Use IF NOT EXISTS for idempotency.

    Tables to create:

    1. **cases** — Core case record for each KYC application
       ```sql
       CREATE TABLE IF NOT EXISTS cases (
         id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
         status TEXT NOT NULL DEFAULT 'pending'
           CHECK (status IN ('pending', 'processing', 'review', 'approved', 'denied', 'escalated')),
         applicant_name TEXT NOT NULL,
         applicant_email TEXT,
         risk_score REAL,
         risk_level TEXT CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),
         decision TEXT CHECK (decision IN ('approved', 'denied', 'escalated')),
         decision_justification TEXT,
         officer_id TEXT,
         narrative TEXT,
         created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
         updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
       );
       ```

    2. **documents** — Uploaded documents linked to cases
       ```sql
       CREATE TABLE IF NOT EXISTS documents (
         id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
         case_id UUID NOT NULL REFERENCES cases(id) ON DELETE CASCADE,
         type TEXT NOT NULL CHECK (type IN ('passport', 'drivers_license', 'utility_bill', 'bank_statement', 'corporate_doc')),
         file_name TEXT NOT NULL,
         file_url TEXT NOT NULL,
         ocr_output TEXT,
         extracted_data JSONB,
         confidence REAL,
         created_at TIMESTAMPTZ NOT NULL DEFAULT now()
       );
       ```

    3. **agent_runs** — Each agent execution for a case
       ```sql
       CREATE TABLE IF NOT EXISTS agent_runs (
         id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
         case_id UUID NOT NULL REFERENCES cases(id) ON DELETE CASCADE,
         agent_type TEXT NOT NULL
           CHECK (agent_type IN ('orchestrator', 'document_processor', 'identity_verifier', 'sanctions_screener', 'risk_scorer', 'case_narrator')),
         status TEXT NOT NULL DEFAULT 'pending'
           CHECK (status IN ('pending', 'running', 'completed', 'failed')),
         started_at TIMESTAMPTZ,
         completed_at TIMESTAMPTZ,
         input JSONB,
         output JSONB,
         confidence REAL,
         error TEXT,
         created_at TIMESTAMPTZ NOT NULL DEFAULT now()
       );
       ```

    4. **audit_logs** — Immutable audit trail
       ```sql
       CREATE TABLE IF NOT EXISTS audit_logs (
         id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
         case_id UUID NOT NULL REFERENCES cases(id) ON DELETE CASCADE,
         action TEXT NOT NULL,
         actor_type TEXT NOT NULL CHECK (actor_type IN ('system', 'agent', 'officer')),
         actor_id TEXT NOT NULL,
         details JSONB,
         created_at TIMESTAMPTZ NOT NULL DEFAULT now()
       );
       ```

    5. **Indexes** for common query patterns:
       ```sql
       CREATE INDEX IF NOT EXISTS idx_cases_status ON cases(status);
       CREATE INDEX IF NOT EXISTS idx_cases_created_at ON cases(created_at DESC);
       CREATE INDEX IF NOT EXISTS idx_documents_case_id ON documents(case_id);
       CREATE INDEX IF NOT EXISTS idx_agent_runs_case_id ON agent_runs(case_id);
       CREATE INDEX IF NOT EXISTS idx_agent_runs_status ON agent_runs(status);
       CREATE INDEX IF NOT EXISTS idx_audit_logs_case_id ON audit_logs(case_id);
       CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at DESC);
       ```

    6. **Updated_at trigger** for cases:
       ```sql
       CREATE OR REPLACE FUNCTION update_updated_at()
       RETURNS TRIGGER AS $$
       BEGIN
         NEW.updated_at = now();
         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql;

       CREATE TRIGGER cases_updated_at
         BEFORE UPDATE ON cases
         FOR EACH ROW
         EXECUTE FUNCTION update_updated_at();
       ```

    7. **Row Level Security** — Enable RLS but allow all operations for now (single-user demo):
       ```sql
       ALTER TABLE cases ENABLE ROW LEVEL SECURITY;
       ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
       ALTER TABLE agent_runs ENABLE ROW LEVEL SECURITY;
       ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

       -- Permissive policies for demo (single-user, no auth)
       CREATE POLICY "Allow all on cases" ON cases FOR ALL USING (true) WITH CHECK (true);
       CREATE POLICY "Allow all on documents" ON documents FOR ALL USING (true) WITH CHECK (true);
       CREATE POLICY "Allow all on agent_runs" ON agent_runs FOR ALL USING (true) WITH CHECK (true);
       CREATE POLICY "Allow all on audit_logs" ON audit_logs FOR ALL USING (true) WITH CHECK (true);
       ```
  </action>
  <verify>
    - SQL file exists at `supabase/migrations/00001_initial_schema.sql`
    - SQL syntax is valid (no obvious errors)
    - All 4 tables defined: cases, documents, agent_runs, audit_logs
    - Foreign keys reference cases(id) with ON DELETE CASCADE
    - CHECK constraints match TypeScript union types in src/types/index.ts
    - Indexes cover case_id foreign keys and common query columns
  </verify>
  <done>
    Complete database schema SQL ready to execute against Supabase. Schema matches domain types exactly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Supabase client utilities and database types</name>
  <files>
    src/lib/supabase/client.ts, src/lib/supabase/server.ts,
    src/lib/supabase/types.ts, src/app/api/health/route.ts
  </files>
  <action>
    1. Create `src/lib/supabase/types.ts` — Database type definitions that match the SQL schema.

       Define a `Database` type with `public.Tables` for each table (Row, Insert, Update variants). This mirrors what `supabase gen types` would produce but is hand-written to avoid requiring the Supabase CLI at this stage:

       ```typescript
       export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];

       export interface Database {
         public: {
           Tables: {
             cases: {
               Row: {
                 id: string;
                 status: string;
                 applicant_name: string;
                 applicant_email: string | null;
                 risk_score: number | null;
                 risk_level: string | null;
                 decision: string | null;
                 decision_justification: string | null;
                 officer_id: string | null;
                 narrative: string | null;
                 created_at: string;
                 updated_at: string;
               };
               Insert: {
                 id?: string;
                 status?: string;
                 applicant_name: string;
                 applicant_email?: string | null;
                 risk_score?: number | null;
                 risk_level?: string | null;
                 decision?: string | null;
                 decision_justification?: string | null;
                 officer_id?: string | null;
                 narrative?: string | null;
                 created_at?: string;
                 updated_at?: string;
               };
               Update: {
                 id?: string;
                 status?: string;
                 applicant_name?: string;
                 applicant_email?: string | null;
                 risk_score?: number | null;
                 risk_level?: string | null;
                 decision?: string | null;
                 decision_justification?: string | null;
                 officer_id?: string | null;
                 narrative?: string | null;
                 created_at?: string;
                 updated_at?: string;
               };
             };
             documents: {
               Row: {
                 id: string;
                 case_id: string;
                 type: string;
                 file_name: string;
                 file_url: string;
                 ocr_output: string | null;
                 extracted_data: Json | null;
                 confidence: number | null;
                 created_at: string;
               };
               Insert: {
                 id?: string;
                 case_id: string;
                 type: string;
                 file_name: string;
                 file_url: string;
                 ocr_output?: string | null;
                 extracted_data?: Json | null;
                 confidence?: number | null;
                 created_at?: string;
               };
               Update: {
                 id?: string;
                 case_id?: string;
                 type?: string;
                 file_name?: string;
                 file_url?: string;
                 ocr_output?: string | null;
                 extracted_data?: Json | null;
                 confidence?: number | null;
                 created_at?: string;
               };
             };
             agent_runs: {
               Row: {
                 id: string;
                 case_id: string;
                 agent_type: string;
                 status: string;
                 started_at: string | null;
                 completed_at: string | null;
                 input: Json | null;
                 output: Json | null;
                 confidence: number | null;
                 error: string | null;
                 created_at: string;
               };
               Insert: {
                 id?: string;
                 case_id: string;
                 agent_type: string;
                 status?: string;
                 started_at?: string | null;
                 completed_at?: string | null;
                 input?: Json | null;
                 output?: Json | null;
                 confidence?: number | null;
                 error?: string | null;
                 created_at?: string;
               };
               Update: {
                 id?: string;
                 case_id?: string;
                 agent_type?: string;
                 status?: string;
                 started_at?: string | null;
                 completed_at?: string | null;
                 input?: Json | null;
                 output?: Json | null;
                 confidence?: number | null;
                 error?: string | null;
                 created_at?: string;
               };
             };
             audit_logs: {
               Row: {
                 id: string;
                 case_id: string;
                 action: string;
                 actor_type: string;
                 actor_id: string;
                 details: Json | null;
                 created_at: string;
               };
               Insert: {
                 id?: string;
                 case_id: string;
                 action: string;
                 actor_type: string;
                 actor_id: string;
                 details?: Json | null;
                 created_at?: string;
               };
               Update: {
                 id?: string;
                 case_id?: string;
                 action?: string;
                 actor_type?: string;
                 actor_id?: string;
                 details?: Json | null;
                 created_at?: string;
               };
             };
           };
         };
       }
       ```

    2. Create `src/lib/supabase/client.ts` — Browser-side Supabase client:

       ```typescript
       import { createClient } from "@supabase/supabase-js";
       import { Database } from "./types";

       const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
       const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

       export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);
       ```

    3. Create `src/lib/supabase/server.ts` — Server-side Supabase client with service role key (for API routes and server components):

       ```typescript
       import { createClient } from "@supabase/supabase-js";
       import { Database } from "./types";

       export function createServerSupabaseClient() {
         const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
         const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

         if (!supabaseUrl || !supabaseServiceKey) {
           throw new Error("Missing Supabase environment variables");
         }

         return createClient<Database>(supabaseUrl, supabaseServiceKey, {
           auth: { persistSession: false },
         });
       }
       ```

    4. Update `src/app/api/health/route.ts` to include a Supabase connectivity check:

       ```typescript
       import { NextResponse } from "next/server";
       import { createServerSupabaseClient } from "@/lib/supabase/server";

       export async function GET() {
         const checks: Record<string, string> = {
           server: "ok",
         };

         // Check Supabase connectivity
         try {
           const supabase = createServerSupabaseClient();
           const { error } = await supabase.from("cases").select("id").limit(1);
           checks.database = error ? `error: ${error.message}` : "ok";
         } catch (e) {
           checks.database = e instanceof Error ? `error: ${e.message}` : "error: unknown";
         }

         const allOk = Object.values(checks).every((v) => v === "ok");

         return NextResponse.json({
           status: allOk ? "ok" : "degraded",
           timestamp: new Date().toISOString(),
           version: "0.1.0",
           checks,
         });
       }
       ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes (all Supabase types compile)
    - `src/lib/supabase/client.ts` exports `supabase` client
    - `src/lib/supabase/server.ts` exports `createServerSupabaseClient` function
    - `src/lib/supabase/types.ts` exports `Database` interface with all 4 tables
    - Database type Row fields match the SQL schema columns exactly
    - Health check returns JSON with `checks.database` field
    - With valid Supabase credentials in .env.local: `curl localhost:3000/api/health` returns `{"status":"ok","checks":{"server":"ok","database":"ok"}}`
    - Without credentials: health check returns degraded status (doesn't crash)
  </verify>
  <done>
    Supabase client and server utilities created with full type safety. Database types match SQL schema. Health check validates DB connectivity. Schema SQL ready to run on Supabase.
  </done>
</task>

</tasks>

<verification>
1. SQL migration file contains valid CREATE TABLE statements for all 4 tables
2. TypeScript compiles with `npx tsc --noEmit` — no errors
3. Database types in `src/lib/supabase/types.ts` match SQL schema columns
4. Supabase client (browser) and server client both instantiate without errors
5. Health check endpoint reports database status
6. With Supabase configured: `curl localhost:3000/api/health` shows `database: "ok"`
</verification>

<success_criteria>
- Supabase database schema defined for cases, documents, agent_runs, audit_logs (Phase 1 Success Criterion #2)
- Typed Supabase clients ready for use by all API routes and components
- Database connectivity verified through health check endpoint
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>

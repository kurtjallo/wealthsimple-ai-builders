---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/agents/client.ts
  - src/lib/agents/test.ts
  - src/app/api/agents/test/route.ts
  - src/app/api/health/route.ts
autonomous: true

must_haves:
  truths:
    - "Google GenAI SDK client is initialized and can make API calls"
    - "A test endpoint proves the SDK works by getting a response from Gemini"
    - "Health check endpoint reports Gemini SDK connectivity status"
    - "Agent client is reusable across all future agent implementations"
  artifacts:
    - path: "src/lib/agents/client.ts"
      provides: "Configured GoogleGenerativeAI client singleton"
      contains: "GoogleGenerativeAI"
    - path: "src/app/api/agents/test/route.ts"
      provides: "Test endpoint that calls Gemini and returns a response"
      exports: ["POST"]
  key_links:
    - from: "src/lib/agents/client.ts"
      to: "GEMINI_API_KEY"
      via: "environment variable"
      pattern: "process.env.GEMINI_API_KEY"
    - from: "src/app/api/agents/test/route.ts"
      to: "src/lib/agents/client.ts"
      via: "import"
      pattern: "import.*agents/client"
    - from: "src/app/api/health/route.ts"
      to: "src/lib/agents/client.ts"
      via: "import for health check"
      pattern: "import.*agents"
---

<objective>
Set up the Google GenAI SDK with a reusable client, create a test endpoint that proves SDK connectivity, and update the health check to report Gemini API status.

Purpose: Establish the AI backbone that all agents will use. Prove Gemini API connectivity before building specialized agents in Phase 2.
Output: Working GoogleGenerativeAI client, test API route returning Gemini responses, health check with Gemini status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GoogleGenerativeAI client and test utilities</name>
  <files>src/lib/agents/client.ts, src/lib/agents/test.ts</files>
  <action>
    1. Create `src/lib/agents/client.ts` — Singleton GoogleGenerativeAI client:

       ```typescript
       import { GoogleGenerativeAI } from "@google/generative-ai";

       let client: GoogleGenerativeAI | null = null;

       export function getGoogleGenAIClient(): GoogleGenerativeAI {
         if (!client) {
           const apiKey = process.env.GEMINI_API_KEY;
           if (!apiKey) {
             throw new Error("Missing GEMINI_API_KEY environment variable");
           }
           client = new GoogleGenerativeAI(apiKey);
         }
         return client;
       }

       // Default model configuration for the project
       export const MODEL_CONFIG = {
         // Primary reasoning model
         reasoning: "gemini-2.5-pro" as const,
         // Fast routing model
         routing: "gemini-2.5-flash" as const,
         // Max tokens for standard responses
         maxTokens: 4096,
       } as const;
       ```

       IMPORTANT: Use `gemini-2.5-pro` as the model ID (per PROJECT.md: "Gemini 2.5 Pro"). The Google GenAI SDK uses the `@google/generative-ai` package — this was installed in Plan 01.

    2. Create `src/lib/agents/test.ts` — Test utility to verify SDK connectivity:

       ```typescript
       import { getGoogleGenAIClient, MODEL_CONFIG } from "./client";

       export async function testGeminiConnectivity(): Promise<{
         success: boolean;
         model: string;
         response?: string;
         error?: string;
         latencyMs: number;
       }> {
         const start = Date.now();
         try {
           const client = getGoogleGenAIClient();
           const model = client.getGenerativeModel({ model: MODEL_CONFIG.routing });
           const result = await model.generateContent("Respond with exactly: CONNECTED");
           const text = result.response.text();

           return {
             success: true,
             model: MODEL_CONFIG.routing,
             response: text.trim(),
             latencyMs: Date.now() - start,
           };
         } catch (e) {
           return {
             success: false,
             model: MODEL_CONFIG.routing,
             error: e instanceof Error ? e.message : "Unknown error",
             latencyMs: Date.now() - start,
           };
         }
       }
       ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/lib/agents/client.ts` exports `getGoogleGenAIClient` and `MODEL_CONFIG`
    - `src/lib/agents/test.ts` exports `testGeminiConnectivity`
    - Model IDs use gemini-2.5-pro and gemini-2.5-flash
  </verify>
  <done>
    GoogleGenerativeAI client singleton and test utility created. Client is reusable across all future agent implementations. Model config centralizes model IDs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test API route and update health check with Gemini status</name>
  <files>src/app/api/agents/test/route.ts, src/app/api/health/route.ts</files>
  <action>
    1. Create `src/app/api/agents/test/route.ts` — Test endpoint that exercises the Google GenAI SDK:

       ```typescript
       import { NextResponse } from "next/server";
       import { testGeminiConnectivity } from "@/lib/agents/test";

       export async function POST() {
         const result = await testGeminiConnectivity();

         return NextResponse.json(result, {
           status: result.success ? 200 : 503,
         });
       }
       ```

    2. Update `src/app/api/health/route.ts` to also check Google GenAI SDK connectivity.

       IMPORTANT: This file was modified by Plan 02 (which runs in parallel). The executor should READ the file first and merge changes. The health check should now check BOTH Supabase AND Gemini.

       If Plan 02 has already added Supabase checks, add the Gemini check alongside. If Plan 02 hasn't run yet, add both the server check and the Gemini check.

       Add to the health check:
       ```typescript
       // Check Google GenAI SDK connectivity
       try {
         const { getGoogleGenAIClient } = await import("@/lib/agents/client");
         getGoogleGenAIClient(); // Validates API key exists
         checks.gemini = "ok";
       } catch (e) {
         checks.gemini = e instanceof Error ? `error: ${e.message}` : "error: unknown";
       }
       ```

       NOTE: This only checks that the client initializes (API key present). It does NOT make an API call on every health check. The `/api/agents/test` endpoint is for actual connectivity testing.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `curl -X POST http://localhost:3000/api/agents/test` returns JSON with `success: true` (when GEMINI_API_KEY is set)
    - `curl http://localhost:3000/api/health` returns JSON with `checks.gemini` field
    - Without API key: test endpoint returns 503 with error message (doesn't crash)
    - With valid API key: test endpoint returns 200 with `success: true`, `model` field, and `response` containing "CONNECTED"
  </verify>
  <done>
    Google GenAI SDK test endpoint working. Health check reports Gemini status. SDK responds to API calls when key is configured.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. GoogleGenerativeAI client initializes when GEMINI_API_KEY is set
3. `curl -X POST localhost:3000/api/agents/test` returns Gemini response with "CONNECTED"
4. Health check at `/api/health` reports both `database` and `gemini` status
5. Model IDs use current Gemini model versions (2.5 Pro, 2.5 Flash)
6. Error handling works — missing API key returns clear error, doesn't crash server
</verification>

<success_criteria>
- Google GenAI SDK initialized and responding to test calls (Phase 1 Success Criterion #3)
- Reusable GoogleGenerativeAI client with centralized model config
- Test endpoint proves end-to-end SDK connectivity
- Health check gives a complete system status (server + database + Gemini)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
